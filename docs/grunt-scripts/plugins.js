/*!
 * jQuery JavaScript Library v1.10.2
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2013-07-03T13:48Z
 */
(function (window, undefined) {
  // Can't do this because several apps including ASP.NET trace
  // the stack via arguments.caller.callee and Firefox dies if
  // you try to trace through "use strict" call chains. (#13335)
  // Support: Firefox 18+
  //"use strict";
  var
    // The deferred used on DOM ready
    readyList,
    // A central reference to the root jQuery(document)
    rootjQuery,
    // Support: IE<10
    // For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`
    core_strundefined = typeof undefined,
    // Use the correct document accordingly with window argument (sandbox)
    location = window.location, document = window.document, docElem = document.documentElement,
    // Map over jQuery in case of overwrite
    _jQuery = window.jQuery,
    // Map over the $ in case of overwrite
    _$ = window.$,
    // [[Class]] -> type pairs
    class2type = {},
    // List of deleted data cache ids, so we can reuse them
    core_deletedIds = [], core_version = '1.10.2',
    // Save a reference to some core methods
    core_concat = core_deletedIds.concat, core_push = core_deletedIds.push, core_slice = core_deletedIds.slice, core_indexOf = core_deletedIds.indexOf, core_toString = class2type.toString, core_hasOwn = class2type.hasOwnProperty, core_trim = core_version.trim,
    // Define a local copy of jQuery
    jQuery = function (selector, context) {
      // The jQuery object is actually just the init constructor 'enhanced'
      return new jQuery.fn.init(selector, context, rootjQuery);
    },
    // Used for matching numbers
    core_pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
    // Used for splitting on whitespace
    core_rnotwhite = /\S+/g,
    // Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
    // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
    // Match a standalone tag
    rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/,
    // JSON RegExp
    rvalidchars = /^[\],:{}\s]*$/, rvalidbraces = /(?:^|:|,)(?:\s*\[)+/g, rvalidescape = /\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g, rvalidtokens = /"[^"\\\r\n]*"|true|false|null|-?(?:\d+\.|)\d+(?:[eE][+-]?\d+|)/g,
    // Matches dashed string for camelizing
    rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi,
    // Used by jQuery.camelCase as callback to replace()
    fcamelCase = function (all, letter) {
      return letter.toUpperCase();
    },
    // The ready event handler
    completed = function (event) {
      // readyState === "complete" is good enough for us to call the dom ready in oldIE
      if (document.addEventListener || event.type === 'load' || document.readyState === 'complete') {
        detach();
        jQuery.ready();
      }
    },
    // Clean-up method for dom ready events
    detach = function () {
      if (document.addEventListener) {
        document.removeEventListener('DOMContentLoaded', completed, false);
        window.removeEventListener('load', completed, false);
      } else {
        document.detachEvent('onreadystatechange', completed);
        window.detachEvent('onload', completed);
      }
    };
  jQuery.fn = jQuery.prototype = {
    jquery: core_version,
    constructor: jQuery,
    init: function (selector, context, rootjQuery) {
      var match, elem;
      // HANDLE: $(""), $(null), $(undefined), $(false)
      if (!selector) {
        return this;
      }
      // Handle HTML strings
      if (typeof selector === 'string') {
        if (selector.charAt(0) === '<' && selector.charAt(selector.length - 1) === '>' && selector.length >= 3) {
          // Assume that strings that start and end with <> are HTML and skip the regex check
          match = [
            null,
            selector,
            null
          ];
        } else {
          match = rquickExpr.exec(selector);
        }
        // Match html or make sure no context is specified for #id
        if (match && (match[1] || !context)) {
          // HANDLE: $(html) -> $(array)
          if (match[1]) {
            context = context instanceof jQuery ? context[0] : context;
            // scripts is true for back-compat
            jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
            // HANDLE: $(html, props)
            if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
              for (match in context) {
                // Properties of context are called as methods if possible
                if (jQuery.isFunction(this[match])) {
                  this[match](context[match]);  // ...and otherwise set as attributes
                } else {
                  this.attr(match, context[match]);
                }
              }
            }
            return this;  // HANDLE: $(#id)
          } else {
            elem = document.getElementById(match[2]);
            // Check parentNode to catch when Blackberry 4.6 returns
            // nodes that are no longer in the document #6963
            if (elem && elem.parentNode) {
              // Handle the case where IE and Opera return items
              // by name instead of ID
              if (elem.id !== match[2]) {
                return rootjQuery.find(selector);
              }
              // Otherwise, we inject the element directly into the jQuery object
              this.length = 1;
              this[0] = elem;
            }
            this.context = document;
            this.selector = selector;
            return this;
          }  // HANDLE: $(expr, $(...))
        } else if (!context || context.jquery) {
          return (context || rootjQuery).find(selector);  // HANDLE: $(expr, context)
                                                          // (which is just equivalent to: $(context).find(expr)
        } else {
          return this.constructor(context).find(selector);
        }  // HANDLE: $(DOMElement)
      } else if (selector.nodeType) {
        this.context = this[0] = selector;
        this.length = 1;
        return this;  // HANDLE: $(function)
                      // Shortcut for document ready
      } else if (jQuery.isFunction(selector)) {
        return rootjQuery.ready(selector);
      }
      if (selector.selector !== undefined) {
        this.selector = selector.selector;
        this.context = selector.context;
      }
      return jQuery.makeArray(selector, this);
    },
    selector: '',
    length: 0,
    toArray: function () {
      return core_slice.call(this);
    },
    get: function (num) {
      return num == null ? this.toArray() : num < 0 ? this[this.length + num] : this[num];
    },
    pushStack: function (elems) {
      // Build a new jQuery matched element set
      var ret = jQuery.merge(this.constructor(), elems);
      // Add the old object onto the stack (as a reference)
      ret.prevObject = this;
      ret.context = this.context;
      // Return the newly-formed element set
      return ret;
    },
    each: function (callback, args) {
      return jQuery.each(this, callback, args);
    },
    ready: function (fn) {
      // Add the callback
      jQuery.ready.promise().done(fn);
      return this;
    },
    slice: function () {
      return this.pushStack(core_slice.apply(this, arguments));
    },
    first: function () {
      return this.eq(0);
    },
    last: function () {
      return this.eq(-1);
    },
    eq: function (i) {
      var len = this.length, j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    map: function (callback) {
      return this.pushStack(jQuery.map(this, function (elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    end: function () {
      return this.prevObject || this.constructor(null);
    },
    push: core_push,
    sort: [].sort,
    splice: [].splice
  };
  // Give the init function the jQuery prototype for later instantiation
  jQuery.fn.init.prototype = jQuery.fn;
  jQuery.extend = jQuery.fn.extend = function () {
    var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
    // Handle a deep copy situation
    if (typeof target === 'boolean') {
      deep = target;
      target = arguments[1] || {};
      // skip the boolean and the target
      i = 2;
    }
    // Handle case when target is a string or something (possible in deep copy)
    if (typeof target !== 'object' && !jQuery.isFunction(target)) {
      target = {};
    }
    // extend jQuery itself if only one argument is passed
    if (length === i) {
      target = this;
      --i;
    }
    for (; i < length; i++) {
      // Only deal with non-null/undefined values
      if ((options = arguments[i]) != null) {
        // Extend the base object
        for (name in options) {
          src = target[name];
          copy = options[name];
          // Prevent never-ending loop
          if (target === copy) {
            continue;
          }
          // Recurse if we're merging plain objects or arrays
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            // Never move original objects, clone them
            target[name] = jQuery.extend(deep, clone, copy);  // Don't bring in undefined values
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    // Return the modified object
    return target;
  };
  jQuery.extend({
    expando: 'jQuery' + (core_version + Math.random()).replace(/\D/g, ''),
    noConflict: function (deep) {
      if (window.$ === jQuery) {
        window.$ = _$;
      }
      if (deep && window.jQuery === jQuery) {
        window.jQuery = _jQuery;
      }
      return jQuery;
    },
    isReady: false,
    readyWait: 1,
    holdReady: function (hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function (wait) {
      // Abort if there are pending holds or we're already ready
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).
      if (!document.body) {
        return setTimeout(jQuery.ready);
      }
      // Remember that the DOM is ready
      jQuery.isReady = true;
      // If a normal DOM Ready event fired, decrement, and wait if need be
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }
      // If there are functions bound, to execute
      readyList.resolveWith(document, [jQuery]);
      // Trigger any bound ready events
      if (jQuery.fn.trigger) {
        jQuery(document).trigger('ready').off('ready');
      }
    },
    isFunction: function (obj) {
      return jQuery.type(obj) === 'function';
    },
    isArray: Array.isArray || function (obj) {
      return jQuery.type(obj) === 'array';
    },
    isWindow: function (obj) {
      /* jshint eqeqeq: false */
      return obj != null && obj == obj.window;
    },
    isNumeric: function (obj) {
      return !isNaN(parseFloat(obj)) && isFinite(obj);
    },
    type: function (obj) {
      if (obj == null) {
        return String(obj);
      }
      return typeof obj === 'object' || typeof obj === 'function' ? class2type[core_toString.call(obj)] || 'object' : typeof obj;
    },
    isPlainObject: function (obj) {
      var key;
      // Must be an Object.
      // Because of IE, we also have to check the presence of the constructor property.
      // Make sure that DOM nodes and window objects don't pass through, as well
      if (!obj || jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }
      try {
        // Not own constructor property must be Object
        if (obj.constructor && !core_hasOwn.call(obj, 'constructor') && !core_hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
          return false;
        }
      } catch (e) {
        // IE8,9 Will throw exceptions on certain host objects #9897
        return false;
      }
      // Support: IE<9
      // Handle iteration over inherited properties before own properties.
      if (jQuery.support.ownLast) {
        for (key in obj) {
          return core_hasOwn.call(obj, key);
        }
      }
      // Own properties are enumerated firstly, so to speed up,
      // if last one is own, then all properties are own.
      for (key in obj) {
      }
      return key === undefined || core_hasOwn.call(obj, key);
    },
    isEmptyObject: function (obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    error: function (msg) {
      throw new Error(msg);
    },
    parseHTML: function (data, context, keepScripts) {
      if (!data || typeof data !== 'string') {
        return null;
      }
      if (typeof context === 'boolean') {
        keepScripts = context;
        context = false;
      }
      context = context || document;
      var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
      // Single tag
      if (parsed) {
        return [context.createElement(parsed[1])];
      }
      parsed = jQuery.buildFragment([data], context, scripts);
      if (scripts) {
        jQuery(scripts).remove();
      }
      return jQuery.merge([], parsed.childNodes);
    },
    parseJSON: function (data) {
      // Attempt to parse using the native JSON parser first
      if (window.JSON && window.JSON.parse) {
        return window.JSON.parse(data);
      }
      if (data === null) {
        return data;
      }
      if (typeof data === 'string') {
        // Make sure leading/trailing whitespace is removed (IE can't handle it)
        data = jQuery.trim(data);
        if (data) {
          // Make sure the incoming data is actual JSON
          // Logic borrowed from http://json.org/json2.js
          if (rvalidchars.test(data.replace(rvalidescape, '@').replace(rvalidtokens, ']').replace(rvalidbraces, ''))) {
            return new Function('return ' + data)();
          }
        }
      }
      jQuery.error('Invalid JSON: ' + data);
    },
    parseXML: function (data) {
      var xml, tmp;
      if (!data || typeof data !== 'string') {
        return null;
      }
      try {
        if (window.DOMParser) {
          // Standard
          tmp = new DOMParser();
          xml = tmp.parseFromString(data, 'text/xml');
        } else {
          // IE
          xml = new ActiveXObject('Microsoft.XMLDOM');
          xml.async = 'false';
          xml.loadXML(data);
        }
      } catch (e) {
        xml = undefined;
      }
      if (!xml || !xml.documentElement || xml.getElementsByTagName('parsererror').length) {
        jQuery.error('Invalid XML: ' + data);
      }
      return xml;
    },
    noop: function () {
    },
    globalEval: function (data) {
      if (data && jQuery.trim(data)) {
        // We use execScript on Internet Explorer
        // We use an anonymous function so that context is window
        // rather than jQuery in Firefox
        (window.execScript || function (data) {
          window['eval'].call(window, data);
        })(data);
      }
    },
    camelCase: function (string) {
      return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
    },
    nodeName: function (elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    each: function (obj, callback, args) {
      var value, i = 0, length = obj.length, isArray = isArraylike(obj);
      if (args) {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.apply(obj[i], args);
            if (value === false) {
              break;
            }
          }
        }  // A special, fast, case for the most common use of each
      } else {
        if (isArray) {
          for (; i < length; i++) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        } else {
          for (i in obj) {
            value = callback.call(obj[i], i, obj[i]);
            if (value === false) {
              break;
            }
          }
        }
      }
      return obj;
    },
    trim: core_trim && !core_trim.call('\ufeff\xa0') ? function (text) {
      return text == null ? '' : core_trim.call(text);
    } : function (text) {
      return text == null ? '' : (text + '').replace(rtrim, '');
    },
    makeArray: function (arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArraylike(Object(arr))) {
          jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
        } else {
          core_push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function (elem, arr, i) {
      var len;
      if (arr) {
        if (core_indexOf) {
          return core_indexOf.call(arr, elem, i);
        }
        len = arr.length;
        i = i ? i < 0 ? Math.max(0, len + i) : i : 0;
        for (; i < len; i++) {
          // Skip accessing in sparse arrays
          if (i in arr && arr[i] === elem) {
            return i;
          }
        }
      }
      return -1;
    },
    merge: function (first, second) {
      var l = second.length, i = first.length, j = 0;
      if (typeof l === 'number') {
        for (; j < l; j++) {
          first[i++] = second[j];
        }
      } else {
        while (second[j] !== undefined) {
          first[i++] = second[j++];
        }
      }
      first.length = i;
      return first;
    },
    grep: function (elems, callback, inv) {
      var retVal, ret = [], i = 0, length = elems.length;
      inv = !!inv;
      // Go through the array, only saving the items
      // that pass the validator function
      for (; i < length; i++) {
        retVal = !!callback(elems[i], i);
        if (inv !== retVal) {
          ret.push(elems[i]);
        }
      }
      return ret;
    },
    map: function (elems, callback, arg) {
      var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
      // Go through the array, translating each of the items to their
      if (isArray) {
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret[ret.length] = value;
          }
        }  // Go through every key on the object,
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret[ret.length] = value;
          }
        }
      }
      // Flatten any nested arrays
      return core_concat.apply([], ret);
    },
    guid: 1,
    proxy: function (fn, context) {
      var args, proxy, tmp;
      if (typeof context === 'string') {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      // Quick check to determine if target is callable, in the spec
      // this throws a TypeError, but we will just return undefined.
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      // Simulated bind
      args = core_slice.call(arguments, 2);
      proxy = function () {
        return fn.apply(context || this, args.concat(core_slice.call(arguments)));
      };
      // Set the guid of unique handler to the same of original handler, so it can be removed
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    access: function (elems, fn, key, value, chainable, emptyGet, raw) {
      var i = 0, length = elems.length, bulk = key == null;
      // Sets many values
      if (jQuery.type(key) === 'object') {
        chainable = true;
        for (i in key) {
          jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
        }  // Sets one value
      } else if (value !== undefined) {
        chainable = true;
        if (!jQuery.isFunction(value)) {
          raw = true;
        }
        if (bulk) {
          // Bulk operations run against the entire set
          if (raw) {
            fn.call(elems, value);
            fn = null;  // ...except when executing function values
          } else {
            bulk = fn;
            fn = function (elem, key, value) {
              return bulk.call(jQuery(elem), value);
            };
          }
        }
        if (fn) {
          for (; i < length; i++) {
            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
          }
        }
      }
      return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
    },
    now: function () {
      return new Date().getTime();
    },
    swap: function (elem, options, callback, args) {
      var ret, name, old = {};
      // Remember the old values, and insert the new ones
      for (name in options) {
        old[name] = elem.style[name];
        elem.style[name] = options[name];
      }
      ret = callback.apply(elem, args || []);
      // Revert the old values
      for (name in options) {
        elem.style[name] = old[name];
      }
      return ret;
    }
  });
  jQuery.ready.promise = function (obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();
      // Catch cases where $(document).ready() is called after the browser event has already occurred.
      // we once tried to use readyState "interactive" here, but it caused issues like the one
      // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15
      if (document.readyState === 'complete') {
        // Handle it asynchronously to allow scripts the opportunity to delay ready
        setTimeout(jQuery.ready);  // Standards-based browsers support DOMContentLoaded
      } else if (document.addEventListener) {
        // Use the handy event callback
        document.addEventListener('DOMContentLoaded', completed, false);
        // A fallback to window.onload, that will always work
        window.addEventListener('load', completed, false);  // If IE event model is used
      } else {
        // Ensure firing before onload, maybe late but safe also for iframes
        document.attachEvent('onreadystatechange', completed);
        // A fallback to window.onload, that will always work
        window.attachEvent('onload', completed);
        // If IE and not a frame
        // continually check to see if the document is ready
        var top = false;
        try {
          top = window.frameElement == null && document.documentElement;
        } catch (e) {
        }
        if (top && top.doScroll) {
          (function doScrollCheck() {
            if (!jQuery.isReady) {
              try {
                // Use the trick by Diego Perini
                // http://javascript.nwbox.com/IEContentLoaded/
                top.doScroll('left');
              } catch (e) {
                return setTimeout(doScrollCheck, 50);
              }
              // detach all dom ready events
              detach();
              // and execute any waiting functions
              jQuery.ready();
            }
          }());
        }
      }
    }
    return readyList.promise(obj);
  };
  // Populate the class2type map
  jQuery.each('Boolean Number String Function Array Date RegExp Object Error'.split(' '), function (i, name) {
    class2type['[object ' + name + ']'] = name.toLowerCase();
  });
  function isArraylike(obj) {
    var length = obj.length, type = jQuery.type(obj);
    if (jQuery.isWindow(obj)) {
      return false;
    }
    if (obj.nodeType === 1 && length) {
      return true;
    }
    return type === 'array' || type !== 'function' && (length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj);
  }
  // All jQuery objects should point back to these
  rootjQuery = jQuery(document);
  /*!
 * Sizzle CSS Selector Engine v1.10.2
 * http://sizzlejs.com/
 *
 * Copyright 2013 jQuery Foundation, Inc. and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2013-07-03
 */
  (function (window, undefined) {
    var i, support, cachedruns, Expr, getText, isXML, compile, outermostContext, sortInput,
      // Local document vars
      setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains,
      // Instance-specific data
      expando = 'sizzle' + -new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), hasDuplicate = false, sortOrder = function (a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        return 0;
      },
      // General-purpose constants
      strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31,
      // Instance methods
      hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice,
      // Use a stripped-down indexOf if we can't use a native one
      indexOf = arr.indexOf || function (elem) {
        var i = 0, len = this.length;
        for (; i < len; i++) {
          if (this[i] === elem) {
            return i;
          }
        }
        return -1;
      }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped',
      // Regular expressions
      // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace
      whitespace = '[\\x20\\t\\r\\n\\f]',
      // http://www.w3.org/TR/css3-syntax/#characters
      characterEncoding = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+',
      // Loosely modeled on CSS identifier characters
      // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors
      // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
      identifier = characterEncoding.replace('w', 'w#'),
      // Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors
      attributes = '\\[' + whitespace + '*(' + characterEncoding + ')' + whitespace + '*(?:([*^$|!~]?=)' + whitespace + '*(?:([\'"])((?:\\\\.|[^\\\\])*?)\\3|(' + identifier + ')|)|)' + whitespace + '*\\]',
      // Prefer arguments quoted,
      //   then not containing pseudos/brackets,
      //   then attribute selectors/non-parenthetical expressions,
      //   then anything else
      // These preferences are here to reduce the number of selectors
      //   needing tokenize in the PSEUDO preFilter
      pseudos = ':(' + characterEncoding + ')(?:\\((([\'"])((?:\\\\.|[^\\\\])*?)\\3|((?:\\\\.|[^\\\\()[\\]]|' + attributes.replace(3, 8) + ')*)|.*)\\)|)',
      // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
      rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([>+~]|' + whitespace + ')' + whitespace + '*'), rsibling = new RegExp(whitespace + '*[+~]'), rattributeQuotes = new RegExp('=' + whitespace + '*([^\\]\'"]*)' + whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {
        'ID': new RegExp('^#(' + characterEncoding + ')'),
        'CLASS': new RegExp('^\\.(' + characterEncoding + ')'),
        'TAG': new RegExp('^(' + characterEncoding.replace('w', 'w*') + ')'),
        'ATTR': new RegExp('^' + attributes),
        'PSEUDO': new RegExp('^' + pseudos),
        'CHILD': new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'),
        'bool': new RegExp('^(?:' + booleans + ')$', 'i'),
        'needsContext': new RegExp('^' + whitespace + '*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?=[^-]|$)', 'i')
      }, rnative = /^[^{]+\{\s*\[native \w/,
      // Easily-parseable/retrievable ID or TAG or CLASS selectors
      rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rescape = /'|\\/g,
      // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
      runescape = new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function (_, escaped, escapedWhitespace) {
        var high = '0x' + escaped - 65536;
        // NaN means non-codepoint
        // Support: Firefox
        // Workaround erroneous numeric interpretation of +"0x"
        return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
      };
    // Optimize for push.apply( _, NodeList )
    try {
      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
      // Support: Android<4.0
      // Detect silently failing push.apply
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {
        apply: arr.length ? function (target, els) {
          push_native.apply(target, slice.call(els));
        } : function (target, els) {
          var j = target.length, i = 0;
          // Can't trust NodeList.length
          while (target[j++] = els[i++]) {
          }
          target.length = j - 1;
        }
      };
    }
    function Sizzle(selector, context, results, seed) {
      var match, elem, m, nodeType,
        // QSA vars
        i, groups, old, nid, newContext, newSelector;
      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
        setDocument(context);
      }
      context = context || document;
      results = results || [];
      if (!selector || typeof selector !== 'string') {
        return results;
      }
      if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
        return [];
      }
      if (documentIsHTML && !seed) {
        // Shortcuts
        if (match = rquickExpr.exec(selector)) {
          // Speed-up: Sizzle("#ID")
          if (m = match[1]) {
            if (nodeType === 9) {
              elem = context.getElementById(m);
              // Check parentNode to catch when Blackberry 4.6 returns
              // nodes that are no longer in the document #6963
              if (elem && elem.parentNode) {
                // Handle the case where IE, Opera, and Webkit return items
                // by name instead of ID
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }
            } else {
              // Context is not a document
              if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                results.push(elem);
                return results;
              }
            }  // Speed-up: Sizzle("TAG")
          } else if (match[2]) {
            push.apply(results, context.getElementsByTagName(selector));
            return results;  // Speed-up: Sizzle(".CLASS")
          } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
            push.apply(results, context.getElementsByClassName(m));
            return results;
          }
        }
        // QSA path
        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          nid = old = expando;
          newContext = context;
          newSelector = nodeType === 9 && selector;
          // qSA works strangely on Element-rooted queries
          // We can work around this by specifying an extra ID on the root
          // and working up from there (Thanks to Andrew Dupont for the technique)
          // IE 8 doesn't work on object elements
          if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
            groups = tokenize(selector);
            if (old = context.getAttribute('id')) {
              nid = old.replace(rescape, '\\$&');
            } else {
              context.setAttribute('id', nid);
            }
            nid = '[id=\'' + nid + '\'] ';
            i = groups.length;
            while (i--) {
              groups[i] = nid + toSelector(groups[i]);
            }
            newContext = rsibling.test(selector) && context.parentNode || context;
            newSelector = groups.join(',');
          }
          if (newSelector) {
            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {
            } finally {
              if (!old) {
                context.removeAttribute('id');
              }
            }
          }
        }
      }
      // All others
      return select(selector.replace(rtrim, '$1'), context, results, seed);
    }
    /**
 * Create key-value caches of limited size
 * @returns {Function(string, Object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
    function createCache() {
      var keys = [];
      function cache(key, value) {
        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
        if (keys.push(key += ' ') > Expr.cacheLength) {
          // Only keep the most recent entries
          delete cache[keys.shift()];
        }
        return cache[key] = value;
      }
      return cache;
    }
    /**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    /**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
    function assert(fn) {
      var div = document.createElement('div');
      try {
        return !!fn(div);
      } catch (e) {
        return false;
      } finally {
        // Remove from its parent by default
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
        // release memory in IE
        div = null;
      }
    }
    /**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
    function addHandle(attrs, handler) {
      var arr = attrs.split('|'), i = attrs.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    /**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
    function siblingCheck(a, b) {
      var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
      // Use IE sourceIndex if available on both nodes
      if (diff) {
        return diff;
      }
      // Check if b follows a
      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    /**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
    function createInputPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return name === 'input' && elem.type === type;
      };
    }
    /**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
    function createButtonPseudo(type) {
      return function (elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === 'input' || name === 'button') && elem.type === type;
      };
    }
    /**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
    function createPositionalPseudo(fn) {
      return markFunction(function (argument) {
        argument = +argument;
        return markFunction(function (seed, matches) {
          var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
          // Match elements found at the specified indexes
          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    /**
 * Detect xml
 * @param {Element|Object} elem An element or a document
 */
    isXML = Sizzle.isXML = function (elem) {
      // documentElement is verified for cases where it doesn't yet exist
      // (such as loading iframes in IE - #4833)
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== 'HTML' : false;
    };
    // Expose support vars for convenience
    support = Sizzle.support = {};
    /**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
    setDocument = Sizzle.setDocument = function (node) {
      var doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
      // If no document and documentElement is available, return
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      // Set our document
      document = doc;
      docElem = doc.documentElement;
      // Support tests
      documentIsHTML = !isXML(doc);
      // Support: IE>8
      // If iframe document is assigned to "document" variable and if iframe has been reloaded,
      // IE will throw "permission denied" error when accessing "document" variable, see jQuery #13936
      // IE6-8 do not support the defaultView property so parent will be undefined
      if (parent && parent.attachEvent && parent !== parent.top) {
        parent.attachEvent('onbeforeunload', function () {
          setDocument();
        });
      }
      /* Attributes
	---------------------------------------------------------------------- */
      // Support: IE<8
      // Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)
      support.attributes = assert(function (div) {
        div.className = 'i';
        return !div.getAttribute('className');
      });
      /* getElement(s)By*
	---------------------------------------------------------------------- */
      // Check if getElementsByTagName("*") returns only elements
      support.getElementsByTagName = assert(function (div) {
        div.appendChild(doc.createComment(''));
        return !div.getElementsByTagName('*').length;
      });
      // Check if getElementsByClassName can be trusted
      support.getElementsByClassName = assert(function (div) {
        div.innerHTML = '<div class=\'a\'></div><div class=\'a i\'></div>';
        // Support: Safari<4
        // Catch class over-caching
        div.firstChild.className = 'i';
        // Support: Opera<10
        // Catch gEBCN failure to find non-leading classes
        return div.getElementsByClassName('i').length === 2;
      });
      // Support: IE<10
      // Check if getElementById returns elements by name
      // The broken getElementById methods don't pick up programatically-set names,
      // so use a roundabout getElementsByName test
      support.getById = assert(function (div) {
        docElem.appendChild(div).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName(expando).length;
      });
      // ID find and filter
      if (support.getById) {
        Expr.find['ID'] = function (id, context) {
          if (typeof context.getElementById !== strundefined && documentIsHTML) {
            var m = context.getElementById(id);
            // Check parentNode to catch when Blackberry 4.6 returns
            // nodes that are no longer in the document #6963
            return m && m.parentNode ? [m] : [];
          }
        };
        Expr.filter['ID'] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            return elem.getAttribute('id') === attrId;
          };
        };
      } else {
        // Support: IE6/7
        // getElementById is not reliable as a find shortcut
        delete Expr.find['ID'];
        Expr.filter['ID'] = function (id) {
          var attrId = id.replace(runescape, funescape);
          return function (elem) {
            var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode('id');
            return node && node.value === attrId;
          };
        };
      }
      // Tag
      Expr.find['TAG'] = support.getElementsByTagName ? function (tag, context) {
        if (typeof context.getElementsByTagName !== strundefined) {
          return context.getElementsByTagName(tag);
        }
      } : function (tag, context) {
        var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
        // Filter out possible comments
        if (tag === '*') {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      // Class
      Expr.find['CLASS'] = support.getElementsByClassName && function (className, context) {
        if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      /* QSA/matchesSelector
	---------------------------------------------------------------------- */
      // QSA and matchesSelector support
      // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
      rbuggyMatches = [];
      // qSa(:focus) reports false when true (Chrome 21)
      // We allow this because of a bug in IE8/9 that throws an error
      // whenever `document.activeElement` is accessed on an iframe
      // So, we allow :focus to pass through QSA all the time to avoid the IE error
      // See http://bugs.jquery.com/ticket/13378
      rbuggyQSA = [];
      if (support.qsa = rnative.test(doc.querySelectorAll)) {
        // Build QSA regex
        // Regex strategy adopted from Diego Perini
        assert(function (div) {
          // Select is set to empty string on purpose
          // This is to test IE's treatment of not explicitly
          // setting a boolean content attribute,
          // since its presence should be enough
          // http://bugs.jquery.com/ticket/12359
          div.innerHTML = '<select><option selected=\'\'></option></select>';
          // Support: IE8
          // Boolean attributes and "value" are not treated correctly
          if (!div.querySelectorAll('[selected]').length) {
            rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
          }
          // Webkit/Opera - :checked should return selected option elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          // IE8 throws error here and will not see later tests
          if (!div.querySelectorAll(':checked').length) {
            rbuggyQSA.push(':checked');
          }
        });
        assert(function (div) {
          // Support: Opera 10-12/IE8
          // ^= $= *= and empty values
          // Should not select anything
          // Support: Windows 8 Native Apps
          // The type attribute is restricted during .innerHTML assignment
          var input = doc.createElement('input');
          input.setAttribute('type', 'hidden');
          div.appendChild(input).setAttribute('t', '');
          if (div.querySelectorAll('[t^=\'\']').length) {
            rbuggyQSA.push('[*^$]=' + whitespace + '*(?:\'\'|"")');
          }
          // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
          // IE8 throws error here and will not see later tests
          if (!div.querySelectorAll(':enabled').length) {
            rbuggyQSA.push(':enabled', ':disabled');
          }
          // Opera 10-11 does not throw on post-comma invalid pseudos
          div.querySelectorAll('*,:x');
          rbuggyQSA.push(',.*:');
        });
      }
      if (support.matchesSelector = rnative.test(matches = docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
        assert(function (div) {
          // Check to see if it's possible to do matchesSelector
          // on a disconnected node (IE 9)
          support.disconnectedMatch = matches.call(div, 'div');
          // This should fail with an exception
          // Gecko does not error, returns false instead
          matches.call(div, '[s!=\'\']:x');
          rbuggyMatches.push('!=', pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
      /* Contains
	---------------------------------------------------------------------- */
      // Element contains another
      // Purposefully does not implement inclusive descendent
      // As in, an element does not contain itself
      contains = rnative.test(docElem.contains) || docElem.compareDocumentPosition ? function (a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function (a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      /* Sorting
	---------------------------------------------------------------------- */
      // Document order sorting
      sortOrder = docElem.compareDocumentPosition ? function (a, b) {
        // Flag for duplicate removal
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition(b);
        if (compare) {
          // Disconnected nodes
          if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
            // Choose the first element that is related to our preferred document
            if (a === doc || contains(preferredDoc, a)) {
              return -1;
            }
            if (b === doc || contains(preferredDoc, b)) {
              return 1;
            }
            // Maintain original order
            return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
          }
          return compare & 4 ? -1 : 1;
        }
        // Not directly comparable, sort on existence of method
        return a.compareDocumentPosition ? -1 : 1;
      } : function (a, b) {
        var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
        // Exit early if the nodes are identical
        if (a === b) {
          hasDuplicate = true;
          return 0;  // Parentless nodes are either documents or disconnected
        } else if (!aup || !bup) {
          return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;  // If the nodes are siblings, we can do a quick check
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        // Otherwise we need full lists of their ancestors for comparison
        cur = a;
        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }
        cur = b;
        while (cur = cur.parentNode) {
          bp.unshift(cur);
        }
        // Walk down the tree looking for a discrepancy
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return doc;
    };
    Sizzle.matches = function (expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function (elem, expr) {
      // Set document vars if needed
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      // Make sure that attribute selectors are quoted
      expr = expr.replace(rattributeQuotes, '=\'$1\']');
      if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          // IE 9's matchesSelector returns false on disconnected nodes
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {
        }
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function (context, elem) {
      // Set document vars if needed
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function (elem, name) {
      // Set document vars if needed
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()],
        // Don't get fooled by Object.prototype properties (jQuery #13807)
        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val === undefined ? support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null : val;
    };
    Sizzle.error = function (msg) {
      throw new Error('Syntax error, unrecognized expression: ' + msg);
    };
    /**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
    Sizzle.uniqueSort = function (results) {
      var elem, duplicates = [], j = 0, i = 0;
      // Unless we *know* we can detect duplicates, assume their presence
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      return results;
    };
    /**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
    getText = Sizzle.getText = function (elem) {
      var node, ret = '', i = 0, nodeType = elem.nodeType;
      if (!nodeType) {
        // If no nodeType, this is expected to be an array
        for (; node = elem[i]; i++) {
          // Do not traverse comment nodes
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        // Use textContent for elements
        // innerText usage removed for consistency of new lines (see #11153)
        if (typeof elem.textContent === 'string') {
          return elem.textContent;
        } else {
          // Traverse its children
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      // Do not include comment or processing instruction nodes
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        '>': {
          dir: 'parentNode',
          first: true
        },
        ' ': { dir: 'parentNode' },
        '+': {
          dir: 'previousSibling',
          first: true
        },
        '~': { dir: 'previousSibling' }
      },
      preFilter: {
        'ATTR': function (match) {
          match[1] = match[1].replace(runescape, funescape);
          // Move the given value to match[3] whether quoted or unquoted
          match[3] = (match[4] || match[5] || '').replace(runescape, funescape);
          if (match[2] === '~=') {
            match[3] = ' ' + match[3] + ' ';
          }
          return match.slice(0, 4);
        },
        'CHILD': function (match) {
          /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === 'nth') {
            // nth-* requires argument
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            // numeric x and y parameters for Expr.filter.CHILD
            // remember that false/true cast respectively to 0/1
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
            match[5] = +(match[7] + match[8] || match[3] === 'odd');  // other types prohibit arguments
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        'PSEUDO': function (match) {
          var excess, unquoted = !match[5] && match[2];
          if (matchExpr['CHILD'].test(match[0])) {
            return null;
          }
          // Accept quoted arguments as-is
          if (match[3] && match[4] !== undefined) {
            match[2] = match[4];  // Strip excess characters from unquoted arguments
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
            // excess is a negative index
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          // Return only captures needed by the pseudo filter method (type and argument)
          return match.slice(0, 3);
        }
      },
      filter: {
        'TAG': function (nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === '*' ? function () {
            return true;
          } : function (elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        'CLASS': function (className) {
          var pattern = classCache[className + ' '];
          return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function (elem) {
            return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute('class') || '');
          });
        },
        'ATTR': function (name, operator, check) {
          return function (elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === '!=';
            }
            if (!operator) {
              return true;
            }
            result += '';
            return operator === '=' ? result === check : operator === '!=' ? result !== check : operator === '^=' ? check && result.indexOf(check) === 0 : operator === '*=' ? check && result.indexOf(check) > -1 : operator === '$=' ? check && result.slice(-check.length) === check : operator === '~=' ? (' ' + result + ' ').indexOf(check) > -1 : operator === '|=' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
          };
        },
        'CHILD': function (type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
          return first === 1 && last === 0 ? function (elem) {
            return !!elem.parentNode;
          } : function (elem, context, xml) {
            var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
            if (parent) {
              // :(first|last|only)-(child|of-type)
              if (simple) {
                while (dir) {
                  node = elem;
                  while (node = node[dir]) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  // Reverse direction for :only-* (if we haven't yet done so)
                  start = dir = type === 'only' && !start && 'nextSibling';
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              // non-xml :nth-child(...) stores cache data on `parent`
              if (forward && useCache) {
                // Seek `elem` from a previously-cached index
                outerCache = parent[expando] || (parent[expando] = {});
                cache = outerCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = cache[0] === dirruns && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  // When found, cache indexes on `parent` and break
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    outerCache[type] = [
                      dirruns,
                      nodeIndex,
                      diff
                    ];
                    break;
                  }
                }  // Use previously-cached element index if available
              } else if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
                diff = cache[1];  // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)
              } else {
                // Use the same loop as above to seek `elem` from the start
                while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                  if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                    // Cache the index of each encountered element
                    if (useCache) {
                      (node[expando] || (node[expando] = {}))[type] = [
                        dirruns,
                        diff
                      ];
                    }
                    if (node === elem) {
                      break;
                    }
                  }
                }
              }
              // Incorporate the offset, then check against cycle size
              diff -= last;
              return diff === first || diff % first === 0 && diff / first >= 0;
            }
          };
        },
        'PSEUDO': function (pseudo, argument) {
          // pseudo-class names are case-insensitive
          // http://www.w3.org/TR/selectors/#pseudo-classes
          // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
          // Remember that setFilters inherits from pseudos
          var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
          // The user may use createPseudo to indicate that
          // arguments are needed to create the filter function
          // just as Sizzle does
          if (fn[expando]) {
            return fn(argument);
          }
          // But maintain support for old signatures
          if (fn.length > 1) {
            args = [
              pseudo,
              pseudo,
              '',
              argument
            ];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
              var idx, matched = fn(seed, argument), i = matched.length;
              while (i--) {
                idx = indexOf.call(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function (elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        'not': markFunction(function (selector) {
          // Trim the selector passed to compile
          // to avoid treating leading and trailing
          // spaces as combinators
          var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
          return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
            var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
            // Match elements unmatched by `matcher`
            while (i--) {
              if (elem = unmatched[i]) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function (elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            return !results.pop();
          };
        }),
        'has': markFunction(function (selector) {
          return function (elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        'contains': markFunction(function (text) {
          return function (elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        'lang': markFunction(function (lang) {
          // lang value must be a valid identifier
          if (!ridentifier.test(lang || '')) {
            Sizzle.error('unsupported lang: ' + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function (elem) {
            var elemLang;
            do {
              if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        'target': function (elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        'root': function (elem) {
          return elem === docElem;
        },
        'focus': function (elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        'enabled': function (elem) {
          return elem.disabled === false;
        },
        'disabled': function (elem) {
          return elem.disabled === true;
        },
        'checked': function (elem) {
          // In CSS3, :checked should return both checked and selected elements
          // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
          var nodeName = elem.nodeName.toLowerCase();
          return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
        },
        'selected': function (elem) {
          // Accessing this property makes selected-by-default
          // options in Safari work properly
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        'empty': function (elem) {
          // http://www.w3.org/TR/selectors/#empty-pseudo
          // :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),
          //   not comment, processing instructions, or others
          // Thanks to Diego Perini for the nodeName shortcut
          //   Greater than "@" means alpha characters (specifically not starting with "#" or "?")
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeName > '@' || elem.nodeType === 3 || elem.nodeType === 4) {
              return false;
            }
          }
          return true;
        },
        'parent': function (elem) {
          return !Expr.pseudos['empty'](elem);
        },
        'header': function (elem) {
          return rheader.test(elem.nodeName);
        },
        'input': function (elem) {
          return rinputs.test(elem.nodeName);
        },
        'button': function (elem) {
          var name = elem.nodeName.toLowerCase();
          return name === 'input' && elem.type === 'button' || name === 'button';
        },
        'text': function (elem) {
          var attr;
          // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)
          // use getAttribute instead to test this case
          return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === elem.type);
        },
        'first': createPositionalPseudo(function () {
          return [0];
        }),
        'last': createPositionalPseudo(function (matchIndexes, length) {
          return [length - 1];
        }),
        'eq': createPositionalPseudo(function (matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        'even': createPositionalPseudo(function (matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'odd': createPositionalPseudo(function (matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'lt': createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        'gt': createPositionalPseudo(function (matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length;) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos['nth'] = Expr.pseudos['eq'];
    // Add button/input type pseudos
    for (i in {
        radio: true,
        checkbox: true,
        file: true,
        password: true,
        image: true
      }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
        submit: true,
        reset: true
      }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    // Easy API for creating new setFilters
    function setFilters() {
    }
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    function tokenize(selector, parseOnly) {
      var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        // Comma and first run
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            // Don't consume trailing commas as valid
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push(tokens = []);
        }
        matched = false;
        // Combinators
        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, ' ')
          });
          soFar = soFar.slice(matched.length);
        }
        // Filters
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      // Return the length of the invalid excess
      // if we're just parsing
      // Otherwise, throw an error or return tokens
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    }
    function toSelector(tokens) {
      var i = 0, len = tokens.length, selector = '';
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
      return combinator.first ? function (elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
      } : function (elem, context, xml) {
        var data, cache, outerCache, dirkey = dirruns + ' ' + doneName;
        // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching
        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              if ((cache = outerCache[dir]) && cache[0] === dirkey) {
                if ((data = cache[1]) === true || data === cachedruns) {
                  return data === true;
                }
              } else {
                cache = outerCache[dir] = [dirkey];
                cache[1] = matcher(elem, context, xml) || cachedruns;
                if (cache[1] === true) {
                  return true;
                }
              }
            }
          }
        }
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function (elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function (seed, results, context, xml) {
        var temp, i, elem, preMap = [], postMap = [], preexisting = results.length,
          // Get initial elements from seed or context
          elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []),
          // Prefilter to get matcher input, preserving a map for seed-results synchronization
          matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        // Find primary matches
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        // Apply postFilter
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          // Un-match failing elements by moving them back to matcherIn
          i = temp.length;
          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              // Get the final matcherOut by condensing this intermediate into postFinder contexts
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if (elem = matcherOut[i]) {
                  // Restore matcherIn since elem is not yet a final match
                  temp.push(matcherIn[i] = elem);
                }
              }
              postFinder(null, matcherOut = [], temp, xml);
            }
            // Move matched elements from seed to results to keep them synchronized
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }  // Add elements to results, through postFinder if defined
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0,
        // The foundational matcher ensures that elements are reachable from top-level context(s)
        matchContext = addCombinator(function (elem) {
          return elem === checkContext;
        }, implicitRelative, true), matchAnyContext = addCombinator(function (elem) {
          return indexOf.call(checkContext, elem) > -1;
        }, implicitRelative, true), matchers = [function (elem, context, xml) {
            return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
          }];
      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          // Return special upon seeing a positional matcher
          if (matcher[expando]) {
            // Find the next relative operator (if any) for proper handling
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({ value: tokens[i - 2].type === ' ' ? '*' : '' })).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      // A counter to specify which element is currently being matched
      var matcherCachedRuns = 0, bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, expandContext) {
          var elem, j, matcher, setMatched = [], matchedCount = 0, i = '0', unmatched = seed && [], outermost = expandContext != null, contextBackup = outermostContext,
            // We must always have either seed elements or context
            elems = seed || byElement && Expr.find['TAG']('*', expandContext && context.parentNode || context),
            // Use integer dirruns iff this is the outermost matcher
            dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1;
          if (outermost) {
            outermostContext = context !== document && context;
            cachedruns = matcherCachedRuns;
          }
          // Add elements passing elementMatchers directly to results
          // Keep `i` a string if there are no elements so `matchedCount` will be "00" below
          for (; (elem = elems[i]) != null; i++) {
            if (byElement && elem) {
              j = 0;
              while (matcher = elementMatchers[j++]) {
                if (matcher(elem, context, xml)) {
                  results.push(elem);
                  break;
                }
              }
              if (outermost) {
                dirruns = dirrunsUnique;
                cachedruns = ++matcherCachedRuns;
              }
            }
            // Track unmatched elements for set filters
            if (bySet) {
              // They will have gone through all possible matchers
              if (elem = !matcher && elem) {
                matchedCount--;
              }
              // Lengthen the array for every element, matched or not
              if (seed) {
                unmatched.push(elem);
              }
            }
          }
          // Apply set filters to unmatched elements
          matchedCount += i;
          if (bySet && i !== matchedCount) {
            j = 0;
            while (matcher = setMatchers[j++]) {
              matcher(unmatched, setMatched, context, xml);
            }
            if (seed) {
              // Reintegrate element matches to eliminate the need for sorting
              if (matchedCount > 0) {
                while (i--) {
                  if (!(unmatched[i] || setMatched[i])) {
                    setMatched[i] = pop.call(results);
                  }
                }
              }
              // Discard index placeholder values to get only actual matches
              setMatched = condense(setMatched);
            }
            // Add matches to results
            push.apply(results, setMatched);
            // Seedless set matches succeeding multiple successful matchers stipulate sorting
            if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
              Sizzle.uniqueSort(results);
            }
          }
          // Override manipulation of globals by nested matchers
          if (outermost) {
            dirruns = dirrunsUnique;
            outermostContext = contextBackup;
          }
          return unmatched;
        };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function (selector, group) {
      var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
      if (!cached) {
        // Generate a function of recursive functions that can be used to check each element
        if (!group) {
          group = tokenize(selector);
        }
        i = group.length;
        while (i--) {
          cached = matcherFromTokens(group[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        // Cache the compiled function
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
      }
      return cached;
    };
    function multipleContexts(selector, contexts, results) {
      var i = 0, len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function select(selector, context, results, seed) {
      var i, tokens, token, type, find, match = tokenize(selector);
      if (!seed) {
        // Try to minimize operations if there is only one group
        if (match.length === 1) {
          // Take a shortcut and set the context if the root selector is an ID
          tokens = match[0] = match[0].slice(0);
          if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
            context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
            if (!context) {
              return results;
            }
            selector = selector.slice(tokens.shift().value.length);
          }
          // Fetch a seed set for right-to-left matching
          i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
          while (i--) {
            token = tokens[i];
            // Abort if we hit a combinator
            if (Expr.relative[type = token.type]) {
              break;
            }
            if (find = Expr.find[type]) {
              // Search, expanding context for leading sibling combinators
              if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && context.parentNode || context)) {
                // If seed is empty or no tokens remain, we can return early
                tokens.splice(i, 1);
                selector = seed.length && toSelector(tokens);
                if (!selector) {
                  push.apply(results, seed);
                  return results;
                }
                break;
              }
            }
          }
        }
      }
      // Compile and execute a filtering function
      // Provide `match` to avoid retokenization if we modified the selector above
      compile(selector, match)(seed, context, !documentIsHTML, results, rsibling.test(selector));
      return results;
    }
    // One-time assignments
    // Sort stability
    support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
    // Support: Chrome<14
    // Always assume duplicates if they aren't passed to the comparison function
    support.detectDuplicates = hasDuplicate;
    // Initialize against the default document
    setDocument();
    // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
    // Detached nodes confoundingly follow *each other*
    support.sortDetached = assert(function (div1) {
      // Should return 1, but returns 4 (following)
      return div1.compareDocumentPosition(document.createElement('div')) & 1;
    });
    // Support: IE<8
    // Prevent attribute/property "interpolation"
    // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
    if (!assert(function (div) {
        div.innerHTML = '<a href=\'#\'></a>';
        return div.firstChild.getAttribute('href') === '#';
      })) {
      addHandle('type|href|height|width', function (elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
        }
      });
    }
    // Support: IE<9
    // Use defaultValue in place of getAttribute("value")
    if (!support.attributes || !assert(function (div) {
        div.innerHTML = '<input/>';
        div.firstChild.setAttribute('value', '');
        return div.firstChild.getAttribute('value') === '';
      })) {
      addHandle('value', function (elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === 'input') {
          return elem.defaultValue;
        }
      });
    }
    // Support: IE<9
    // Use getAttributeNode to fetch booleans when getAttribute lies
    if (!assert(function (div) {
        return div.getAttribute('disabled') == null;
      })) {
      addHandle(booleans, function (elem, name, isXML) {
        var val;
        if (!isXML) {
          return (val = elem.getAttributeNode(name)) && val.specified ? val.value : elem[name] === true ? name.toLowerCase() : null;
        }
      });
    }
    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[':'] = jQuery.expr.pseudos;
    jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;
  }(window));
  // String to Object options format cache
  var optionsCache = {};
  // Convert String-formatted options into Object-formatted ones and store in cache
  function createOptions(options) {
    var object = optionsCache[options] = {};
    jQuery.each(options.match(core_rnotwhite) || [], function (_, flag) {
      object[flag] = true;
    });
    return object;
  }
  /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
  jQuery.Callbacks = function (options) {
    // Convert options from String-formatted to Object-formatted if needed
    // (we check in cache first)
    options = typeof options === 'string' ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
    var
      // Flag to know if list is currently firing
      firing,
      // Last fire value (for non-forgettable lists)
      memory,
      // Flag to know if list was already fired
      fired,
      // End of the loop when firing
      firingLength,
      // Index of currently firing callback (modified by remove if needed)
      firingIndex,
      // First callback to fire (used internally by add and fireWith)
      firingStart,
      // Actual callback list
      list = [],
      // Stack of fire calls for repeatable lists
      stack = !options.once && [],
      // Fire callbacks
      fire = function (data) {
        memory = options.memory && data;
        fired = true;
        firingIndex = firingStart || 0;
        firingStart = 0;
        firingLength = list.length;
        firing = true;
        for (; list && firingIndex < firingLength; firingIndex++) {
          if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
            memory = false;
            // To prevent further calls using add
            break;
          }
        }
        firing = false;
        if (list) {
          if (stack) {
            if (stack.length) {
              fire(stack.shift());
            }
          } else if (memory) {
            list = [];
          } else {
            self.disable();
          }
        }
      },
      // Actual Callbacks object
      self = {
        add: function () {
          if (list) {
            // First, we save the current length
            var start = list.length;
            (function add(args) {
              jQuery.each(args, function (_, arg) {
                var type = jQuery.type(arg);
                if (type === 'function') {
                  if (!options.unique || !self.has(arg)) {
                    list.push(arg);
                  }
                } else if (arg && arg.length && type !== 'string') {
                  // Inspect recursively
                  add(arg);
                }
              });
            }(arguments));
            // Do we need to add the callbacks to the
            // current firing batch?
            if (firing) {
              firingLength = list.length;  // With memory, if we're not firing then
                                           // we should call right away
            } else if (memory) {
              firingStart = start;
              fire(memory);
            }
          }
          return this;
        },
        remove: function () {
          if (list) {
            jQuery.each(arguments, function (_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);
                // Handle firing indexes
                if (firing) {
                  if (index <= firingLength) {
                    firingLength--;
                  }
                  if (index <= firingIndex) {
                    firingIndex--;
                  }
                }
              }
            });
          }
          return this;
        },
        has: function (fn) {
          return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
        },
        empty: function () {
          list = [];
          firingLength = 0;
          return this;
        },
        disable: function () {
          list = stack = memory = undefined;
          return this;
        },
        disabled: function () {
          return !list;
        },
        lock: function () {
          stack = undefined;
          if (!memory) {
            self.disable();
          }
          return this;
        },
        locked: function () {
          return !stack;
        },
        fireWith: function (context, args) {
          if (list && (!fired || stack)) {
            args = args || [];
            args = [
              context,
              args.slice ? args.slice() : args
            ];
            if (firing) {
              stack.push(args);
            } else {
              fire(args);
            }
          }
          return this;
        },
        fire: function () {
          self.fireWith(this, arguments);
          return this;
        },
        fired: function () {
          return !!fired;
        }
      };
    return self;
  };
  jQuery.extend({
    Deferred: function (func) {
      var tuples = [
          [
            'resolve',
            'done',
            jQuery.Callbacks('once memory'),
            'resolved'
          ],
          [
            'reject',
            'fail',
            jQuery.Callbacks('once memory'),
            'rejected'
          ],
          [
            'notify',
            'progress',
            jQuery.Callbacks('memory')
          ]
        ], state = 'pending', promise = {
          state: function () {
            return state;
          },
          always: function () {
            deferred.done(arguments).fail(arguments);
            return this;
          },
          then: function () {
            var fns = arguments;
            return jQuery.Deferred(function (newDefer) {
              jQuery.each(tuples, function (i, tuple) {
                var action = tuple[0], fn = jQuery.isFunction(fns[i]) && fns[i];
                // deferred[ done | fail | progress ] for forwarding actions to newDefer
                deferred[tuple[1]](function () {
                  var returned = fn && fn.apply(this, arguments);
                  if (returned && jQuery.isFunction(returned.promise)) {
                    returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
                  } else {
                    newDefer[action + 'With'](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                  }
                });
              });
              fns = null;
            }).promise();
          },
          promise: function (obj) {
            return obj != null ? jQuery.extend(obj, promise) : promise;
          }
        }, deferred = {};
      // Keep pipe for back-compat
      promise.pipe = promise.then;
      // Add list-specific methods
      jQuery.each(tuples, function (i, tuple) {
        var list = tuple[2], stateString = tuple[3];
        // promise[ done | fail | progress ] = list.add
        promise[tuple[1]] = list.add;
        // Handle state
        if (stateString) {
          list.add(function () {
            // state = [ resolved | rejected ]
            state = stateString;  // [ reject_list | resolve_list ].disable; progress_list.lock
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        }
        // deferred[ resolve | reject | notify ]
        deferred[tuple[0]] = function () {
          deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments);
          return this;
        };
        deferred[tuple[0] + 'With'] = list.fireWith;
      });
      // Make the deferred a promise
      promise.promise(deferred);
      // Call given func if any
      if (func) {
        func.call(deferred, deferred);
      }
      // All done!
      return deferred;
    },
    when: function (subordinate) {
      var i = 0, resolveValues = core_slice.call(arguments), length = resolveValues.length,
        // the count of uncompleted subordinates
        remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0,
        // the master Deferred. If resolveValues consist of only a single Deferred, just use that.
        deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
        // Update function for both resolve and progress values
        updateFunc = function (i, contexts, values) {
          return function (value) {
            contexts[i] = this;
            values[i] = arguments.length > 1 ? core_slice.call(arguments) : value;
            if (values === progressValues) {
              deferred.notifyWith(contexts, values);
            } else if (!--remaining) {
              deferred.resolveWith(contexts, values);
            }
          };
        }, progressValues, progressContexts, resolveContexts;
      // add listeners to Deferred subordinates; treat others as resolved
      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
          } else {
            --remaining;
          }
        }
      }
      // if we're not waiting on anything, resolve the master
      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }
      return deferred.promise();
    }
  });
  jQuery.support = function (support) {
    var all, a, input, select, fragment, opt, eventName, isSupported, i, div = document.createElement('div');
    // Setup
    div.setAttribute('className', 't');
    div.innerHTML = '  <link/><table></table><a href=\'/a\'>a</a><input type=\'checkbox\'/>';
    // Finish early in limited (non-browser) environments
    all = div.getElementsByTagName('*') || [];
    a = div.getElementsByTagName('a')[0];
    if (!a || !a.style || !all.length) {
      return support;
    }
    // First batch of tests
    select = document.createElement('select');
    opt = select.appendChild(document.createElement('option'));
    input = div.getElementsByTagName('input')[0];
    a.style.cssText = 'top:1px;float:left;opacity:.5';
    // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)
    support.getSetAttribute = div.className !== 't';
    // IE strips leading whitespace when .innerHTML is used
    support.leadingWhitespace = div.firstChild.nodeType === 3;
    // Make sure that tbody elements aren't automatically inserted
    // IE will insert them into empty tables
    support.tbody = !div.getElementsByTagName('tbody').length;
    // Make sure that link elements get serialized correctly by innerHTML
    // This requires a wrapper element in IE
    support.htmlSerialize = !!div.getElementsByTagName('link').length;
    // Get the style information from getAttribute
    // (IE uses .cssText instead)
    support.style = /top/.test(a.getAttribute('style'));
    // Make sure that URLs aren't manipulated
    // (IE normalizes it by default)
    support.hrefNormalized = a.getAttribute('href') === '/a';
    // Make sure that element opacity exists
    // (IE uses filter instead)
    // Use a regex to work around a WebKit issue. See #5145
    support.opacity = /^0.5/.test(a.style.opacity);
    // Verify style float existence
    // (IE uses styleFloat instead of cssFloat)
    support.cssFloat = !!a.style.cssFloat;
    // Check the default checkbox/radio value ("" on WebKit; "on" elsewhere)
    support.checkOn = !!input.value;
    // Make sure that a selected-by-default option has a working selected property.
    // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)
    support.optSelected = opt.selected;
    // Tests for enctype support on a form (#6743)
    support.enctype = !!document.createElement('form').enctype;
    // Makes sure cloning an html5 element does not cause problems
    // Where outerHTML is undefined, this still works
    support.html5Clone = document.createElement('nav').cloneNode(true).outerHTML !== '<:nav></:nav>';
    // Will be defined later
    support.inlineBlockNeedsLayout = false;
    support.shrinkWrapBlocks = false;
    support.pixelPosition = false;
    support.deleteExpando = true;
    support.noCloneEvent = true;
    support.reliableMarginRight = true;
    support.boxSizingReliable = true;
    // Make sure checked status is properly cloned
    input.checked = true;
    support.noCloneChecked = input.cloneNode(true).checked;
    // Make sure that the options inside disabled selects aren't marked as disabled
    // (WebKit marks them as disabled)
    select.disabled = true;
    support.optDisabled = !opt.disabled;
    // Support: IE<9
    try {
      delete div.test;
    } catch (e) {
      support.deleteExpando = false;
    }
    // Check if we can trust getAttribute("value")
    input = document.createElement('input');
    input.setAttribute('value', '');
    support.input = input.getAttribute('value') === '';
    // Check if an input maintains its value after becoming a radio
    input.value = 't';
    input.setAttribute('type', 'radio');
    support.radioValue = input.value === 't';
    // #11217 - WebKit loses check when the name is after the checked attribute
    input.setAttribute('checked', 't');
    input.setAttribute('name', 't');
    fragment = document.createDocumentFragment();
    fragment.appendChild(input);
    // Check if a disconnected checkbox will retain its checked
    // value of true after appended to the DOM (IE6/7)
    support.appendChecked = input.checked;
    // WebKit doesn't clone checked state correctly in fragments
    support.checkClone = fragment.cloneNode(true).cloneNode(true).lastChild.checked;
    // Support: IE<9
    // Opera does not clone events (and typeof div.attachEvent === undefined).
    // IE9-10 clones events bound via attachEvent, but they don't trigger with .click()
    if (div.attachEvent) {
      div.attachEvent('onclick', function () {
        support.noCloneEvent = false;
      });
      div.cloneNode(true).click();
    }
    // Support: IE<9 (lack submit/change bubble), Firefox 17+ (lack focusin event)
    // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)
    for (i in {
        submit: true,
        change: true,
        focusin: true
      }) {
      div.setAttribute(eventName = 'on' + i, 't');
      support[i + 'Bubbles'] = eventName in window || div.attributes[eventName].expando === false;
    }
    div.style.backgroundClip = 'content-box';
    div.cloneNode(true).style.backgroundClip = '';
    support.clearCloneStyle = div.style.backgroundClip === 'content-box';
    // Support: IE<9
    // Iteration over object's inherited properties before its own.
    for (i in jQuery(support)) {
      break;
    }
    support.ownLast = i !== '0';
    // Run tests that need a body at doc ready
    jQuery(function () {
      var container, marginDiv, tds, divReset = 'padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;', body = document.getElementsByTagName('body')[0];
      if (!body) {
        // Return for frameset docs that don't have a body
        return;
      }
      container = document.createElement('div');
      container.style.cssText = 'border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px';
      body.appendChild(container).appendChild(div);
      // Support: IE8
      // Check if table cells still have offsetWidth/Height when they are set
      // to display:none and there are still other visible table cells in a
      // table row; if so, offsetWidth/Height are not reliable for use when
      // determining if an element has been hidden directly using
      // display:none (it is still safe to use offsets if a parent element is
      // hidden; don safety goggles and see bug #4512 for more information).
      div.innerHTML = '<table><tr><td></td><td>t</td></tr></table>';
      tds = div.getElementsByTagName('td');
      tds[0].style.cssText = 'padding:0;margin:0;border:0;display:none';
      isSupported = tds[0].offsetHeight === 0;
      tds[0].style.display = '';
      tds[1].style.display = 'none';
      // Support: IE8
      // Check if empty table cells still have offsetWidth/Height
      support.reliableHiddenOffsets = isSupported && tds[0].offsetHeight === 0;
      // Check box-sizing and margin behavior.
      div.innerHTML = '';
      div.style.cssText = 'box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;';
      // Workaround failing boxSizing test due to offsetWidth returning wrong value
      // with some non-1 values of body zoom, ticket #13543
      jQuery.swap(body, body.style.zoom != null ? { zoom: 1 } : {}, function () {
        support.boxSizing = div.offsetWidth === 4;
      });
      // Use window.getComputedStyle because jsdom on node.js will break without it.
      if (window.getComputedStyle) {
        support.pixelPosition = (window.getComputedStyle(div, null) || {}).top !== '1%';
        support.boxSizingReliable = (window.getComputedStyle(div, null) || { width: '4px' }).width === '4px';
        // Check if div with explicit width and no margin-right incorrectly
        // gets computed margin-right based on width of container. (#3333)
        // Fails in WebKit before Feb 2011 nightlies
        // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
        marginDiv = div.appendChild(document.createElement('div'));
        marginDiv.style.cssText = div.style.cssText = divReset;
        marginDiv.style.marginRight = marginDiv.style.width = '0';
        div.style.width = '1px';
        support.reliableMarginRight = !parseFloat((window.getComputedStyle(marginDiv, null) || {}).marginRight);
      }
      if (typeof div.style.zoom !== core_strundefined) {
        // Support: IE<8
        // Check if natively block-level elements act like inline-block
        // elements when setting their display to 'inline' and giving
        // them layout
        div.innerHTML = '';
        div.style.cssText = divReset + 'width:1px;padding:1px;display:inline;zoom:1';
        support.inlineBlockNeedsLayout = div.offsetWidth === 3;
        // Support: IE6
        // Check if elements with layout shrink-wrap their children
        div.style.display = 'block';
        div.innerHTML = '<div></div>';
        div.firstChild.style.width = '5px';
        support.shrinkWrapBlocks = div.offsetWidth !== 3;
        if (support.inlineBlockNeedsLayout) {
          // Prevent IE 6 from affecting layout for positioned elements #11048
          // Prevent IE from shrinking the body in IE 7 mode #12869
          // Support: IE<8
          body.style.zoom = 1;
        }
      }
      body.removeChild(container);
      // Null elements to avoid leaks in IE
      container = div = tds = marginDiv = null;
    });
    // Null elements to avoid leaks in IE
    all = select = fragment = opt = a = input = null;
    return support;
  }({});
  var rbrace = /(?:\{[\s\S]*\}|\[[\s\S]*\])$/, rmultiDash = /([A-Z])/g;
  function internalData(elem, name, data, pvt) {
    if (!jQuery.acceptData(elem)) {
      return;
    }
    var ret, thisCache, internalKey = jQuery.expando,
      // We have to handle DOM nodes and JS objects differently because IE6-7
      // can't GC object references properly across the DOM-JS boundary
      isNode = elem.nodeType,
      // Only DOM nodes need the global jQuery cache; JS object data is
      // attached directly to the object so GC can occur automatically
      cache = isNode ? jQuery.cache : elem,
      // Only defining an ID for JS objects if its cache already exists allows
      // the code to shortcut on the same path as a DOM node with no cache
      id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;
    // Avoid doing any more work than we need to when trying to get data on an
    // object that has no data at all
    if ((!id || !cache[id] || !pvt && !cache[id].data) && data === undefined && typeof name === 'string') {
      return;
    }
    if (!id) {
      // Only DOM nodes need a new unique ID for each element since their data
      // ends up in the global cache
      if (isNode) {
        id = elem[internalKey] = core_deletedIds.pop() || jQuery.guid++;
      } else {
        id = internalKey;
      }
    }
    if (!cache[id]) {
      // Avoid exposing jQuery metadata on plain JS objects when the object
      // is serialized using JSON.stringify
      cache[id] = isNode ? {} : { toJSON: jQuery.noop };
    }
    // An object can be passed to jQuery.data instead of a key/value pair; this gets
    // shallow copied over onto the existing cache
    if (typeof name === 'object' || typeof name === 'function') {
      if (pvt) {
        cache[id] = jQuery.extend(cache[id], name);
      } else {
        cache[id].data = jQuery.extend(cache[id].data, name);
      }
    }
    thisCache = cache[id];
    // jQuery data() is stored in a separate object inside the object's internal data
    // cache in order to avoid key collisions between internal data and user-defined
    // data.
    if (!pvt) {
      if (!thisCache.data) {
        thisCache.data = {};
      }
      thisCache = thisCache.data;
    }
    if (data !== undefined) {
      thisCache[jQuery.camelCase(name)] = data;
    }
    // Check for both converted-to-camel and non-converted data property names
    // If a data property was specified
    if (typeof name === 'string') {
      // First Try to find as-is property data
      ret = thisCache[name];
      // Test for null|undefined property data
      if (ret == null) {
        // Try to find the camelCased property
        ret = thisCache[jQuery.camelCase(name)];
      }
    } else {
      ret = thisCache;
    }
    return ret;
  }
  function internalRemoveData(elem, name, pvt) {
    if (!jQuery.acceptData(elem)) {
      return;
    }
    var thisCache, i, isNode = elem.nodeType,
      // See jQuery.data for more information
      cache = isNode ? jQuery.cache : elem, id = isNode ? elem[jQuery.expando] : jQuery.expando;
    // If there is already no cache entry for this object, there is no
    // purpose in continuing
    if (!cache[id]) {
      return;
    }
    if (name) {
      thisCache = pvt ? cache[id] : cache[id].data;
      if (thisCache) {
        // Support array or space separated string names for data keys
        if (!jQuery.isArray(name)) {
          // try the string as a key before any manipulation
          if (name in thisCache) {
            name = [name];
          } else {
            // split the camel cased version by spaces unless a key with the spaces exists
            name = jQuery.camelCase(name);
            if (name in thisCache) {
              name = [name];
            } else {
              name = name.split(' ');
            }
          }
        } else {
          // If "name" is an array of keys...
          // When data is initially created, via ("key", "val") signature,
          // keys will be converted to camelCase.
          // Since there is no way to tell _how_ a key was added, remove
          // both plain key and camelCase key. #12786
          // This will only penalize the array argument path.
          name = name.concat(jQuery.map(name, jQuery.camelCase));
        }
        i = name.length;
        while (i--) {
          delete thisCache[name[i]];
        }
        // If there is no data left in the cache, we want to continue
        // and let the cache object itself get destroyed
        if (pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache)) {
          return;
        }
      }
    }
    // See jQuery.data for more information
    if (!pvt) {
      delete cache[id].data;
      // Don't destroy the parent cache unless the internal data object
      // had been the only thing left in it
      if (!isEmptyDataObject(cache[id])) {
        return;
      }
    }
    // Destroy the cache
    if (isNode) {
      jQuery.cleanData([elem], true);  // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)
                                       /* jshint eqeqeq: false */
    } else if (jQuery.support.deleteExpando || cache != cache.window) {
      /* jshint eqeqeq: true */
      delete cache[id];  // When all else fails, null
    } else {
      cache[id] = null;
    }
  }
  jQuery.extend({
    cache: {},
    noData: {
      'applet': true,
      'embed': true,
      'object': 'clsid:D27CDB6E-AE6D-11cf-96B8-444553540000'
    },
    hasData: function (elem) {
      elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];
      return !!elem && !isEmptyDataObject(elem);
    },
    data: function (elem, name, data) {
      return internalData(elem, name, data);
    },
    removeData: function (elem, name) {
      return internalRemoveData(elem, name);
    },
    _data: function (elem, name, data) {
      return internalData(elem, name, data, true);
    },
    _removeData: function (elem, name) {
      return internalRemoveData(elem, name, true);
    },
    acceptData: function (elem) {
      // Do not set data on non-element because it will not be cleared (#8335).
      if (elem.nodeType && elem.nodeType !== 1 && elem.nodeType !== 9) {
        return false;
      }
      var noData = elem.nodeName && jQuery.noData[elem.nodeName.toLowerCase()];
      // nodes accept data unless otherwise specified; rejection can be conditional
      return !noData || noData !== true && elem.getAttribute('classid') === noData;
    }
  });
  jQuery.fn.extend({
    data: function (key, value) {
      var attrs, name, data = null, i = 0, elem = this[0];
      // Special expections of .data basically thwart jQuery.access,
      // so implement the relevant behavior ourselves
      // Gets all values
      if (key === undefined) {
        if (this.length) {
          data = jQuery.data(elem);
          if (elem.nodeType === 1 && !jQuery._data(elem, 'parsedAttrs')) {
            attrs = elem.attributes;
            for (; i < attrs.length; i++) {
              name = attrs[i].name;
              if (name.indexOf('data-') === 0) {
                name = jQuery.camelCase(name.slice(5));
                dataAttr(elem, name, data[name]);
              }
            }
            jQuery._data(elem, 'parsedAttrs', true);
          }
        }
        return data;
      }
      // Sets multiple values
      if (typeof key === 'object') {
        return this.each(function () {
          jQuery.data(this, key);
        });
      }
      return arguments.length > 1 ? this.each(function () {
        jQuery.data(this, key, value);
      }) : elem ? dataAttr(elem, key, jQuery.data(elem, key)) : null;
    },
    removeData: function (key) {
      return this.each(function () {
        jQuery.removeData(this, key);
      });
    }
  });
  function dataAttr(elem, key, data) {
    // If nothing was found internally, try to fetch any
    // data from the HTML5 data-* attribute
    if (data === undefined && elem.nodeType === 1) {
      var name = 'data-' + key.replace(rmultiDash, '-$1').toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === 'string') {
        try {
          data = data === 'true' ? true : data === 'false' ? false : data === 'null' ? null : +data + '' === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
        } catch (e) {
        }
        // Make sure we set the data so it isn't changed later
        jQuery.data(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  // checks a cache object for emptiness
  function isEmptyDataObject(obj) {
    var name;
    for (name in obj) {
      // if the public data object is empty, the private is still empty
      if (name === 'data' && jQuery.isEmptyObject(obj[name])) {
        continue;
      }
      if (name !== 'toJSON') {
        return false;
      }
    }
    return true;
  }
  jQuery.extend({
    queue: function (elem, type, data) {
      var queue;
      if (elem) {
        type = (type || 'fx') + 'queue';
        queue = jQuery._data(elem, type);
        // Speed up dequeue by getting out quickly if this is just a lookup
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = jQuery._data(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function (elem, type) {
      type = type || 'fx';
      var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
          jQuery.dequeue(elem, type);
        };
      // If the fx queue is dequeued, always remove the progress sentinel
      if (fn === 'inprogress') {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        // Add a progress sentinel to prevent the fx queue from being
        // automatically dequeued
        if (type === 'fx') {
          queue.unshift('inprogress');
        }
        // clear up the last queue stop function
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function (elem, type) {
      var key = type + 'queueHooks';
      return jQuery._data(elem, key) || jQuery._data(elem, key, {
        empty: jQuery.Callbacks('once memory').add(function () {
          jQuery._removeData(elem, type + 'queue');
          jQuery._removeData(elem, key);
        })
      });
    }
  });
  jQuery.fn.extend({
    queue: function (type, data) {
      var setter = 2;
      if (typeof type !== 'string') {
        data = type;
        type = 'fx';
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function () {
        var queue = jQuery.queue(this, type, data);
        // ensure a hooks for this queue
        jQuery._queueHooks(this, type);
        if (type === 'fx' && queue[0] !== 'inprogress') {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function (type) {
      return this.each(function () {
        jQuery.dequeue(this, type);
      });
    },
    delay: function (time, type) {
      time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
      type = type || 'fx';
      return this.queue(type, function (next, hooks) {
        var timeout = setTimeout(next, time);
        hooks.stop = function () {
          clearTimeout(timeout);
        };
      });
    },
    clearQueue: function (type) {
      return this.queue(type || 'fx', []);
    },
    promise: function (type, obj) {
      var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
          if (!--count) {
            defer.resolveWith(elements, [elements]);
          }
        };
      if (typeof type !== 'string') {
        obj = type;
        type = undefined;
      }
      type = type || 'fx';
      while (i--) {
        tmp = jQuery._data(elements[i], type + 'queueHooks');
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var nodeHook, boolHook, rclass = /[\t\r\n\f]/g, rreturn = /\r/g, rfocusable = /^(?:input|select|textarea|button|object)$/i, rclickable = /^(?:a|area)$/i, ruseDefault = /^(?:checked|selected)$/i, getSetAttribute = jQuery.support.getSetAttribute, getSetInput = jQuery.support.input;
  jQuery.fn.extend({
    attr: function (name, value) {
      return jQuery.access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function (name) {
      return this.each(function () {
        jQuery.removeAttr(this, name);
      });
    },
    prop: function (name, value) {
      return jQuery.access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function (name) {
      name = jQuery.propFix[name] || name;
      return this.each(function () {
        // try/catch handles cases where IE balks (such as removing a property on window)
        try {
          this[name] = undefined;
          delete this[name];
        } catch (e) {
        }
      });
    },
    addClass: function (value) {
      var classes, elem, cur, clazz, j, i = 0, len = this.length, proceed = typeof value === 'string' && value;
      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).addClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        // The disjunction here is for better compressibility (see removeClass)
        classes = (value || '').match(core_rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : ' ');
          if (cur) {
            j = 0;
            while (clazz = classes[j++]) {
              if (cur.indexOf(' ' + clazz + ' ') < 0) {
                cur += clazz + ' ';
              }
            }
            elem.className = jQuery.trim(cur);
          }
        }
      }
      return this;
    },
    removeClass: function (value) {
      var classes, elem, cur, clazz, j, i = 0, len = this.length, proceed = arguments.length === 0 || typeof value === 'string' && value;
      if (jQuery.isFunction(value)) {
        return this.each(function (j) {
          jQuery(this).removeClass(value.call(this, j, this.className));
        });
      }
      if (proceed) {
        classes = (value || '').match(core_rnotwhite) || [];
        for (; i < len; i++) {
          elem = this[i];
          // This expression is here for better compressibility (see addClass)
          cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : '');
          if (cur) {
            j = 0;
            while (clazz = classes[j++]) {
              // Remove *all* instances
              while (cur.indexOf(' ' + clazz + ' ') >= 0) {
                cur = cur.replace(' ' + clazz + ' ', ' ');
              }
            }
            elem.className = value ? jQuery.trim(cur) : '';
          }
        }
      }
      return this;
    },
    toggleClass: function (value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === 'boolean' && type === 'string') {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function (i) {
          jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
        });
      }
      return this.each(function () {
        if (type === 'string') {
          // toggle individual class names
          var className, i = 0, self = jQuery(this), classNames = value.match(core_rnotwhite) || [];
          while (className = classNames[i++]) {
            // check each className given, space separated list
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }  // Toggle whole class name
        } else if (type === core_strundefined || type === 'boolean') {
          if (this.className) {
            // store className if set
            jQuery._data(this, '__className__', this.className);
          }
          // If the element has a class name or if we're passed "false",
          // then remove the whole classname (if there was one, the above saved it).
          // Otherwise bring back whatever was previously saved (if anything),
          // falling back to the empty string if nothing was stored.
          this.className = this.className || value === false ? '' : jQuery._data(this, '__className__') || '';
        }
      });
    },
    hasClass: function (selector) {
      var className = ' ' + selector + ' ', i = 0, l = this.length;
      for (; i < l; i++) {
        if (this[i].nodeType === 1 && (' ' + this[i].className + ' ').replace(rclass, ' ').indexOf(className) >= 0) {
          return true;
        }
      }
      return false;
    },
    val: function (value) {
      var ret, hooks, isFunction, elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
            return ret;
          }
          ret = elem.value;
          return typeof ret === 'string' ? ret.replace(rreturn, '') : ret == null ? '' : ret;
        }
        return;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function (i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        // Treat null/undefined as ""; convert numbers to string
        if (val == null) {
          val = '';
        } else if (typeof val === 'number') {
          val += '';
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function (value) {
            return value == null ? '' : value + '';
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        // If set returns undefined, fall back to normal setting
        if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
          this.value = val;
        }
      });
    }
  });
  jQuery.extend({
    valHooks: {
      option: {
        get: function (elem) {
          // Use proper attribute retrieval(#6932, #12072)
          var val = jQuery.find.attr(elem, 'value');
          return val != null ? val : elem.text;
        }
      },
      select: {
        get: function (elem) {
          var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one' || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
          // Loop through all the selected options
          for (; i < max; i++) {
            option = options[i];
            // oldIE doesn't update selected after form reset (#2551)
            if ((option.selected || i === index) && (jQuery.support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {
              // Get the specific value for the option
              value = jQuery(option).val();
              // We don't need an array for one selects
              if (one) {
                return value;
              }
              // Multi-Selects return an array
              values.push(value);
            }
          }
          return values;
        },
        set: function (elem, value) {
          var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
          while (i--) {
            option = options[i];
            if (option.selected = jQuery.inArray(jQuery(option).val(), values) >= 0) {
              optionSet = true;
            }
          }
          // force browsers to behave consistently when non-matching value is set
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    },
    attr: function (elem, name, value) {
      var hooks, ret, nType = elem.nodeType;
      // don't get/set attributes on text, comment and attribute nodes
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      // Fallback to prop when attributes are not supported
      if (typeof elem.getAttribute === core_strundefined) {
        return jQuery.prop(elem, name, value);
      }
      // All attributes are lowercase
      // Grab necessary hook if one is defined
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
        } else if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        } else {
          elem.setAttribute(name, value + '');
          return value;
        }
      } else if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      } else {
        ret = jQuery.find.attr(elem, name);
        // Non-existent attributes return null, we normalize to undefined
        return ret == null ? undefined : ret;
      }
    },
    removeAttr: function (elem, value) {
      var name, propName, i = 0, attrNames = value && value.match(core_rnotwhite);
      if (attrNames && elem.nodeType === 1) {
        while (name = attrNames[i++]) {
          propName = jQuery.propFix[name] || name;
          // Boolean attributes get special treatment (#10870)
          if (jQuery.expr.match.bool.test(name)) {
            // Set corresponding property to false
            if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
              elem[propName] = false;  // Support: IE<9
                                       // Also clear defaultChecked/defaultSelected (if appropriate)
            } else {
              elem[jQuery.camelCase('default-' + name)] = elem[propName] = false;
            }  // See #9699 for explanation of this approach (setting first, then removal)
          } else {
            jQuery.attr(elem, name, '');
          }
          elem.removeAttribute(getSetAttribute ? name : propName);
        }
      }
    },
    attrHooks: {
      type: {
        set: function (elem, value) {
          if (!jQuery.support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
            // Setting the type on a radio button after the value resets the value in IE6-9
            // Reset value to default in case type is set after value during creation
            var val = elem.value;
            elem.setAttribute('type', value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }
      }
    },
    propFix: {
      'for': 'htmlFor',
      'class': 'className'
    },
    prop: function (elem, name, value) {
      var ret, hooks, notxml, nType = elem.nodeType;
      // don't get/set properties on text, comment and attribute nodes
      if (!elem || nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
      if (notxml) {
        // Fix name and attach hooks
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        return hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
      } else {
        return hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
      }
    },
    propHooks: {
      tabIndex: {
        get: function (elem) {
          // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set
          // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
          // Use proper attribute retrieval(#12072)
          var tabindex = jQuery.find.attr(elem, 'tabindex');
          return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
        }
      }
    }
  });
  // Hooks for boolean attributes
  boolHook = {
    set: function (elem, value, name) {
      if (value === false) {
        // Remove boolean attributes when set to false
        jQuery.removeAttr(elem, name);
      } else if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
        // IE<8 needs the *property* name
        elem.setAttribute(!getSetAttribute && jQuery.propFix[name] || name, name);  // Use defaultChecked and defaultSelected for oldIE
      } else {
        elem[jQuery.camelCase('default-' + name)] = elem[name] = true;
      }
      return name;
    }
  };
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
    var getter = jQuery.expr.attrHandle[name] || jQuery.find.attr;
    jQuery.expr.attrHandle[name] = getSetInput && getSetAttribute || !ruseDefault.test(name) ? function (elem, name, isXML) {
      var fn = jQuery.expr.attrHandle[name], ret = isXML ? undefined : (jQuery.expr.attrHandle[name] = undefined) != getter(elem, name, isXML) ? name.toLowerCase() : null;
      jQuery.expr.attrHandle[name] = fn;
      return ret;
    } : function (elem, name, isXML) {
      return isXML ? undefined : elem[jQuery.camelCase('default-' + name)] ? name.toLowerCase() : null;
    };
  });
  // fix oldIE attroperties
  if (!getSetInput || !getSetAttribute) {
    jQuery.attrHooks.value = {
      set: function (elem, value, name) {
        if (jQuery.nodeName(elem, 'input')) {
          // Does not return so that setAttribute is also used
          elem.defaultValue = value;
        } else {
          // Use nodeHook if defined (#1954); otherwise setAttribute is fine
          return nodeHook && nodeHook.set(elem, value, name);
        }
      }
    };
  }
  // IE6/7 do not support getting/setting some attributes with get/setAttribute
  if (!getSetAttribute) {
    // Use this for any attribute in IE6/7
    // This fixes almost every IE6/7 issue
    nodeHook = {
      set: function (elem, value, name) {
        // Set the existing or create a new attribute node
        var ret = elem.getAttributeNode(name);
        if (!ret) {
          elem.setAttributeNode(ret = elem.ownerDocument.createAttribute(name));
        }
        ret.value = value += '';
        // Break association with cloned elements by also using setAttribute (#9646)
        return name === 'value' || value === elem.getAttribute(name) ? value : undefined;
      }
    };
    jQuery.expr.attrHandle.id = jQuery.expr.attrHandle.name = jQuery.expr.attrHandle.coords = function (elem, name, isXML) {
      var ret;
      return isXML ? undefined : (ret = elem.getAttributeNode(name)) && ret.value !== '' ? ret.value : null;
    };
    jQuery.valHooks.button = {
      get: function (elem, name) {
        var ret = elem.getAttributeNode(name);
        return ret && ret.specified ? ret.value : undefined;
      },
      set: nodeHook.set
    };
    // Set contenteditable to false on removals(#10429)
    // Setting to empty string throws an error as an invalid value
    jQuery.attrHooks.contenteditable = {
      set: function (elem, value, name) {
        nodeHook.set(elem, value === '' ? false : value, name);
      }
    };
    // Set width and height to auto instead of 0 on empty string( Bug #8150 )
    // This is for removals
    jQuery.each([
      'width',
      'height'
    ], function (i, name) {
      jQuery.attrHooks[name] = {
        set: function (elem, value) {
          if (value === '') {
            elem.setAttribute(name, 'auto');
            return value;
          }
        }
      };
    });
  }
  // Some attributes require a special call on IE
  // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
  if (!jQuery.support.hrefNormalized) {
    // href/src property should get the full normalized URL (#10299/#12915)
    jQuery.each([
      'href',
      'src'
    ], function (i, name) {
      jQuery.propHooks[name] = {
        get: function (elem) {
          return elem.getAttribute(name, 4);
        }
      };
    });
  }
  if (!jQuery.support.style) {
    jQuery.attrHooks.style = {
      get: function (elem) {
        // Return undefined in the case of empty string
        // Note: IE uppercases css property names, but if we were to .toLowerCase()
        // .cssText, that would destroy case senstitivity in URL's, like in "background"
        return elem.style.cssText || undefined;
      },
      set: function (elem, value) {
        return elem.style.cssText = value + '';
      }
    };
  }
  // Safari mis-reports the default selected property of an option
  // Accessing the parent's selectedIndex property fixes it
  if (!jQuery.support.optSelected) {
    jQuery.propHooks.selected = {
      get: function (elem) {
        var parent = elem.parentNode;
        if (parent) {
          parent.selectedIndex;
          // Make sure that it also works with optgroups, see #5701
          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
        return null;
      }
    };
  }
  jQuery.each([
    'tabIndex',
    'readOnly',
    'maxLength',
    'cellSpacing',
    'cellPadding',
    'rowSpan',
    'colSpan',
    'useMap',
    'frameBorder',
    'contentEditable'
  ], function () {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  // IE6/7 call enctype encoding
  if (!jQuery.support.enctype) {
    jQuery.propFix.enctype = 'encoding';
  }
  // Radios and checkboxes getter/setter
  jQuery.each([
    'radio',
    'checkbox'
  ], function () {
    jQuery.valHooks[this] = {
      set: function (elem, value) {
        if (jQuery.isArray(value)) {
          return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
        }
      }
    };
    if (!jQuery.support.checkOn) {
      jQuery.valHooks[this].get = function (elem) {
        // Support: Webkit
        // "" is returned instead of "on" if a value isn't specified
        return elem.getAttribute('value') === null ? 'on' : elem.value;
      };
    }
  });
  var rformElems = /^(?:input|select|textarea)$/i, rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {
    }
  }
  /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
  jQuery.event = {
    global: {},
    add: function (elem, types, handler, data, selector) {
      var tmp, events, t, handleObjIn, special, eventHandle, handleObj, handlers, type, namespaces, origType, elemData = jQuery._data(elem);
      // Don't attach events to noData or text/comment nodes (but allow plain objects)
      if (!elemData) {
        return;
      }
      // Caller can pass in an object of custom data in lieu of the handler
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      // Make sure that the handler has a unique ID, used to find/remove it later
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      // Init the element's event structure and main handler, if this is the first
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function (e) {
          // Discard the second event of a jQuery.event.trigger() and
          // when an event is called after a page has unloaded
          return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;
        };
        // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events
        eventHandle.elem = elem;
      }
      // Handle multiple events separated by a space
      types = (types || '').match(core_rnotwhite) || [''];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || '').split('.').sort();
        // There *must* be a type, no attaching namespace-only handlers
        if (!type) {
          continue;
        }
        // If event changes its type, use the special event handlers for the changed type
        special = jQuery.event.special[type] || {};
        // If selector defined, determine special event api type, otherwise given type
        type = (selector ? special.delegateType : special.bindType) || type;
        // Update special based on newly reset type
        special = jQuery.event.special[type] || {};
        // handleObj is passed to all event handlers
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join('.')
        }, handleObjIn);
        // Init the event handler queue if we're the first
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          // Only use addEventListener/attachEvent if the special events handler returns false
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            // Bind the global event handler to the element
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle, false);
            } else if (elem.attachEvent) {
              elem.attachEvent('on' + type, eventHandle);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        // Add to the element's handler list, delegates in front
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        // Keep track of which events have ever been used, for event optimization
        jQuery.event.global[type] = true;
      }
      // Nullify elem to prevent memory leaks in IE
      elem = null;
    },
    remove: function (elem, types, handler, selector, mappedTypes) {
      var j, handleObj, tmp, origCount, t, events, special, handlers, type, namespaces, origType, elemData = jQuery.hasData(elem) && jQuery._data(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      // Once for each type.namespace in types; type may be omitted
      types = (types || '').match(core_rnotwhite) || [''];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || '').split('.').sort();
        // Unbind all events (on this namespace, if provided) for the element
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
        // Remove matching events
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        // Remove generic event handler if we removed something and no more handlers exist
        // (avoids potential for endless recursion during removal of special event handlers)
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      // Remove the expando if it's no longer used
      if (jQuery.isEmptyObject(events)) {
        delete elemData.handle;
        // removeData also checks for emptiness and clears the expando if empty
        // so use it instead of delete
        jQuery._removeData(elem, 'events');
      }
    },
    trigger: function (event, data, elem, onlyHandlers) {
      var handle, ontype, cur, bubbleType, special, tmp, i, eventPath = [elem || document], type = core_hasOwn.call(event, 'type') ? event.type : event, namespaces = core_hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
      cur = tmp = elem = elem || document;
      // Don't do events on text and comment nodes
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      // focus/blur morphs to focusin/out; ensure we're not firing them right now
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf('.') >= 0) {
        // Namespaced trigger; create a regexp to match event type in handle()
        namespaces = type.split('.');
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(':') < 0 && 'on' + type;
      // Caller can pass in a jQuery.Event object, Object, or just an event type string
      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
      // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join('.');
      event.namespace_re = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
      // Clean up the event in case it is being reused
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      // Clone any incoming data and prepend the event, creating the handler arg list
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      // Allow special events to draw outside the lines
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }
      // Determine event propagation path in advance, per W3C events spec (#9951)
      // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        // Only add window if we got to document (e.g., not plain obj or detached DOM)
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      // Fire handlers on the event path
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;
        // jQuery handler
        handle = (jQuery._data(cur, 'events') || {})[event.type] && jQuery._data(cur, 'handle');
        if (handle) {
          handle.apply(cur, data);
        }
        // Native handler
        handle = ontype && cur[ontype];
        if (handle && jQuery.acceptData(cur) && handle.apply && handle.apply(cur, data) === false) {
          event.preventDefault();
        }
      }
      event.type = type;
      // If nobody prevented the default action, do it now
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
          // Call a native DOM method on the target with the same name name as the event.
          // Can't use an .isFunction() check here because IE6/7 fails that test.
          // Don't do default actions on window, that's where global variables be (#6170)
          if (ontype && elem[type] && !jQuery.isWindow(elem)) {
            // Don't re-trigger an onFOO event when we call its FOO() method
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            // Prevent re-triggering of the same event, since we already bubbled it above
            jQuery.event.triggered = type;
            try {
              elem[type]();
            } catch (e) {
            }
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    dispatch: function (event) {
      // Make a writable jQuery.Event from the native event object
      event = jQuery.event.fix(event);
      var i, ret, handleObj, matched, j, handlerQueue = [], args = core_slice.call(arguments), handlers = (jQuery._data(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
      // Use the fix-ed jQuery.Event rather than the (read-only) native event
      args[0] = event;
      event.delegateTarget = this;
      // Call the preDispatch hook for the mapped type, and let it bail if desired
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }
      // Determine handlers
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      // Run delegates first; they may want to stop propagation beneath us
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          // Triggered event must either 1) have no namespace, or
          // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).
          if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      // Call the postDispatch hook for the mapped type
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function (event, handlers) {
      var sel, handleObj, matches, i, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
      // Find delegate handlers
      // Black-hole SVG <use> instance trees (#13180)
      // Avoid non-left-click bubbling in Firefox (#3861)
      if (delegateCount && cur.nodeType && (!event.button || event.type !== 'click')) {
        /* jshint eqeqeq: false */
        for (; cur != this; cur = cur.parentNode || this) {
          /* jshint eqeqeq: true */
          // Don't check non-elements (#13208)
          // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
          if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== 'click')) {
            matches = [];
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              // Don't conflict with Object.prototype properties (#13203)
              sel = handleObj.selector + ' ';
              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matches[sel]) {
                matches.push(handleObj);
              }
            }
            if (matches.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matches
              });
            }
          }
        }
      }
      // Add the remaining (directly-bound) handlers
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    fix: function (event) {
      if (event[jQuery.expando]) {
        return event;
      }
      // Create a writable copy of the event object and normalize some properties
      var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
      if (!fixHook) {
        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = new jQuery.Event(originalEvent);
      i = copy.length;
      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }
      // Support: IE<9
      // Fix target property (#1925)
      if (!event.target) {
        event.target = originalEvent.srcElement || document;
      }
      // Support: Chrome 23+, Safari?
      // Target should not be a text node (#504, #13143)
      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }
      // Support: IE<9
      // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)
      event.metaKey = !!event.metaKey;
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    props: 'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(' '),
    fixHooks: {},
    keyHooks: {
      props: 'char charCode key keyCode'.split(' '),
      filter: function (event, original) {
        // Add which for key events
        if (event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }
        return event;
      }
    },
    mouseHooks: {
      props: 'button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement'.split(' '),
      filter: function (event, original) {
        var body, eventDoc, doc, button = original.button, fromElement = original.fromElement;
        // Calculate pageX/Y if missing and clientX/Y available
        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        // Add relatedTarget, if necessary
        if (!event.relatedTarget && fromElement) {
          event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
        }
        // Add which for click: 1 === left; 2 === middle; 3 === right
        // Note: button is not normalized, so don't use it
        if (!event.which && button !== undefined) {
          event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
        }
        return event;
      }
    },
    special: {
      load: { noBubble: true },
      focus: {
        trigger: function () {
          if (this !== safeActiveElement() && this.focus) {
            try {
              this.focus();
              return false;
            } catch (e) {
            }
          }
        },
        delegateType: 'focusin'
      },
      blur: {
        trigger: function () {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: 'focusout'
      },
      click: {
        trigger: function () {
          if (jQuery.nodeName(this, 'input') && this.type === 'checkbox' && this.click) {
            this.click();
            return false;
          }
        },
        _default: function (event) {
          return jQuery.nodeName(event.target, 'a');
        }
      },
      beforeunload: {
        postDispatch: function (event) {
          // Even when returnValue equals to undefined Firefox will still show alert
          if (event.result !== undefined) {
            event.originalEvent.returnValue = event.result;
          }
        }
      }
    },
    simulate: function (type, elem, event, bubble) {
      // Piggyback on a donor event to simulate a different one.
      // Fake originalEvent to avoid donor's stopPropagation, but if the
      // simulated event prevents default then we do the same on the donor.
      var e = jQuery.extend(new jQuery.Event(), event, {
          type: type,
          isSimulated: true,
          originalEvent: {}
        });
      if (bubble) {
        jQuery.event.trigger(e, null, elem);
      } else {
        jQuery.event.dispatch.call(elem, e);
      }
      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    }
  };
  jQuery.removeEvent = document.removeEventListener ? function (elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle, false);
    }
  } : function (elem, type, handle) {
    var name = 'on' + type;
    if (elem.detachEvent) {
      // #8545, #7054, preventing memory leaks for custom events in IE6-8
      // detachEvent needed property on element, by name of that event, to properly expose it to GC
      if (typeof elem[name] === core_strundefined) {
        elem[name] = null;
      }
      elem.detachEvent(name, handle);
    }
  };
  jQuery.Event = function (src, props) {
    // Allow instantiation without the 'new' keyword
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    // Event object
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      // Events bubbling up the document may have been marked as prevented
      // by a handler lower down the tree; reflect the correct value.
      this.isDefaultPrevented = src.defaultPrevented || src.returnValue === false || src.getPreventDefault && src.getPreventDefault() ? returnTrue : returnFalse;  // Event type
    } else {
      this.type = src;
    }
    // Put explicitly provided properties onto the event object
    if (props) {
      jQuery.extend(this, props);
    }
    // Create a timestamp if incoming event doesn't have one
    this.timeStamp = src && src.timeStamp || jQuery.now();
    // Mark it as fixed
    this[jQuery.expando] = true;
  };
  // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
  // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
  jQuery.Event.prototype = {
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function () {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (!e) {
        return;
      }
      // If preventDefault exists, run it on the original event
      if (e.preventDefault) {
        e.preventDefault();  // Support: IE
                             // Otherwise set the returnValue property of the original event to false
      } else {
        e.returnValue = false;
      }
    },
    stopPropagation: function () {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (!e) {
        return;
      }
      // If stopPropagation exists, run it on the original event
      if (e.stopPropagation) {
        e.stopPropagation();
      }
      // Support: IE
      // Set the cancelBubble property of the original event to true
      e.cancelBubble = true;
    },
    stopImmediatePropagation: function () {
      this.isImmediatePropagationStopped = returnTrue;
      this.stopPropagation();
    }
  };
  // Create mouseenter/leave events using mouseover/out and event-time checks
  jQuery.each({
    mouseenter: 'mouseover',
    mouseleave: 'mouseout'
  }, function (orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function (event) {
        var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
        // For mousenter/leave call the handler if related is outside the target.
        // NB: No relatedTarget if the mouse left/entered the browser window
        if (!related || related !== target && !jQuery.contains(target, related)) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  // IE submit delegation
  if (!jQuery.support.submitBubbles) {
    jQuery.event.special.submit = {
      setup: function () {
        // Only need this for delegated form submit events
        if (jQuery.nodeName(this, 'form')) {
          return false;
        }
        // Lazy-add a submit handler when a descendant form may potentially be submitted
        jQuery.event.add(this, 'click._submit keypress._submit', function (e) {
          // Node name check avoids a VML-related crash in IE (#9807)
          var elem = e.target, form = jQuery.nodeName(elem, 'input') || jQuery.nodeName(elem, 'button') ? elem.form : undefined;
          if (form && !jQuery._data(form, 'submitBubbles')) {
            jQuery.event.add(form, 'submit._submit', function (event) {
              event._submit_bubble = true;
            });
            jQuery._data(form, 'submitBubbles', true);
          }
        });  // return undefined since we don't need an event listener
      },
      postDispatch: function (event) {
        // If form was submitted by the user, bubble the event up the tree
        if (event._submit_bubble) {
          delete event._submit_bubble;
          if (this.parentNode && !event.isTrigger) {
            jQuery.event.simulate('submit', this.parentNode, event, true);
          }
        }
      },
      teardown: function () {
        // Only need this for delegated form submit events
        if (jQuery.nodeName(this, 'form')) {
          return false;
        }
        // Remove delegated handlers; cleanData eventually reaps submit handlers attached above
        jQuery.event.remove(this, '._submit');
      }
    };
  }
  // IE change delegation and checkbox/radio fix
  if (!jQuery.support.changeBubbles) {
    jQuery.event.special.change = {
      setup: function () {
        if (rformElems.test(this.nodeName)) {
          // IE doesn't fire change on a check/radio until blur; trigger it on click
          // after a propertychange. Eat the blur-change in special.change.handle.
          // This still fires onchange a second time for check/radio after blur.
          if (this.type === 'checkbox' || this.type === 'radio') {
            jQuery.event.add(this, 'propertychange._change', function (event) {
              if (event.originalEvent.propertyName === 'checked') {
                this._just_changed = true;
              }
            });
            jQuery.event.add(this, 'click._change', function (event) {
              if (this._just_changed && !event.isTrigger) {
                this._just_changed = false;
              }
              // Allow triggered, simulated change events (#11500)
              jQuery.event.simulate('change', this, event, true);
            });
          }
          return false;
        }
        // Delegated event; lazy-add a change handler on descendant inputs
        jQuery.event.add(this, 'beforeactivate._change', function (e) {
          var elem = e.target;
          if (rformElems.test(elem.nodeName) && !jQuery._data(elem, 'changeBubbles')) {
            jQuery.event.add(elem, 'change._change', function (event) {
              if (this.parentNode && !event.isSimulated && !event.isTrigger) {
                jQuery.event.simulate('change', this.parentNode, event, true);
              }
            });
            jQuery._data(elem, 'changeBubbles', true);
          }
        });
      },
      handle: function (event) {
        var elem = event.target;
        // Swallow native change events from checkbox/radio, we already triggered them above
        if (this !== elem || event.isSimulated || event.isTrigger || elem.type !== 'radio' && elem.type !== 'checkbox') {
          return event.handleObj.handler.apply(this, arguments);
        }
      },
      teardown: function () {
        jQuery.event.remove(this, '._change');
        return !rformElems.test(this.nodeName);
      }
    };
  }
  // Create "bubbling" focus and blur events
  if (!jQuery.support.focusinBubbles) {
    jQuery.each({
      focus: 'focusin',
      blur: 'focusout'
    }, function (orig, fix) {
      // Attach a single capturing handler while someone wants focusin/focusout
      var attaches = 0, handler = function (event) {
          jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
        };
      jQuery.event.special[fix] = {
        setup: function () {
          if (attaches++ === 0) {
            document.addEventListener(orig, handler, true);
          }
        },
        teardown: function () {
          if (--attaches === 0) {
            document.removeEventListener(orig, handler, true);
          }
        }
      };
    });
  }
  jQuery.fn.extend({
    on: function (types, selector, data, fn, one) {
      var type, origFn;
      // Types can be a map of types/handlers
      if (typeof types === 'object') {
        // ( types-Object, selector, data )
        if (typeof selector !== 'string') {
          // ( types-Object, data )
          data = data || selector;
          selector = undefined;
        }
        for (type in types) {
          this.on(type, selector, data, types[type], one);
        }
        return this;
      }
      if (data == null && fn == null) {
        // ( types, fn )
        fn = selector;
        data = selector = undefined;
      } else if (fn == null) {
        if (typeof selector === 'string') {
          // ( types, selector, fn )
          fn = data;
          data = undefined;
        } else {
          // ( types, data, fn )
          fn = data;
          data = selector;
          selector = undefined;
        }
      }
      if (fn === false) {
        fn = returnFalse;
      } else if (!fn) {
        return this;
      }
      if (one === 1) {
        origFn = fn;
        fn = function (event) {
          // Can use an empty set, since event contains the info
          jQuery().off(event);
          return origFn.apply(this, arguments);
        };
        // Use same guid so caller can remove using origFn
        fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
      }
      return this.each(function () {
        jQuery.event.add(this, types, fn, data, selector);
      });
    },
    one: function (types, selector, data, fn) {
      return this.on(types, selector, data, fn, 1);
    },
    off: function (types, selector, fn) {
      var handleObj, type;
      if (types && types.preventDefault && types.handleObj) {
        // ( event )  dispatched jQuery.Event
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === 'object') {
        // ( types-object [, selector] )
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === 'function') {
        // ( types [, fn] )
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function () {
        jQuery.event.remove(this, types, fn, selector);
      });
    },
    trigger: function (type, data) {
      return this.each(function () {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function (type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  var isSimple = /^.[^:#\[\.,]*$/, rparentsprev = /^(?:parents|prev(?:Until|All))/, rneedsContext = jQuery.expr.match.needsContext,
    // methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
      children: true,
      contents: true,
      next: true,
      prev: true
    };
  jQuery.fn.extend({
    find: function (selector) {
      var i, ret = [], self = this, len = self.length;
      if (typeof selector !== 'string') {
        return this.pushStack(jQuery(selector).filter(function () {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      // Needed because $( selector, context ) becomes $( context ).find( selector )
      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + ' ' + selector : selector;
      return ret;
    },
    has: function (target) {
      var i, targets = jQuery(target, this), len = targets.length;
      return this.filter(function () {
        for (i = 0; i < len; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    not: function (selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    filter: function (selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    is: function (selector) {
      return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    },
    closest: function (selectors, context) {
      var cur, i = 0, l = this.length, ret = [], pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ? jQuery(selectors, context || this.context) : 0;
      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          // Always skip document fragments
          if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
            cur = ret.push(cur);
            break;
          }
        }
      }
      return this.pushStack(ret.length > 1 ? jQuery.unique(ret) : ret);
    },
    index: function (elem) {
      // No argument, return index in parent
      if (!elem) {
        return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
      }
      // index in selector
      if (typeof elem === 'string') {
        return jQuery.inArray(this[0], jQuery(elem));
      }
      // Locate the position of the desired element
      return jQuery.inArray(elem.jquery ? elem[0] : elem, this);
    },
    add: function (selector, context) {
      var set = typeof selector === 'string' ? jQuery(selector, context) : jQuery.makeArray(selector && selector.nodeType ? [selector] : selector), all = jQuery.merge(this.get(), set);
      return this.pushStack(jQuery.unique(all));
    },
    addBack: function (selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    do {
      cur = cur[dir];
    } while (cur && cur.nodeType !== 1);
    return cur;
  }
  jQuery.each({
    parent: function (elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function (elem) {
      return jQuery.dir(elem, 'parentNode');
    },
    parentsUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'parentNode', until);
    },
    next: function (elem) {
      return sibling(elem, 'nextSibling');
    },
    prev: function (elem) {
      return sibling(elem, 'previousSibling');
    },
    nextAll: function (elem) {
      return jQuery.dir(elem, 'nextSibling');
    },
    prevAll: function (elem) {
      return jQuery.dir(elem, 'previousSibling');
    },
    nextUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'nextSibling', until);
    },
    prevUntil: function (elem, i, until) {
      return jQuery.dir(elem, 'previousSibling', until);
    },
    siblings: function (elem) {
      return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
    },
    children: function (elem) {
      return jQuery.sibling(elem.firstChild);
    },
    contents: function (elem) {
      return jQuery.nodeName(elem, 'iframe') ? elem.contentDocument || elem.contentWindow.document : jQuery.merge([], elem.childNodes);
    }
  }, function (name, fn) {
    jQuery.fn[name] = function (until, selector) {
      var ret = jQuery.map(this, fn, until);
      if (name.slice(-5) !== 'Until') {
        selector = until;
      }
      if (selector && typeof selector === 'string') {
        ret = jQuery.filter(selector, ret);
      }
      if (this.length > 1) {
        // Remove duplicates
        if (!guaranteedUnique[name]) {
          ret = jQuery.unique(ret);
        }
        // Reverse order for parents* and prev-derivatives
        if (rparentsprev.test(name)) {
          ret = ret.reverse();
        }
      }
      return this.pushStack(ret);
    };
  });
  jQuery.extend({
    filter: function (expr, elems, not) {
      var elem = elems[0];
      if (not) {
        expr = ':not(' + expr + ')';
      }
      return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
        return elem.nodeType === 1;
      }));
    },
    dir: function (elem, dir, until) {
      var matched = [], cur = elem[dir];
      while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
        if (cur.nodeType === 1) {
          matched.push(cur);
        }
        cur = cur[dir];
      }
      return matched;
    },
    sibling: function (n, elem) {
      var r = [];
      for (; n; n = n.nextSibling) {
        if (n.nodeType === 1 && n !== elem) {
          r.push(n);
        }
      }
      return r;
    }
  });
  // Implement the identical functionality for filter and not
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function (elem, i) {
        /* jshint -W018 */
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function (elem) {
        return elem === qualifier !== not;
      });
    }
    if (typeof qualifier === 'string') {
      if (isSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }
      qualifier = jQuery.filter(qualifier, elements);
    }
    return jQuery.grep(elements, function (elem) {
      return jQuery.inArray(elem, qualifier) >= 0 !== not;
    });
  }
  function createSafeFragment(document) {
    var list = nodeNames.split('|'), safeFrag = document.createDocumentFragment();
    if (safeFrag.createElement) {
      while (list.length) {
        safeFrag.createElement(list.pop());
      }
    }
    return safeFrag;
  }
  var nodeNames = 'abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|' + 'header|hgroup|mark|meter|nav|output|progress|section|summary|time|video', rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g, rnoshimcache = new RegExp('<(?:' + nodeNames + ')[\\s/>]', 'i'), rleadingWhitespace = /^\s+/, rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rtbody = /<tbody/i, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, manipulation_rcheckableType = /^(?:checkbox|radio)$/i,
    // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,
    // We have to close these tags to support XHTML (#13200)
    wrapMap = {
      option: [
        1,
        '<select multiple=\'multiple\'>',
        '</select>'
      ],
      legend: [
        1,
        '<fieldset>',
        '</fieldset>'
      ],
      area: [
        1,
        '<map>',
        '</map>'
      ],
      param: [
        1,
        '<object>',
        '</object>'
      ],
      thead: [
        1,
        '<table>',
        '</table>'
      ],
      tr: [
        2,
        '<table><tbody>',
        '</tbody></table>'
      ],
      col: [
        2,
        '<table><tbody></tbody><colgroup>',
        '</colgroup></table>'
      ],
      td: [
        3,
        '<table><tbody><tr>',
        '</tr></tbody></table>'
      ],
      _default: jQuery.support.htmlSerialize ? [
        0,
        '',
        ''
      ] : [
        1,
        'X<div>',
        '</div>'
      ]
    }, safeFragment = createSafeFragment(document), fragmentDiv = safeFragment.appendChild(document.createElement('div'));
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  jQuery.fn.extend({
    text: function (value) {
      return jQuery.access(this, function (value) {
        return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
      }, null, value, arguments.length);
    },
    append: function () {
      return this.domManip(arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function () {
      return this.domManip(arguments, function (elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function () {
      return this.domManip(arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function () {
      return this.domManip(arguments, function (elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    remove: function (selector, keepData) {
      var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
      for (; (elem = elems[i]) != null; i++) {
        if (!keepData && elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem));
        }
        if (elem.parentNode) {
          if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
            setGlobalEval(getAll(elem, 'script'));
          }
          elem.parentNode.removeChild(elem);
        }
      }
      return this;
    },
    empty: function () {
      var elem, i = 0;
      for (; (elem = this[i]) != null; i++) {
        // Remove element nodes and prevent memory leaks
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
        }
        // Remove any remaining nodes
        while (elem.firstChild) {
          elem.removeChild(elem.firstChild);
        }
        // If this is a select, ensure that it displays empty (#12336)
        // Support: IE<9
        if (elem.options && jQuery.nodeName(elem, 'select')) {
          elem.options.length = 0;
        }
      }
      return this;
    },
    clone: function (dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function () {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function (value) {
      return jQuery.access(this, function (value) {
        var elem = this[0] || {}, i = 0, l = this.length;
        if (value === undefined) {
          return elem.nodeType === 1 ? elem.innerHTML.replace(rinlinejQuery, '') : undefined;
        }
        // See if we can take a shortcut and just use innerHTML
        if (typeof value === 'string' && !rnoInnerhtml.test(value) && (jQuery.support.htmlSerialize || !rnoshimcache.test(value)) && (jQuery.support.leadingWhitespace || !rleadingWhitespace.test(value)) && !wrapMap[(rtagName.exec(value) || [
            '',
            ''
          ])[1].toLowerCase()]) {
          value = value.replace(rxhtmlTag, '<$1></$2>');
          try {
            for (; i < l; i++) {
              // Remove element nodes and prevent memory leaks
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;  // If using innerHTML throws an exception, use the fallback method
          } catch (e) {
          }
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function () {
      var
        // Snapshot the DOM in case .domManip sweeps something relevant into its fragment
        args = jQuery.map(this, function (elem) {
          return [
            elem.nextSibling,
            elem.parentNode
          ];
        }), i = 0;
      // Make the changes, replacing each context element with the new content
      this.domManip(arguments, function (elem) {
        var next = args[i++], parent = args[i++];
        if (parent) {
          // Don't use the snapshot next if it has moved (#13810)
          if (next && next.parentNode !== parent) {
            next = this.nextSibling;
          }
          jQuery(this).remove();
          parent.insertBefore(elem, next);
        }  // Allow new content to include elements from the context set
      }, true);
      // Force removal if there was no new content (e.g., from empty arguments)
      return i ? this : this.remove();
    },
    detach: function (selector) {
      return this.remove(selector, true);
    },
    domManip: function (args, callback, allowIntersection) {
      // Flatten any nested arrays
      args = core_concat.apply([], args);
      var first, node, hasScripts, scripts, doc, fragment, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
      // We can't cloneNode fragments that contain checked, in WebKit
      if (isFunction || !(l <= 1 || typeof value !== 'string' || jQuery.support.checkClone || !rchecked.test(value))) {
        return this.each(function (index) {
          var self = set.eq(index);
          if (isFunction) {
            args[0] = value.call(this, index, self.html());
          }
          self.domManip(args, callback, allowIntersection);
        });
      }
      if (l) {
        fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, !allowIntersection && this);
        first = fragment.firstChild;
        if (fragment.childNodes.length === 1) {
          fragment = first;
        }
        if (first) {
          scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
          hasScripts = scripts.length;
          // Use the original fragment for the last item instead of the first because it can end up
          // being emptied incorrectly in certain situations (#8070).
          for (; i < l; i++) {
            node = fragment;
            if (i !== iNoClone) {
              node = jQuery.clone(node, true, true);
              // Keep references to cloned scripts for later restoration
              if (hasScripts) {
                jQuery.merge(scripts, getAll(node, 'script'));
              }
            }
            callback.call(this[i], node, i);
          }
          if (hasScripts) {
            doc = scripts[scripts.length - 1].ownerDocument;
            // Reenable scripts
            jQuery.map(scripts, restoreScript);
            // Evaluate executable scripts on first document insertion
            for (i = 0; i < hasScripts; i++) {
              node = scripts[i];
              if (rscriptType.test(node.type || '') && !jQuery._data(node, 'globalEval') && jQuery.contains(doc, node)) {
                if (node.src) {
                  // Hope ajax is available...
                  jQuery._evalUrl(node.src);
                } else {
                  jQuery.globalEval((node.text || node.textContent || node.innerHTML || '').replace(rcleanScript, ''));
                }
              }
            }
          }
          // Fix #11809: Avoid leaking memory
          fragment = first = null;
        }
      }
      return this;
    }
  });
  // Support: IE<8
  // Manipulating tables requires a tbody
  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType === 1 ? content : content.firstChild, 'tr') ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody')) : elem;
  }
  // Replace/restore the type attribute of script elements for safe DOM manipulation
  function disableScript(elem) {
    elem.type = (jQuery.find.attr(elem, 'type') !== null) + '/' + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute('type');
    }
    return elem;
  }
  // Mark scripts as having already been evaluated
  function setGlobalEval(elems, refElements) {
    var elem, i = 0;
    for (; (elem = elems[i]) != null; i++) {
      jQuery._data(elem, 'globalEval', !refElements || jQuery._data(refElements[i], 'globalEval'));
    }
  }
  function cloneCopyEvent(src, dest) {
    if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
      return;
    }
    var type, i, l, oldData = jQuery._data(src), curData = jQuery._data(dest, oldData), events = oldData.events;
    if (events) {
      delete curData.handle;
      curData.events = {};
      for (type in events) {
        for (i = 0, l = events[type].length; i < l; i++) {
          jQuery.event.add(dest, type, events[type][i]);
        }
      }
    }
    // make the cloned public data object a copy from the original
    if (curData.data) {
      curData.data = jQuery.extend({}, curData.data);
    }
  }
  function fixCloneNodeIssues(src, dest) {
    var nodeName, e, data;
    // We do not need to do anything for non-Elements
    if (dest.nodeType !== 1) {
      return;
    }
    nodeName = dest.nodeName.toLowerCase();
    // IE6-8 copies events bound via attachEvent when using cloneNode.
    if (!jQuery.support.noCloneEvent && dest[jQuery.expando]) {
      data = jQuery._data(dest);
      for (e in data.events) {
        jQuery.removeEvent(dest, e, data.handle);
      }
      // Event data gets referenced instead of copied if the expando gets copied too
      dest.removeAttribute(jQuery.expando);
    }
    // IE blanks contents when cloning scripts, and tries to evaluate newly-set text
    if (nodeName === 'script' && dest.text !== src.text) {
      disableScript(dest).text = src.text;
      restoreScript(dest);  // IE6-10 improperly clones children of object elements using classid.
                            // IE10 throws NoModificationAllowedError if parent is null, #12132.
    } else if (nodeName === 'object') {
      if (dest.parentNode) {
        dest.outerHTML = src.outerHTML;
      }
      // This path appears unavoidable for IE9. When cloning an object
      // element in IE9, the outerHTML strategy above is not sufficient.
      // If the src has innerHTML and the destination does not,
      // copy the src.innerHTML into the dest.innerHTML. #10324
      if (jQuery.support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML))) {
        dest.innerHTML = src.innerHTML;
      }
    } else if (nodeName === 'input' && manipulation_rcheckableType.test(src.type)) {
      // IE6-8 fails to persist the checked state of a cloned checkbox
      // or radio button. Worse, IE6-7 fail to give the cloned element
      // a checked appearance if the defaultChecked value isn't also set
      dest.defaultChecked = dest.checked = src.checked;
      // IE6-7 get confused and end up setting the value of a cloned
      // checkbox/radio button to an empty string instead of "on"
      if (dest.value !== src.value) {
        dest.value = src.value;
      }  // IE6-8 fails to return the selected option to the default selected
         // state when cloning options
    } else if (nodeName === 'option') {
      dest.defaultSelected = dest.selected = src.defaultSelected;  // IE6-8 fails to set the defaultValue to the correct value when
                                                                   // cloning other types of input fields
    } else if (nodeName === 'input' || nodeName === 'textarea') {
      dest.defaultValue = src.defaultValue;
    }
  }
  jQuery.each({
    appendTo: 'append',
    prependTo: 'prepend',
    insertBefore: 'before',
    insertAfter: 'after',
    replaceAll: 'replaceWith'
  }, function (name, original) {
    jQuery.fn[name] = function (selector) {
      var elems, i = 0, ret = [], insert = jQuery(selector), last = insert.length - 1;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()
        core_push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  function getAll(context, tag) {
    var elems, elem, i = 0, found = typeof context.getElementsByTagName !== core_strundefined ? context.getElementsByTagName(tag || '*') : typeof context.querySelectorAll !== core_strundefined ? context.querySelectorAll(tag || '*') : undefined;
    if (!found) {
      for (found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++) {
        if (!tag || jQuery.nodeName(elem, tag)) {
          found.push(elem);
        } else {
          jQuery.merge(found, getAll(elem, tag));
        }
      }
    }
    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], found) : found;
  }
  // Used in buildFragment, fixes the defaultChecked property
  function fixDefaultChecked(elem) {
    if (manipulation_rcheckableType.test(elem.type)) {
      elem.defaultChecked = elem.checked;
    }
  }
  jQuery.extend({
    clone: function (elem, dataAndEvents, deepDataAndEvents) {
      var destElements, node, clone, i, srcElements, inPage = jQuery.contains(elem.ownerDocument, elem);
      if (jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test('<' + elem.nodeName + '>')) {
        clone = elem.cloneNode(true);  // IE<=8 does not properly clone detached, unknown element nodes
      } else {
        fragmentDiv.innerHTML = elem.outerHTML;
        fragmentDiv.removeChild(clone = fragmentDiv.firstChild);
      }
      if ((!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
        destElements = getAll(clone);
        srcElements = getAll(elem);
        // Fix all IE cloning issues
        for (i = 0; (node = srcElements[i]) != null; ++i) {
          // Ensure that the destination node is not null; Fixes #9587
          if (destElements[i]) {
            fixCloneNodeIssues(node, destElements[i]);
          }
        }
      }
      // Copy the events from the original to the clone
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0; (node = srcElements[i]) != null; i++) {
            cloneCopyEvent(node, destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      // Preserve script evaluation history
      destElements = getAll(clone, 'script');
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
      }
      destElements = srcElements = node = null;
      // Return the cloned set
      return clone;
    },
    buildFragment: function (elems, context, scripts, selection) {
      var j, elem, contains, tmp, tag, tbody, wrap, l = elems.length,
        // Ensure a safe fragment
        safe = createSafeFragment(context), nodes = [], i = 0;
      for (; i < l; i++) {
        elem = elems[i];
        if (elem || elem === 0) {
          // Add nodes directly
          if (jQuery.type(elem) === 'object') {
            jQuery.merge(nodes, elem.nodeType ? [elem] : elem);  // Convert non-html into a text node
          } else if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));  // Convert html into DOM nodes
          } else {
            tmp = tmp || safe.appendChild(context.createElement('div'));
            // Deserialize a standard representation
            tag = (rtagName.exec(elem) || [
              '',
              ''
            ])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, '<$1></$2>') + wrap[2];
            // Descend through wrappers to the right content
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            // Manually add leading whitespace removed by IE
            if (!jQuery.support.leadingWhitespace && rleadingWhitespace.test(elem)) {
              nodes.push(context.createTextNode(rleadingWhitespace.exec(elem)[0]));
            }
            // Remove IE's autoinserted <tbody> from table fragments
            if (!jQuery.support.tbody) {
              // String was a <table>, *may* have spurious <tbody>
              elem = tag === 'table' && !rtbody.test(elem) ? tmp.firstChild : wrap[1] === '<table>' && !rtbody.test(elem) ? tmp : 0;
              j = elem && elem.childNodes.length;
              while (j--) {
                if (jQuery.nodeName(tbody = elem.childNodes[j], 'tbody') && !tbody.childNodes.length) {
                  elem.removeChild(tbody);
                }
              }
            }
            jQuery.merge(nodes, tmp.childNodes);
            // Fix #12392 for WebKit and IE > 9
            tmp.textContent = '';
            // Fix #12392 for oldIE
            while (tmp.firstChild) {
              tmp.removeChild(tmp.firstChild);
            }
            // Remember the top-level container for proper cleanup
            tmp = safe.lastChild;
          }
        }
      }
      // Fix #11356: Clear elements from fragment
      if (tmp) {
        safe.removeChild(tmp);
      }
      // Reset defaultChecked for any radios and checkboxes
      // about to be appended to the DOM in IE 6/7 (#8060)
      if (!jQuery.support.appendChecked) {
        jQuery.grep(getAll(nodes, 'input'), fixDefaultChecked);
      }
      i = 0;
      while (elem = nodes[i++]) {
        // #4087 - If origin and destination elements are the same, and this is
        // that element, do not do anything
        if (selection && jQuery.inArray(elem, selection) !== -1) {
          continue;
        }
        contains = jQuery.contains(elem.ownerDocument, elem);
        // Append to fragment
        tmp = getAll(safe.appendChild(elem), 'script');
        // Preserve script evaluation history
        if (contains) {
          setGlobalEval(tmp);
        }
        // Capture executables
        if (scripts) {
          j = 0;
          while (elem = tmp[j++]) {
            if (rscriptType.test(elem.type || '')) {
              scripts.push(elem);
            }
          }
        }
      }
      tmp = null;
      return safe;
    },
    cleanData: function (elems, acceptData) {
      var elem, type, id, data, i = 0, internalKey = jQuery.expando, cache = jQuery.cache, deleteExpando = jQuery.support.deleteExpando, special = jQuery.event.special;
      for (; (elem = elems[i]) != null; i++) {
        if (acceptData || jQuery.acceptData(elem)) {
          id = elem[internalKey];
          data = id && cache[id];
          if (data) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);  // This is a shortcut to avoid jQuery.event.remove's overhead
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            // Remove cache only if it was not already removed by jQuery.event.remove
            if (cache[id]) {
              delete cache[id];
              // IE does not allow us to delete expando properties from nodes,
              // nor does it have a removeAttribute function on Document nodes;
              // we must handle all of these cases
              if (deleteExpando) {
                delete elem[internalKey];
              } else if (typeof elem.removeAttribute !== core_strundefined) {
                elem.removeAttribute(internalKey);
              } else {
                elem[internalKey] = null;
              }
              core_deletedIds.push(id);
            }
          }
        }
      }
    },
    _evalUrl: function (url) {
      return jQuery.ajax({
        url: url,
        type: 'GET',
        dataType: 'script',
        async: false,
        global: false,
        'throws': true
      });
    }
  });
  jQuery.fn.extend({
    wrapAll: function (html) {
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }
      if (this[0]) {
        // The elements to wrap the target around
        var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function () {
          var elem = this;
          while (elem.firstChild && elem.firstChild.nodeType === 1) {
            elem = elem.firstChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function (html) {
      if (jQuery.isFunction(html)) {
        return this.each(function (i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function () {
        var self = jQuery(this), contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function (html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function (i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function () {
      return this.parent().each(function () {
        if (!jQuery.nodeName(this, 'body')) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    }
  });
  var iframe, getStyles, curCSS, ralpha = /alpha\([^)]*\)/i, ropacity = /opacity\s*=\s*([^)]*)/, rposition = /^(top|right|bottom|left)$/,
    // swappable if display is none or starts with table except "table", "table-cell", or "table-caption"
    // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/, rmargin = /^margin/, rnumsplit = new RegExp('^(' + core_pnum + ')(.*)$', 'i'), rnumnonpx = new RegExp('^(' + core_pnum + ')(?!px)[a-z%]+$', 'i'), rrelNum = new RegExp('^([+-])=(' + core_pnum + ')', 'i'), elemdisplay = { BODY: 'block' }, cssShow = {
      position: 'absolute',
      visibility: 'hidden',
      display: 'block'
    }, cssNormalTransform = {
      letterSpacing: 0,
      fontWeight: 400
    }, cssExpand = [
      'Top',
      'Right',
      'Bottom',
      'Left'
    ], cssPrefixes = [
      'Webkit',
      'O',
      'Moz',
      'ms'
    ];
  // return a css property mapped to a potentially vendor prefixed property
  function vendorPropName(style, name) {
    // shortcut for names that are not vendor prefixed
    if (name in style) {
      return name;
    }
    // check for vendor prefixed names
    var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in style) {
        return name;
      }
    }
    return origName;
  }
  function isHidden(elem, el) {
    // isHidden might be called from jQuery#filter function;
    // in that case, element will be second argument
    elem = el || elem;
    return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
  }
  function showHide(elements, show) {
    var display, elem, hidden, values = [], index = 0, length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      values[index] = jQuery._data(elem, 'olddisplay');
      display = elem.style.display;
      if (show) {
        // Reset the inline display of this element to learn if it is
        // being hidden by cascaded rules or not
        if (!values[index] && display === 'none') {
          elem.style.display = '';
        }
        // Set elements which have been overridden with display: none
        // in a stylesheet to whatever the default browser style is
        // for such an element
        if (elem.style.display === '' && isHidden(elem)) {
          values[index] = jQuery._data(elem, 'olddisplay', css_defaultDisplay(elem.nodeName));
        }
      } else {
        if (!values[index]) {
          hidden = isHidden(elem);
          if (display && display !== 'none' || !hidden) {
            jQuery._data(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
          }
        }
      }
    }
    // Set the display of most of the elements in a second loop
    // to avoid the constant reflow
    for (index = 0; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === 'none' || elem.style.display === '') {
        elem.style.display = show ? values[index] || '' : 'none';
      }
    }
    return elements;
  }
  jQuery.fn.extend({
    css: function (name, value) {
      return jQuery.access(this, function (elem, name, value) {
        var len, styles, map = {}, i = 0;
        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    },
    show: function () {
      return showHide(this, true);
    },
    hide: function () {
      return showHide(this);
    },
    toggle: function (state) {
      if (typeof state === 'boolean') {
        return state ? this.show() : this.hide();
      }
      return this.each(function () {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  jQuery.extend({
    cssHooks: {
      opacity: {
        get: function (elem, computed) {
          if (computed) {
            // We should always get a number back from opacity
            var ret = curCSS(elem, 'opacity');
            return ret === '' ? '1' : ret;
          }
        }
      }
    },
    cssNumber: {
      'columnCount': true,
      'fillOpacity': true,
      'fontWeight': true,
      'lineHeight': true,
      'opacity': true,
      'order': true,
      'orphans': true,
      'widows': true,
      'zIndex': true,
      'zoom': true
    },
    cssProps: { 'float': jQuery.support.cssFloat ? 'cssFloat' : 'styleFloat' },
    style: function (elem, name, value, extra) {
      // Don't set styles on text and comment nodes
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      // Make sure that we're working with the right name
      var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
      // gets hook for the prefixed version
      // followed by the unprefixed version
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      // Check if we're setting a value
      if (value !== undefined) {
        type = typeof value;
        // convert relative number strings (+= or -=) to relative numbers. #7345
        if (type === 'string' && (ret = rrelNum.exec(value))) {
          value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
          // Fixes bug #9237
          type = 'number';
        }
        // Make sure that NaN and null values aren't set. See: #7116
        if (value == null || type === 'number' && isNaN(value)) {
          return;
        }
        // If a number was passed in, add 'px' to the (except for certain CSS properties)
        if (type === 'number' && !jQuery.cssNumber[origName]) {
          value += 'px';
        }
        // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,
        // but it would mean to define eight (for every problematic property) identical functions
        if (!jQuery.support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
          style[name] = 'inherit';
        }
        // If a hook was provided, use that value, otherwise just set the specified value
        if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          // Wrapped to prevent IE from throwing errors when 'invalid' values are provided
          // Fixes bug #5509
          try {
            style[name] = value;
          } catch (e) {
          }
        }
      } else {
        // If a hook was provided get the non-computed value from there
        if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        // Otherwise just get the value from the style object
        return style[name];
      }
    },
    css: function (elem, name, extra, styles) {
      var num, val, hooks, origName = jQuery.camelCase(name);
      // Make sure that we're working with the right name
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
      // gets hook for the prefixed version
      // followed by the unprefixed version
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      // If a hook was provided get the computed value from there
      if (hooks && 'get' in hooks) {
        val = hooks.get(elem, true, extra);
      }
      // Otherwise, if a way to get the computed value exists, use that
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      //convert "normal" to computed value
      if (val === 'normal' && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      // Return, converting to number if forced or a qualifier was provided and val looks numeric
      if (extra === '' || extra) {
        num = parseFloat(val);
        return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
      }
      return val;
    }
  });
  // NOTE: we've included the "window" in window.getComputedStyle
  // because jsdom on node.js will break without it.
  if (window.getComputedStyle) {
    getStyles = function (elem) {
      return window.getComputedStyle(elem, null);
    };
    curCSS = function (elem, name, _computed) {
      var width, minWidth, maxWidth, computed = _computed || getStyles(elem),
        // getPropertyValue is only needed for .css('filter') in IE9, see #12537
        ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined, style = elem.style;
      if (computed) {
        if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
          ret = jQuery.style(elem, name);
        }
        // A tribute to the "awesome hack by Dean Edwards"
        // Chrome < 17 and Safari 5.0 uses "computed value" instead of "used value" for margin-right
        // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels
        // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values
        if (rnumnonpx.test(ret) && rmargin.test(name)) {
          // Remember the original values
          width = style.width;
          minWidth = style.minWidth;
          maxWidth = style.maxWidth;
          // Put in the new values to get a computed value out
          style.minWidth = style.maxWidth = style.width = ret;
          ret = computed.width;
          // Revert the changed values
          style.width = width;
          style.minWidth = minWidth;
          style.maxWidth = maxWidth;
        }
      }
      return ret;
    };
  } else if (document.documentElement.currentStyle) {
    getStyles = function (elem) {
      return elem.currentStyle;
    };
    curCSS = function (elem, name, _computed) {
      var left, rs, rsLeft, computed = _computed || getStyles(elem), ret = computed ? computed[name] : undefined, style = elem.style;
      // Avoid setting ret to empty string here
      // so we don't default to auto
      if (ret == null && style && style[name]) {
        ret = style[name];
      }
      // From the awesome hack by Dean Edwards
      // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
      // If we're not dealing with a regular pixel number
      // but a number that has a weird ending, we need to convert it to pixels
      // but not position css attributes, as those are proportional to the parent element instead
      // and we can't measure the parent instead because it might trigger a "stacking dolls" problem
      if (rnumnonpx.test(ret) && !rposition.test(name)) {
        // Remember the original values
        left = style.left;
        rs = elem.runtimeStyle;
        rsLeft = rs && rs.left;
        // Put in the new values to get a computed value out
        if (rsLeft) {
          rs.left = elem.currentStyle.left;
        }
        style.left = name === 'fontSize' ? '1em' : ret;
        ret = style.pixelLeft + 'px';
        // Revert the changed values
        style.left = left;
        if (rsLeft) {
          rs.left = rsLeft;
        }
      }
      return ret === '' ? 'auto' : ret;
    };
  }
  function setPositiveNumber(elem, value, subtract) {
    var matches = rnumsplit.exec(value);
    return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || 'px') : value;
  }
  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? 'border' : 'content') ? 4 : name === 'width' ? 1 : 0, val = 0;
    for (; i < 4; i += 2) {
      // both box models exclude margin, so add it if we want it
      if (extra === 'margin') {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        // border-box includes padding, so remove it if we want content
        if (extra === 'content') {
          val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
        }
        // at this point, extra isn't border nor margin, so remove border
        if (extra !== 'margin') {
          val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
        }
      } else {
        // at this point, extra isn't content, so add padding
        val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
        // at this point, extra isn't content nor padding, so add border
        if (extra !== 'padding') {
          val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
        }
      }
    }
    return val;
  }
  function getWidthOrHeight(elem, name, extra) {
    // Start with offset property, which is equivalent to the border-box value
    var valueIsBorderBox = true, val = name === 'width' ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = jQuery.support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
    // some non-html elements return undefined for offsetWidth, so check for null/undefined
    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
    if (val <= 0 || val == null) {
      // Fall back to computed then uncomputed css if necessary
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      // Computed unit is not pixels. Stop here and return.
      if (rnumnonpx.test(val)) {
        return val;
      }
      // we need the check for style in case a browser which returns unreliable values
      // for getComputedStyle silently falls back to the reliable elem.style
      valueIsBorderBox = isBorderBox && (jQuery.support.boxSizingReliable || val === elem.style[name]);
      // Normalize "", auto, and prepare for extra
      val = parseFloat(val) || 0;
    }
    // use the active box-sizing model to add/subtract irrelevant styles
    return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
  }
  // Try to determine the default display value of an element
  function css_defaultDisplay(nodeName) {
    var doc = document, display = elemdisplay[nodeName];
    if (!display) {
      display = actualDisplay(nodeName, doc);
      // If the simple way fails, read from inside an iframe
      if (display === 'none' || !display) {
        // Use the already-created iframe if possible
        iframe = (iframe || jQuery('<iframe frameborder=\'0\' width=\'0\' height=\'0\'/>').css('cssText', 'display:block !important')).appendTo(doc.documentElement);
        // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
        doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;
        doc.write('<!doctype html><html><body>');
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }
      // Store the correct default display
      elemdisplay[nodeName] = display;
    }
    return display;
  }
  // Called ONLY from within css_defaultDisplay
  function actualDisplay(name, doc) {
    var elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = jQuery.css(elem[0], 'display');
    elem.remove();
    return display;
  }
  jQuery.each([
    'height',
    'width'
  ], function (i, name) {
    jQuery.cssHooks[name] = {
      get: function (elem, computed, extra) {
        if (computed) {
          // certain elements can have dimension info if we invisibly show them
          // however, it must have a current display style that would benefit from this
          return elem.offsetWidth === 0 && rdisplayswap.test(jQuery.css(elem, 'display')) ? jQuery.swap(elem, cssShow, function () {
            return getWidthOrHeight(elem, name, extra);
          }) : getWidthOrHeight(elem, name, extra);
        }
      },
      set: function (elem, value, extra) {
        var styles = extra && getStyles(elem);
        return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, jQuery.support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles) : 0);
      }
    };
  });
  if (!jQuery.support.opacity) {
    jQuery.cssHooks.opacity = {
      get: function (elem, computed) {
        // IE uses filters for opacity
        return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || '') ? 0.01 * parseFloat(RegExp.$1) + '' : computed ? '1' : '';
      },
      set: function (elem, value) {
        var style = elem.style, currentStyle = elem.currentStyle, opacity = jQuery.isNumeric(value) ? 'alpha(opacity=' + value * 100 + ')' : '', filter = currentStyle && currentStyle.filter || style.filter || '';
        // IE has trouble with opacity if it does not have layout
        // Force it by setting the zoom level
        style.zoom = 1;
        // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652
        // if value === "", then remove inline opacity #12685
        if ((value >= 1 || value === '') && jQuery.trim(filter.replace(ralpha, '')) === '' && style.removeAttribute) {
          // Setting style.filter to null, "" & " " still leave "filter:" in the cssText
          // if "filter:" is present at all, clearType is disabled, we want to avoid this
          // style.removeAttribute is IE Only, but so apparently is this code path...
          style.removeAttribute('filter');
          // if there is no filter style applied in a css rule or unset inline opacity, we are done
          if (value === '' || currentStyle && !currentStyle.filter) {
            return;
          }
        }
        // otherwise, set new filter values
        style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + ' ' + opacity;
      }
    };
  }
  // These hooks cannot be added until DOM ready because the support test
  // for it is not run until after DOM ready
  jQuery(function () {
    if (!jQuery.support.reliableMarginRight) {
      jQuery.cssHooks.marginRight = {
        get: function (elem, computed) {
          if (computed) {
            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
            // Work around by temporarily setting element display to inline-block
            return jQuery.swap(elem, { 'display': 'inline-block' }, curCSS, [
              elem,
              'marginRight'
            ]);
          }
        }
      };
    }
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // getComputedStyle returns percent when specified for top/left/bottom/right
    // rather than make the css module depend on the offset module, we just check for it here
    if (!jQuery.support.pixelPosition && jQuery.fn.position) {
      jQuery.each([
        'top',
        'left'
      ], function (i, prop) {
        jQuery.cssHooks[prop] = {
          get: function (elem, computed) {
            if (computed) {
              computed = curCSS(elem, prop);
              // if curCSS returns percentage, fallback to offset
              return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
            }
          }
        };
      });
    }
  });
  if (jQuery.expr && jQuery.expr.filters) {
    jQuery.expr.filters.hidden = function (elem) {
      // Support: Opera <= 12.12
      // Opera reports offsetWidths and offsetHeights less than zero on some elements
      return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 || !jQuery.support.reliableHiddenOffsets && (elem.style && elem.style.display || jQuery.css(elem, 'display')) === 'none';
    };
    jQuery.expr.filters.visible = function (elem) {
      return !jQuery.expr.filters.hidden(elem);
    };
  }
  // These hooks are used by animate to expand properties
  jQuery.each({
    margin: '',
    padding: '',
    border: 'Width'
  }, function (prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {
      expand: function (value) {
        var i = 0, expanded = {},
          // assumes a single number if not a string
          parts = typeof value === 'string' ? value.split(' ') : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }
    };
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
  jQuery.fn.extend({
    serialize: function () {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function () {
      return this.map(function () {
        // Can add propHook for "elements" to filter or add form elements
        var elements = jQuery.prop(this, 'elements');
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function () {
        var type = this.type;
        // Use .is(":disabled") so that fieldset[disabled] works
        return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !manipulation_rcheckableType.test(type));
      }).map(function (i, elem) {
        var val = jQuery(this).val();
        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
          return {
            name: elem.name,
            value: val.replace(rCRLF, '\r\n')
          };
        }) : {
          name: elem.name,
          value: val.replace(rCRLF, '\r\n')
        };
      }).get();
    }
  });
  //Serialize an array of form elements or a set of
  //key/values into a query string
  jQuery.param = function (a, traditional) {
    var prefix, s = [], add = function (key, value) {
        // If value is a function, invoke it and return its value
        value = jQuery.isFunction(value) ? value() : value == null ? '' : value;
        s[s.length] = encodeURIComponent(key) + '=' + encodeURIComponent(value);
      };
    // Set traditional to true for jQuery <= 1.3.2 behavior.
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }
    // If an array was passed in, assume that it is an array of form elements.
    if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
      // Serialize the form elements
      jQuery.each(a, function () {
        add(this.name, this.value);
      });
    } else {
      // If traditional, encode the "old" way (the way 1.3.2 or older
      // did it), otherwise encode params recursively.
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    // Return the resulting serialization
    return s.join('&').replace(r20, '+');
  };
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      // Serialize array item.
      jQuery.each(obj, function (i, v) {
        if (traditional || rbracket.test(prefix)) {
          // Treat each array item as a scalar.
          add(prefix, v);
        } else {
          // Item is non-scalar (array or object), encode its numeric index.
          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === 'object') {
      // Serialize object item.
      for (name in obj) {
        buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
      }
    } else {
      // Serialize scalar item.
      add(prefix, obj);
    }
  }
  jQuery.each(('blur focus focusin focusout load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup error contextmenu').split(' '), function (i, name) {
    // Handle event binding
    jQuery.fn[name] = function (data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({
    hover: function (fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    },
    bind: function (types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function (types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function (selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function (selector, types, fn) {
      // ( namespace ) or ( selector, types [, fn] )
      return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
    }
  });
  var
    // Document location
    ajaxLocParts, ajaxLocation, ajax_nonce = jQuery.now(), ajax_rquery = /\?/, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/gm,
    // IE leaves an \r character at EOL
    // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/([^\/?#:]*)(?::(\d+)|)|)/,
    // Keep a copy of the old load method
    _load = jQuery.fn.load,
    /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
    prefilters = {},
    /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
    transports = {},
    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = '*/'.concat('*');
  // #8138, IE may throw an exception when accessing
  // a field from window.location if document.domain has been set
  try {
    ajaxLocation = location.href;
  } catch (e) {
    // Use the href attribute of an A element
    // since IE will modify it given document.location
    ajaxLocation = document.createElement('a');
    ajaxLocation.href = '';
    ajaxLocation = ajaxLocation.href;
  }
  // Segment location into parts
  ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
  // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
  function addToPrefiltersOrTransports(structure) {
    // dataTypeExpression is optional and defaults to "*"
    return function (dataTypeExpression, func) {
      if (typeof dataTypeExpression !== 'string') {
        func = dataTypeExpression;
        dataTypeExpression = '*';
      }
      var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(core_rnotwhite) || [];
      if (jQuery.isFunction(func)) {
        // For each dataType in the dataTypeExpression
        while (dataType = dataTypes[i++]) {
          // Prepend if requested
          if (dataType[0] === '+') {
            dataType = dataType.slice(1) || '*';
            (structure[dataType] = structure[dataType] || []).unshift(func);  // Otherwise append
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  // Base inspection function for prefilters and transports
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {}, seekingTransport = structure === transports;
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
  }
  // A special extend for ajax options
  // that takes "flat" options (not to be deep extended)
  // Fixes #9887
  function ajaxExtend(target, src) {
    var deep, key, flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  jQuery.fn.load = function (url, params, callback) {
    if (typeof url !== 'string' && _load) {
      return _load.apply(this, arguments);
    }
    var selector, response, type, self = this, off = url.indexOf(' ');
    if (off >= 0) {
      selector = url.slice(off, url.length);
      url = url.slice(0, off);
    }
    // If it's a function
    if (jQuery.isFunction(params)) {
      // We assume that it's the callback
      callback = params;
      params = undefined;  // Otherwise, build a param string
    } else if (params && typeof params === 'object') {
      type = 'POST';
    }
    // If we have elements to modify, make the request
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type,
        dataType: 'html',
        data: params
      }).done(function (responseText) {
        // Save response for use in complete callback
        response = arguments;
        self.html(selector ? jQuery('<div>').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).complete(callback && function (jqXHR, status) {
        self.each(callback, response || [
          jqXHR.responseText,
          status,
          jqXHR
        ]);
      });
    }
    return this;
  };
  // Attach a bunch of functions for handling common AJAX events
  jQuery.each([
    'ajaxStart',
    'ajaxStop',
    'ajaxComplete',
    'ajaxError',
    'ajaxSuccess',
    'ajaxSend'
  ], function (i, type) {
    jQuery.fn[type] = function (fn) {
      return this.on(type, fn);
    };
  });
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: ajaxLocation,
      type: 'GET',
      isLocal: rlocalProtocol.test(ajaxLocParts[1]),
      global: true,
      processData: true,
      async: true,
      contentType: 'application/x-www-form-urlencoded; charset=UTF-8',
      accepts: {
        '*': allTypes,
        text: 'text/plain',
        html: 'text/html',
        xml: 'application/xml, text/xml',
        json: 'application/json, text/javascript'
      },
      contents: {
        xml: /xml/,
        html: /html/,
        json: /json/
      },
      responseFields: {
        xml: 'responseXML',
        text: 'responseText',
        json: 'responseJSON'
      },
      converters: {
        '* text': String,
        'text html': true,
        'text json': jQuery.parseJSON,
        'text xml': jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function (target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function (url, options) {
      // If url is an object, simulate pre-1.5 signature
      if (typeof url === 'object') {
        options = url;
        url = undefined;
      }
      // Force options to be an object
      options = options || {};
      var
        // Cross-domain detection vars
        parts,
        // Loop variable
        i,
        // URL without anti-cache param
        cacheURL,
        // Response headers as string
        responseHeadersString,
        // timeout handle
        timeoutTimer,
        // To know if global events are to be dispatched
        fireGlobals, transport,
        // Response headers
        responseHeaders,
        // Create the final options object
        s = jQuery.ajaxSetup({}, options),
        // Callbacks context
        callbackContext = s.context || s,
        // Context for global events is callbackContext if it is a DOM node or jQuery collection
        globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
        // Deferreds
        deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'),
        // Status-dependent callbacks
        statusCode = s.statusCode || {},
        // Headers (they are sent all at once)
        requestHeaders = {}, requestHeadersNames = {},
        // The jqXHR state
        state = 0,
        // Default abort message
        strAbort = 'canceled',
        // Fake xhr
        jqXHR = {
          readyState: 0,
          getResponseHeader: function (key) {
            var match;
            if (state === 2) {
              if (!responseHeaders) {
                responseHeaders = {};
                while (match = rheaders.exec(responseHeadersString)) {
                  responseHeaders[match[1].toLowerCase()] = match[2];
                }
              }
              match = responseHeaders[key.toLowerCase()];
            }
            return match == null ? null : match;
          },
          getAllResponseHeaders: function () {
            return state === 2 ? responseHeadersString : null;
          },
          setRequestHeader: function (name, value) {
            var lname = name.toLowerCase();
            if (!state) {
              name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
              requestHeaders[name] = value;
            }
            return this;
          },
          overrideMimeType: function (type) {
            if (!state) {
              s.mimeType = type;
            }
            return this;
          },
          statusCode: function (map) {
            var code;
            if (map) {
              if (state < 2) {
                for (code in map) {
                  // Lazy-add the new callback in a way that preserves old ones
                  statusCode[code] = [
                    statusCode[code],
                    map[code]
                  ];
                }
              } else {
                // Execute the appropriate callbacks
                jqXHR.always(map[jqXHR.status]);
              }
            }
            return this;
          },
          abort: function (statusText) {
            var finalText = statusText || strAbort;
            if (transport) {
              transport.abort(finalText);
            }
            done(0, finalText);
            return this;
          }
        };
      // Attach deferreds
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;
      // Remove hash character (#7531: and string promotion)
      // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)
      // Handle falsy url in the settings object (#10093: consistency with old signature)
      // We also use the url parameter if available
      s.url = ((url || s.url || ajaxLocation) + '').replace(rhash, '').replace(rprotocol, ajaxLocParts[1] + '//');
      // Alias method option to type as per ticket #12004
      s.type = options.method || options.type || s.method || s.type;
      // Extract dataTypes list
      s.dataTypes = jQuery.trim(s.dataType || '*').toLowerCase().match(core_rnotwhite) || [''];
      // A cross-domain request is in order when we have a protocol:host:port mismatch
      if (s.crossDomain == null) {
        parts = rurl.exec(s.url.toLowerCase());
        s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !== (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443'))));
      }
      // Convert data if not already a string
      if (s.data && s.processData && typeof s.data !== 'string') {
        s.data = jQuery.param(s.data, s.traditional);
      }
      // Apply prefilters
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      // If request was aborted inside a prefilter, stop there
      if (state === 2) {
        return jqXHR;
      }
      // We can fire global events as of now if asked to
      fireGlobals = s.global;
      // Watch for a new set of requests
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger('ajaxStart');
      }
      // Uppercase the type
      s.type = s.type.toUpperCase();
      // Determine if request has content
      s.hasContent = !rnoContent.test(s.type);
      // Save the URL in case we're toying with the If-Modified-Since
      // and/or If-None-Match header later on
      cacheURL = s.url;
      // More options handling for requests with no content
      if (!s.hasContent) {
        // If data is available, append data to url
        if (s.data) {
          cacheURL = s.url += (ajax_rquery.test(cacheURL) ? '&' : '?') + s.data;
          // #9682: remove data so that it's not used in an eventual retry
          delete s.data;
        }
        // Add anti-cache in url if needed
        if (s.cache === false) {
          s.url = rts.test(cacheURL) ? cacheURL.replace(rts, '$1_=' + ajax_nonce++) : cacheURL + (ajax_rquery.test(cacheURL) ? '&' : '?') + '_=' + ajax_nonce++;
        }
      }
      // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
        }
      }
      // Set the correct header, if data is being sent
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader('Content-Type', s.contentType);
      }
      // Set the Accepts header for the server, depending on the dataType
      jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q=0.01' : '') : s.accepts['*']);
      // Check for headers option
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      // Allow custom headers/mimetypes and early abort
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        // Abort if not done already and return
        return jqXHR.abort();
      }
      // aborting is no longer a cancellation
      strAbort = 'abort';
      // Install callbacks on deferreds
      for (i in {
          success: 1,
          error: 1,
          complete: 1
        }) {
        jqXHR[i](s[i]);
      }
      // Get transport
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      // If no transport, we auto-abort
      if (!transport) {
        done(-1, 'No Transport');
      } else {
        jqXHR.readyState = 1;
        // Send global event
        if (fireGlobals) {
          globalEventContext.trigger('ajaxSend', [
            jqXHR,
            s
          ]);
        }
        // Timeout
        if (s.async && s.timeout > 0) {
          timeoutTimer = setTimeout(function () {
            jqXHR.abort('timeout');
          }, s.timeout);
        }
        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          // Propagate exception as error if not done
          if (state < 2) {
            done(-1, e);  // Simply rethrow otherwise
          } else {
            throw e;
          }
        }
      }
      // Callback for when everything is done
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess, success, error, response, modified, statusText = nativeStatusText;
        // Called once
        if (state === 2) {
          return;
        }
        // State is "done" now
        state = 2;
        // Clear timeout if it exists
        if (timeoutTimer) {
          clearTimeout(timeoutTimer);
        }
        // Dereference transport for early garbage collection
        // (no matter how long the jqXHR object will be used)
        transport = undefined;
        // Cache response headers
        responseHeadersString = headers || '';
        // Set readyState
        jqXHR.readyState = status > 0 ? 4 : 0;
        // Determine if successful
        isSuccess = status >= 200 && status < 300 || status === 304;
        // Get response data
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        // Convert no matter what (that way responseXXX fields are always set)
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        // If successful, handle type chaining
        if (isSuccess) {
          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader('Last-Modified');
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader('etag');
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          // if no content
          if (status === 204 || s.type === 'HEAD') {
            statusText = 'nocontent';  // if not modified
          } else if (status === 304) {
            statusText = 'notmodified';  // If we have data, let's convert it
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          // We extract error from statusText
          // then normalize statusText and status for non-aborts
          error = statusText;
          if (status || !statusText) {
            statusText = 'error';
            if (status < 0) {
              status = 0;
            }
          }
        }
        // Set data for the fake xhr object
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + '';
        // Success/Error
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [
            success,
            statusText,
            jqXHR
          ]);
        } else {
          deferred.rejectWith(callbackContext, [
            jqXHR,
            statusText,
            error
          ]);
        }
        // Status-dependent callbacks
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [
            jqXHR,
            s,
            isSuccess ? success : error
          ]);
        }
        // Complete
        completeDeferred.fireWith(callbackContext, [
          jqXHR,
          statusText
        ]);
        if (fireGlobals) {
          globalEventContext.trigger('ajaxComplete', [
            jqXHR,
            s
          ]);
          // Handle the global AJAX counter
          if (!--jQuery.active) {
            jQuery.event.trigger('ajaxStop');
          }
        }
      }
      return jqXHR;
    },
    getJSON: function (url, data, callback) {
      return jQuery.get(url, data, callback, 'json');
    },
    getScript: function (url, callback) {
      return jQuery.get(url, undefined, callback, 'script');
    }
  });
  jQuery.each([
    'get',
    'post'
  ], function (i, method) {
    jQuery[method] = function (url, data, callback, type) {
      // shift arguments if data argument was omitted
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      });
    };
  });
  /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
  function ajaxHandleResponses(s, jqXHR, responses) {
    var firstDataType, ct, finalDataType, type, contents = s.contents, dataTypes = s.dataTypes;
    // Remove auto dataType and get content-type in the process
    while (dataTypes[0] === '*') {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
      }
    }
    // Check if we're dealing with a known content-type
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    // Check to see if we have a response for the expected dataType
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      // Try convertible dataTypes
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      // Or just use first one
      finalDataType = finalDataType || firstDataType;
    }
    // If we found a dataType
    // We add the dataType to the list if needed
    // and return the corresponding response
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2, current, conv, tmp, prev, converters = {},
      // Work with a copy of dataTypes in case we need to modify it for conversion
      dataTypes = s.dataTypes.slice();
    // Create converters map with lowercased keys
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    // Convert to each sequential dataType
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      // Apply the dataFilter if provided
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        // There's only work to do if current dataType is non-auto
        if (current === '*') {
          current = prev;  // Convert response if prev dataType is non-auto and differs from current
        } else if (prev !== '*' && prev !== current) {
          // Seek a direct converter
          conv = converters[prev + ' ' + current] || converters['* ' + current];
          // If none found, seek a pair
          if (!conv) {
            for (conv2 in converters) {
              // If conv2 outputs current
              tmp = conv2.split(' ');
              if (tmp[1] === current) {
                // If prev can be converted to accepted input
                conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                if (conv) {
                  // Condense equivalence converters
                  if (conv === true) {
                    conv = converters[conv2];  // Otherwise, insert the intermediate dataType
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          // Apply converter (if not an equivalence)
          if (conv !== true) {
            // Unless errors are allowed to bubble, catch and return them
            if (conv && s['throws']) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: 'parsererror',
                  error: conv ? e : 'No conversion from ' + prev + ' to ' + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: 'success',
      data: response
    };
  }
  // Install script dataType
  jQuery.ajaxSetup({
    accepts: { script: 'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript' },
    contents: { script: /(?:java|ecma)script/ },
    converters: {
      'text script': function (text) {
        jQuery.globalEval(text);
        return text;
      }
    }
  });
  // Handle cache's special case and global
  jQuery.ajaxPrefilter('script', function (s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = 'GET';
      s.global = false;
    }
  });
  // Bind script tag hack transport
  jQuery.ajaxTransport('script', function (s) {
    // This transport only deals with cross domain requests
    if (s.crossDomain) {
      var script, head = document.head || jQuery('head')[0] || document.documentElement;
      return {
        send: function (_, callback) {
          script = document.createElement('script');
          script.async = true;
          if (s.scriptCharset) {
            script.charset = s.scriptCharset;
          }
          script.src = s.url;
          // Attach handlers for all browsers
          script.onload = script.onreadystatechange = function (_, isAbort) {
            if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
              // Handle memory leak in IE
              script.onload = script.onreadystatechange = null;
              // Remove the script
              if (script.parentNode) {
                script.parentNode.removeChild(script);
              }
              // Dereference the script
              script = null;
              // Callback if not abort
              if (!isAbort) {
                callback(200, 'success');
              }
            }
          };
          // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending
          // Use native DOM manipulation to avoid our domManip AJAX trickery
          head.insertBefore(script, head.firstChild);
        },
        abort: function () {
          if (script) {
            script.onload(undefined, true);
          }
        }
      };
    }
  });
  var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
  // Default jsonp settings
  jQuery.ajaxSetup({
    jsonp: 'callback',
    jsonpCallback: function () {
      var callback = oldCallbacks.pop() || jQuery.expando + '_' + ajax_nonce++;
      this[callback] = true;
      return callback;
    }
  });
  // Detect, normalize options and install callbacks for jsonp requests
  jQuery.ajaxPrefilter('json jsonp', function (s, originalSettings, jqXHR) {
    var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && !(s.contentType || '').indexOf('application/x-www-form-urlencoded') && rjsonp.test(s.data) && 'data');
    // Handle iff the expected data type is "jsonp" or we have a parameter to set
    if (jsonProp || s.dataTypes[0] === 'jsonp') {
      // Get callback name, remembering preexisting value associated with it
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      // Insert callback into url or form data
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (ajax_rquery.test(s.url) ? '&' : '?') + s.jsonp + '=' + callbackName;
      }
      // Use data converter to retrieve json after script execution
      s.converters['script json'] = function () {
        if (!responseContainer) {
          jQuery.error(callbackName + ' was not called');
        }
        return responseContainer[0];
      };
      // force json dataType
      s.dataTypes[0] = 'json';
      // Install callback
      overwritten = window[callbackName];
      window[callbackName] = function () {
        responseContainer = arguments;
      };
      // Clean-up function (fires after converters)
      jqXHR.always(function () {
        // Restore preexisting value
        window[callbackName] = overwritten;
        // Save back as free
        if (s[callbackName]) {
          // make sure that re-using the options doesn't screw things around
          s.jsonpCallback = originalSettings.jsonpCallback;
          // save the callback name for future use
          oldCallbacks.push(callbackName);
        }
        // Call if it was a function and we have a response
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      // Delegate to script
      return 'script';
    }
  });
  var xhrCallbacks, xhrSupported, xhrId = 0,
    // #5280: Internet Explorer will keep connections alive if we don't abort on unload
    xhrOnUnloadAbort = window.ActiveXObject && function () {
      // Abort all pending requests
      var key;
      for (key in xhrCallbacks) {
        xhrCallbacks[key](undefined, true);
      }
    };
  // Functions to create xhrs
  function createStandardXHR() {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {
    }
  }
  function createActiveXHR() {
    try {
      return new window.ActiveXObject('Microsoft.XMLHTTP');
    } catch (e) {
    }
  }
  // Create the request object
  // (This is still attached to ajaxSettings for backward compatibility)
  jQuery.ajaxSettings.xhr = window.ActiveXObject ? function () {
    return !this.isLocal && createStandardXHR() || createActiveXHR();
  } : createStandardXHR;
  // Determine support properties
  xhrSupported = jQuery.ajaxSettings.xhr();
  jQuery.support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
  xhrSupported = jQuery.support.ajax = !!xhrSupported;
  // Create transport if the browser can provide an xhr
  if (xhrSupported) {
    jQuery.ajaxTransport(function (s) {
      // Cross domain only allowed if supported through XMLHttpRequest
      if (!s.crossDomain || jQuery.support.cors) {
        var callback;
        return {
          send: function (headers, complete) {
            // Get a new xhr
            var handle, i, xhr = s.xhr();
            // Open the socket
            // Passing null username, generates a login popup on Opera (#2865)
            if (s.username) {
              xhr.open(s.type, s.url, s.async, s.username, s.password);
            } else {
              xhr.open(s.type, s.url, s.async);
            }
            // Apply custom fields if provided
            if (s.xhrFields) {
              for (i in s.xhrFields) {
                xhr[i] = s.xhrFields[i];
              }
            }
            // Override mime type if needed
            if (s.mimeType && xhr.overrideMimeType) {
              xhr.overrideMimeType(s.mimeType);
            }
            // X-Requested-With header
            // For cross-domain requests, seeing as conditions for a preflight are
            // akin to a jigsaw puzzle, we simply never set it to be sure.
            // (it can always be set on a per-request basis or even using ajaxSetup)
            // For same-domain requests, won't change header if already provided.
            if (!s.crossDomain && !headers['X-Requested-With']) {
              headers['X-Requested-With'] = 'XMLHttpRequest';
            }
            // Need an extra try/catch for cross domain requests in Firefox 3
            try {
              for (i in headers) {
                xhr.setRequestHeader(i, headers[i]);
              }
            } catch (err) {
            }
            // Do send the request
            // This may raise an exception which is actually
            // handled in jQuery.ajax (so no try/catch here)
            xhr.send(s.hasContent && s.data || null);
            // Listener
            callback = function (_, isAbort) {
              var status, responseHeaders, statusText, responses;
              // Firefox throws exceptions when accessing properties
              // of an xhr when a network error occurred
              // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)
              try {
                // Was never called and is aborted or complete
                if (callback && (isAbort || xhr.readyState === 4)) {
                  // Only called once
                  callback = undefined;
                  // Do not keep as active anymore
                  if (handle) {
                    xhr.onreadystatechange = jQuery.noop;
                    if (xhrOnUnloadAbort) {
                      delete xhrCallbacks[handle];
                    }
                  }
                  // If it's an abort
                  if (isAbort) {
                    // Abort it manually if needed
                    if (xhr.readyState !== 4) {
                      xhr.abort();
                    }
                  } else {
                    responses = {};
                    status = xhr.status;
                    responseHeaders = xhr.getAllResponseHeaders();
                    // When requesting binary data, IE6-9 will throw an exception
                    // on any attempt to access responseText (#11426)
                    if (typeof xhr.responseText === 'string') {
                      responses.text = xhr.responseText;
                    }
                    // Firefox throws an exception when accessing
                    // statusText for faulty cross-domain requests
                    try {
                      statusText = xhr.statusText;
                    } catch (e) {
                      // We normalize with Webkit giving an empty statusText
                      statusText = '';
                    }
                    // Filter status for non standard behaviors
                    // If the request is local and we have data: assume a success
                    // (success with no data won't get notified, that's the best we
                    // can do given current implementations)
                    if (!status && s.isLocal && !s.crossDomain) {
                      status = responses.text ? 200 : 404;  // IE - #1450: sometimes returns 1223 when it should be 204
                    } else if (status === 1223) {
                      status = 204;
                    }
                  }
                }
              } catch (firefoxAccessException) {
                if (!isAbort) {
                  complete(-1, firefoxAccessException);
                }
              }
              // Call complete if needed
              if (responses) {
                complete(status, statusText, responses, responseHeaders);
              }
            };
            if (!s.async) {
              // if we're in sync mode we fire the callback
              callback();
            } else if (xhr.readyState === 4) {
              // (IE6 & IE7) if it's in cache and has been
              // retrieved directly we need to fire the callback
              setTimeout(callback);
            } else {
              handle = ++xhrId;
              if (xhrOnUnloadAbort) {
                // Create the active xhrs callbacks list if needed
                // and attach the unload handler
                if (!xhrCallbacks) {
                  xhrCallbacks = {};
                  jQuery(window).unload(xhrOnUnloadAbort);
                }
                // Add to list of active xhrs callbacks
                xhrCallbacks[handle] = callback;
              }
              xhr.onreadystatechange = callback;
            }
          },
          abort: function () {
            if (callback) {
              callback(undefined, true);
            }
          }
        };
      }
    });
  }
  var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp('^(?:([+-])=|)(' + core_pnum + ')([a-z%]*)$', 'i'), rrun = /queueHooks$/, animationPrefilters = [defaultPrefilter], tweeners = {
      '*': [function (prop, value) {
          var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? '' : 'px'),
            // Starting value computation is required for potential unit mismatches
            start = (jQuery.cssNumber[prop] || unit !== 'px' && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
          if (start && start[3] !== unit) {
            // Trust units reported by jQuery.css
            unit = unit || start[3];
            // Make sure we update the tween properties later on
            parts = parts || [];
            // Iteratively approximate from a nonzero starting point
            start = +target || 1;
            do {
              // If previous iteration zeroed out, double until we get *something*
              // Use a string for doubling factor so we don't accidentally see scale as unchanged below
              scale = scale || '.5';
              // Adjust and apply
              start = start / scale;
              jQuery.style(tween.elem, prop, start + unit);  // Update scale, tolerating zero or NaN from tween.cur()
                                                             // And breaking the loop if scale is unchanged or perfect, or if we've just had enough
            } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
          }
          // Update tween properties
          if (parts) {
            start = tween.start = +start || +target || 0;
            tween.unit = unit;
            // If a +=/-= token was provided, we're doing a relative animation
            tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
          }
          return tween;
        }]
    };
  // Animations created synchronously will run synchronously
  function createFxNow() {
    setTimeout(function () {
      fxNow = undefined;
    });
    return fxNow = jQuery.now();
  }
  function createTween(value, prop, animation) {
    var tween, collection = (tweeners[prop] || []).concat(tweeners['*']), index = 0, length = collection.length;
    for (; index < length; index++) {
      if (tween = collection[index].call(animation, prop, value)) {
        // we're done with this property
        return tween;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function () {
        // don't match elem in the :animated selector
        delete tick.elem;
      }), tick = function () {
        if (stopped) {
          return false;
        }
        var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
          // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)
          temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
        for (; index < length; index++) {
          animation.tweens[index].run(percent);
        }
        deferred.notifyWith(elem, [
          animation,
          percent,
          remaining
        ]);
        if (percent < 1 && length) {
          return remaining;
        } else {
          deferred.resolveWith(elem, [animation]);
          return false;
        }
      }, animation = deferred.promise({
        elem: elem,
        props: jQuery.extend({}, properties),
        opts: jQuery.extend(true, { specialEasing: {} }, options),
        originalProperties: properties,
        originalOptions: options,
        startTime: fxNow || createFxNow(),
        duration: options.duration,
        tweens: [],
        createTween: function (prop, end) {
          var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
          animation.tweens.push(tween);
          return tween;
        },
        stop: function (gotoEnd) {
          var index = 0,
            // if we are going to the end, we want to run all the tweens
            // otherwise we skip this part
            length = gotoEnd ? animation.tweens.length : 0;
          if (stopped) {
            return this;
          }
          stopped = true;
          for (; index < length; index++) {
            animation.tweens[index].run(1);
          }
          // resolve when we played the last frame
          // otherwise, reject
          if (gotoEnd) {
            deferred.resolveWith(elem, [
              animation,
              gotoEnd
            ]);
          } else {
            deferred.rejectWith(elem, [
              animation,
              gotoEnd
            ]);
          }
          return this;
        }
      }), props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = animationPrefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    // attach callbacks from options
    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }
  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks;
    // camelCase, specialEasing and expand cssHook pass
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && 'expand' in hooks) {
        value = hooks.expand(value);
        delete props[name];
        // not quite $.extend, this wont overwrite keys already present.
        // also - reusing 'index' from above because we have the correct "name"
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweener: function (props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ['*'];
      } else {
        props = props.split(' ');
      }
      var prop, index = 0, length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        tweeners[prop] = tweeners[prop] || [];
        tweeners[prop].unshift(callback);
      }
    },
    prefilter: function (callback, prepend) {
      if (prepend) {
        animationPrefilters.unshift(callback);
      } else {
        animationPrefilters.push(callback);
      }
    }
  });
  function defaultPrefilter(elem, props, opts) {
    /* jshint validthis: true */
    var prop, value, toggle, tween, hooks, oldfire, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = jQuery._data(elem, 'fxshow');
    // handle queue: false promises
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, 'fx');
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function () {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function () {
        // doing this makes sure that the complete handler will be called
        // before this completes
        anim.always(function () {
          hooks.unqueued--;
          if (!jQuery.queue(elem, 'fx').length) {
            hooks.empty.fire();
          }
        });
      });
    }
    // height/width overflow pass
    if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
      // Make sure that nothing sneaks out
      // Record all 3 overflow attributes because IE does not
      // change the overflow attribute when overflowX and
      // overflowY are set to the same value
      opts.overflow = [
        style.overflow,
        style.overflowX,
        style.overflowY
      ];
      // Set display property to inline-block for height/width
      // animations on inline elements that are having width/height animated
      if (jQuery.css(elem, 'display') === 'inline' && jQuery.css(elem, 'float') === 'none') {
        // inline-level elements accept inline-block;
        // block-level elements need to be inline with layout
        if (!jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay(elem.nodeName) === 'inline') {
          style.display = 'inline-block';
        } else {
          style.zoom = 1;
        }
      }
    }
    if (opts.overflow) {
      style.overflow = 'hidden';
      if (!jQuery.support.shrinkWrapBlocks) {
        anim.always(function () {
          style.overflow = opts.overflow[0];
          style.overflowX = opts.overflow[1];
          style.overflowY = opts.overflow[2];
        });
      }
    }
    // show/hide pass
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === 'toggle';
        if (value === (hidden ? 'hide' : 'show')) {
          continue;
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      }
    }
    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ('hidden' in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = jQuery._data(elem, 'fxshow', {});
      }
      // store state if its toggle - enables .stop().toggle() to "reverse"
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function () {
          jQuery(elem).hide();
        });
      }
      anim.done(function () {
        var prop;
        jQuery._removeData(elem, 'fxshow');
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
          }
        }
      }
    }
  }
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function (elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || 'swing';
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
    },
    cur: function () {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function (percent) {
      var eased, hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {
    _default: {
      get: function (tween) {
        var result;
        if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
          return tween.elem[tween.prop];
        }
        // passing an empty string as a 3rd parameter to .css will automatically
        // attempt a parseFloat and fallback to a string if the parse fails
        // so, simple values such as "10px" are parsed to Float.
        // complex values such as "rotate(1rad)" are returned as is.
        result = jQuery.css(tween.elem, tween.prop, '');
        // Empty strings, null, undefined and "auto" are converted to 0.
        return !result || result === 'auto' ? 0 : result;
      },
      set: function (tween) {
        // use step hook for back compat - use cssHook if its there - use .style if its
        // available and use plain properties where available
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }
  };
  // Support: IE <=9
  // Panic based approach to setting things on disconnected nodes
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
    set: function (tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }
  };
  jQuery.each([
    'toggle',
    'show',
    'hide'
  ], function (i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function (speed, easing, callback) {
      return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.fn.extend({
    fadeTo: function (speed, to, easing, callback) {
      // show any hidden elements after setting opacity to 0
      return this.filter(isHidden).css('opacity', 0).show().end().animate({ opacity: to }, speed, easing, callback);
    },
    animate: function (prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
          // Operate on a copy of prop so per-property easing won't be lost
          var anim = Animation(this, jQuery.extend({}, prop), optall);
          // Empty animations, or finishing resolves immediately
          if (empty || jQuery._data(this, 'finish')) {
            anim.stop(true);
          }
        };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function (type, clearQueue, gotoEnd) {
      var stopQueue = function (hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== 'string') {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || 'fx', []);
      }
      return this.each(function () {
        var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = jQuery._data(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        // start the next in the queue if the last step wasn't forced
        // timers currently will call their complete callbacks, which will dequeue
        // but only if they were gotoEnd
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function (type) {
      if (type !== false) {
        type = type || 'fx';
      }
      return this.each(function () {
        var index, data = jQuery._data(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
        // enable finishing flag on private data
        data.finish = true;
        // empty the queue first
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        // look for any active animations, and finish them
        for (index = timers.length; index--;) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        // look for any animations in the old queue and finish them
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        // turn off finishing flag
        delete data.finish;
      });
    }
  });
  // Generate parameters to create a standard animation
  function genFx(type, includeWidth) {
    var which, attrs = { height: type }, i = 0;
    // if we include width, step value is 1 to do all cssExpand values,
    // if we don't include width, step value is 2 to skip over Left and Right
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs['margin' + which] = attrs['padding' + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  // Generate shortcuts for custom animations
  jQuery.each({
    slideDown: genFx('show'),
    slideUp: genFx('hide'),
    slideToggle: genFx('toggle'),
    fadeIn: { opacity: 'show' },
    fadeOut: { opacity: 'hide' },
    fadeToggle: { opacity: 'toggle' }
  }, function (name, props) {
    jQuery.fn[name] = function (speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.speed = function (speed, easing, fn) {
    var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {
        complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
        duration: speed,
        easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
      };
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === 'number' ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
    // normalize opt.queue - true/undefined/null -> "fx"
    if (opt.queue == null || opt.queue === true) {
      opt.queue = 'fx';
    }
    // Queueing
    opt.old = opt.complete;
    opt.complete = function () {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.easing = {
    linear: function (p) {
      return p;
    },
    swing: function (p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    }
  };
  jQuery.timers = [];
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.tick = function () {
    var timer, timers = jQuery.timers, i = 0;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      // Checks the timer has not already been removed
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function (timer) {
    if (timer() && jQuery.timers.push(timer)) {
      jQuery.fx.start();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function () {
    if (!timerId) {
      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function () {
    clearInterval(timerId);
    timerId = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  // Back Compat <1.8 extension point
  jQuery.fx.step = {};
  if (jQuery.expr && jQuery.expr.filters) {
    jQuery.expr.filters.animated = function (elem) {
      return jQuery.grep(jQuery.timers, function (fn) {
        return elem === fn.elem;
      }).length;
    };
  }
  jQuery.fn.offset = function (options) {
    if (arguments.length) {
      return options === undefined ? this : this.each(function (i) {
        jQuery.offset.setOffset(this, options, i);
      });
    }
    var docElem, win, box = {
        top: 0,
        left: 0
      }, elem = this[0], doc = elem && elem.ownerDocument;
    if (!doc) {
      return;
    }
    docElem = doc.documentElement;
    // Make sure it's not a disconnected DOM node
    if (!jQuery.contains(docElem, elem)) {
      return box;
    }
    // If we don't have gBCR, just use 0,0 rather than error
    // BlackBerry 5, iOS 3 (original iPhone)
    if (typeof elem.getBoundingClientRect !== core_strundefined) {
      box = elem.getBoundingClientRect();
    }
    win = getWindow(doc);
    return {
      top: box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0),
      left: box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)
    };
  };
  jQuery.offset = {
    setOffset: function (elem, options, i) {
      var position = jQuery.css(elem, 'position');
      // set position first, in-case top/left are set even on static elem
      if (position === 'static') {
        elem.style.position = 'relative';
      }
      var curElem = jQuery(elem), curOffset = curElem.offset(), curCSSTop = jQuery.css(elem, 'top'), curCSSLeft = jQuery.css(elem, 'left'), calculatePosition = (position === 'absolute' || position === 'fixed') && jQuery.inArray('auto', [
          curCSSTop,
          curCSSLeft
        ]) > -1, props = {}, curPosition = {}, curTop, curLeft;
      // need to be able to calculate position if either top or left is auto and position is either absolute or fixed
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, curOffset);
      }
      if (options.top != null) {
        props.top = options.top - curOffset.top + curTop;
      }
      if (options.left != null) {
        props.left = options.left - curOffset.left + curLeft;
      }
      if ('using' in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }
  };
  jQuery.fn.extend({
    position: function () {
      if (!this[0]) {
        return;
      }
      var offsetParent, offset, parentOffset = {
          top: 0,
          left: 0
        }, elem = this[0];
      // fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent
      if (jQuery.css(elem, 'position') === 'fixed') {
        // we assume that getBoundingClientRect is available when computed position is fixed
        offset = elem.getBoundingClientRect();
      } else {
        // Get *real* offsetParent
        offsetParent = this.offsetParent();
        // Get correct offsets
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], 'html')) {
          parentOffset = offsetParent.offset();
        }
        // Add offsetParent borders
        parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true);
        parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true);
      }
      // Subtract parent offsets and element margins
      // note: when an element has margin: auto the offsetLeft and marginLeft
      // are the same in Safari causing offset.left to incorrectly be 0
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true),
        left: offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)
      };
    },
    offsetParent: function () {
      return this.map(function () {
        var offsetParent = this.offsetParent || docElem;
        while (offsetParent && (!jQuery.nodeName(offsetParent, 'html') && jQuery.css(offsetParent, 'position') === 'static')) {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || docElem;
      });
    }
  });
  // Create scrollLeft and scrollTop methods
  jQuery.each({
    scrollLeft: 'pageXOffset',
    scrollTop: 'pageYOffset'
  }, function (method, prop) {
    var top = /Y/.test(prop);
    jQuery.fn[method] = function (val) {
      return jQuery.access(this, function (elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? prop in win ? win[prop] : win.document.documentElement[method] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : jQuery(win).scrollLeft(), top ? val : jQuery(win).scrollTop());
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length, null);
    };
  });
  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;
  }
  // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
  jQuery.each({
    Height: 'height',
    Width: 'width'
  }, function (name, type) {
    jQuery.each({
      padding: 'inner' + name,
      content: type,
      '': 'outer' + name
    }, function (defaultExtra, funcName) {
      // margin is only for outerHeight, outerWidth
      jQuery.fn[funcName] = function (margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
        return jQuery.access(this, function (elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
            // isn't a whole lot we can do. See pull request at this URL for discussion:
            // https://github.com/jquery/jquery/pull/764
            return elem.document.documentElement['client' + name];
          }
          // Get document width or height
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest
            // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.
            return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  });
  // Limit scope pollution from any deprecated API
  // (function() {
  // The number of elements contained in the matched element set
  jQuery.fn.size = function () {
    return this.length;
  };
  jQuery.fn.andSelf = jQuery.fn.addBack;
  // })();
  if (typeof module === 'object' && module && typeof module.exports === 'object') {
    // Expose jQuery as module.exports in loaders that implement the Node
    // module pattern (including browserify). Do not create the global, since
    // the user will be storing it themselves locally, and globals are frowned
    // upon in the Node module world.
    module.exports = jQuery;
  } else {
    // Otherwise expose jQuery to the global object as usual
    window.jQuery = window.$ = jQuery;
    // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.
    if (typeof define === 'function' && define.amd) {
      define('jquery', [], function () {
        return jQuery;
      });
    }
  }
}(window));
/*! jQuery UI - v1.10.3 - 2013-05-03
* http://jqueryui.com
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.sortable.js, jquery.ui.effect.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.effect-blind.js, jquery.ui.effect-bounce.js, jquery.ui.effect-clip.js, jquery.ui.effect-drop.js, jquery.ui.effect-explode.js, jquery.ui.effect-fade.js, jquery.ui.effect-fold.js, jquery.ui.effect-highlight.js, jquery.ui.effect-pulsate.js, jquery.ui.effect-scale.js, jquery.ui.effect-shake.js, jquery.ui.effect-slide.js, jquery.ui.effect-transfer.js, jquery.ui.menu.js, jquery.ui.position.js, jquery.ui.progressbar.js, jquery.ui.slider.js, jquery.ui.spinner.js, jquery.ui.tabs.js, jquery.ui.tooltip.js
* Copyright 2013 jQuery Foundation and other contributors; Licensed MIT */
(function ($, undefined) {
  var uuid = 0, runiqueId = /^ui-id-\d+$/;
  // $.ui might exist from components with no dependencies, e.g., $.ui.position
  $.ui = $.ui || {};
  $.extend($.ui, {
    version: '1.10.3',
    keyCode: {
      BACKSPACE: 8,
      COMMA: 188,
      DELETE: 46,
      DOWN: 40,
      END: 35,
      ENTER: 13,
      ESCAPE: 27,
      HOME: 36,
      LEFT: 37,
      NUMPAD_ADD: 107,
      NUMPAD_DECIMAL: 110,
      NUMPAD_DIVIDE: 111,
      NUMPAD_ENTER: 108,
      NUMPAD_MULTIPLY: 106,
      NUMPAD_SUBTRACT: 109,
      PAGE_DOWN: 34,
      PAGE_UP: 33,
      PERIOD: 190,
      RIGHT: 39,
      SPACE: 32,
      TAB: 9,
      UP: 38
    }
  });
  // plugins
  $.fn.extend({
    focus: function (orig) {
      return function (delay, fn) {
        return typeof delay === 'number' ? this.each(function () {
          var elem = this;
          setTimeout(function () {
            $(elem).focus();
            if (fn) {
              fn.call(elem);
            }
          }, delay);
        }) : orig.apply(this, arguments);
      };
    }($.fn.focus),
    scrollParent: function () {
      var scrollParent;
      if ($.ui.ie && /(static|relative)/.test(this.css('position')) || /absolute/.test(this.css('position'))) {
        scrollParent = this.parents().filter(function () {
          return /(relative|absolute|fixed)/.test($.css(this, 'position')) && /(auto|scroll)/.test($.css(this, 'overflow') + $.css(this, 'overflow-y') + $.css(this, 'overflow-x'));
        }).eq(0);
      } else {
        scrollParent = this.parents().filter(function () {
          return /(auto|scroll)/.test($.css(this, 'overflow') + $.css(this, 'overflow-y') + $.css(this, 'overflow-x'));
        }).eq(0);
      }
      return /fixed/.test(this.css('position')) || !scrollParent.length ? $(document) : scrollParent;
    },
    zIndex: function (zIndex) {
      if (zIndex !== undefined) {
        return this.css('zIndex', zIndex);
      }
      if (this.length) {
        var elem = $(this[0]), position, value;
        while (elem.length && elem[0] !== document) {
          // Ignore z-index if position is set to a value where z-index is ignored by the browser
          // This makes behavior of this function consistent across browsers
          // WebKit always returns auto if the element is positioned
          position = elem.css('position');
          if (position === 'absolute' || position === 'relative' || position === 'fixed') {
            // IE returns 0 when zIndex is not specified
            // other browsers return a string
            // we ignore the case of nested elements with an explicit value of 0
            // <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
            value = parseInt(elem.css('zIndex'), 10);
            if (!isNaN(value) && value !== 0) {
              return value;
            }
          }
          elem = elem.parent();
        }
      }
      return 0;
    },
    uniqueId: function () {
      return this.each(function () {
        if (!this.id) {
          this.id = 'ui-id-' + ++uuid;
        }
      });
    },
    removeUniqueId: function () {
      return this.each(function () {
        if (runiqueId.test(this.id)) {
          $(this).removeAttr('id');
        }
      });
    }
  });
  // selectors
  function focusable(element, isTabIndexNotNaN) {
    var map, mapName, img, nodeName = element.nodeName.toLowerCase();
    if ('area' === nodeName) {
      map = element.parentNode;
      mapName = map.name;
      if (!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {
        return false;
      }
      img = $('img[usemap=#' + mapName + ']')[0];
      return !!img && visible(img);
    }
    return (/input|select|textarea|button|object/.test(nodeName) ? !element.disabled : 'a' === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && visible(element);
  }
  function visible(element) {
    return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function () {
      return $.css(this, 'visibility') === 'hidden';
    }).length;
  }
  $.extend($.expr[':'], {
    data: $.expr.createPseudo ? $.expr.createPseudo(function (dataName) {
      return function (elem) {
        return !!$.data(elem, dataName);
      };
    }) : function (elem, i, match) {
      return !!$.data(elem, match[3]);
    },
    focusable: function (element) {
      return focusable(element, !isNaN($.attr(element, 'tabindex')));
    },
    tabbable: function (element) {
      var tabIndex = $.attr(element, 'tabindex'), isTabIndexNaN = isNaN(tabIndex);
      return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
    }
  });
  // support: jQuery <1.8
  if (!$('<a>').outerWidth(1).jquery) {
    $.each([
      'Width',
      'Height'
    ], function (i, name) {
      var side = name === 'Width' ? [
          'Left',
          'Right'
        ] : [
          'Top',
          'Bottom'
        ], type = name.toLowerCase(), orig = {
          innerWidth: $.fn.innerWidth,
          innerHeight: $.fn.innerHeight,
          outerWidth: $.fn.outerWidth,
          outerHeight: $.fn.outerHeight
        };
      function reduce(elem, size, border, margin) {
        $.each(side, function () {
          size -= parseFloat($.css(elem, 'padding' + this)) || 0;
          if (border) {
            size -= parseFloat($.css(elem, 'border' + this + 'Width')) || 0;
          }
          if (margin) {
            size -= parseFloat($.css(elem, 'margin' + this)) || 0;
          }
        });
        return size;
      }
      $.fn['inner' + name] = function (size) {
        if (size === undefined) {
          return orig['inner' + name].call(this);
        }
        return this.each(function () {
          $(this).css(type, reduce(this, size) + 'px');
        });
      };
      $.fn['outer' + name] = function (size, margin) {
        if (typeof size !== 'number') {
          return orig['outer' + name].call(this, size);
        }
        return this.each(function () {
          $(this).css(type, reduce(this, size, true, margin) + 'px');
        });
      };
    });
  }
  // support: jQuery <1.8
  if (!$.fn.addBack) {
    $.fn.addBack = function (selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    };
  }
  // support: jQuery 1.6.1, 1.6.2 (http://bugs.jquery.com/ticket/9413)
  if ($('<a>').data('a-b', 'a').removeData('a-b').data('a-b')) {
    $.fn.removeData = function (removeData) {
      return function (key) {
        if (arguments.length) {
          return removeData.call(this, $.camelCase(key));
        } else {
          return removeData.call(this);
        }
      };
    }($.fn.removeData);
  }
  // deprecated
  $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
  $.support.selectstart = 'onselectstart' in document.createElement('div');
  $.fn.extend({
    disableSelection: function () {
      return this.bind(($.support.selectstart ? 'selectstart' : 'mousedown') + '.ui-disableSelection', function (event) {
        event.preventDefault();
      });
    },
    enableSelection: function () {
      return this.unbind('.ui-disableSelection');
    }
  });
  $.extend($.ui, {
    plugin: {
      add: function (module, option, set) {
        var i, proto = $.ui[module].prototype;
        for (i in set) {
          proto.plugins[i] = proto.plugins[i] || [];
          proto.plugins[i].push([
            option,
            set[i]
          ]);
        }
      },
      call: function (instance, name, args) {
        var i, set = instance.plugins[name];
        if (!set || !instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11) {
          return;
        }
        for (i = 0; i < set.length; i++) {
          if (instance.options[set[i][0]]) {
            set[i][1].apply(instance.element, args);
          }
        }
      }
    },
    hasScroll: function (el, a) {
      //If overflow is hidden, the element might have extra content, but the user wants to hide it
      if ($(el).css('overflow') === 'hidden') {
        return false;
      }
      var scroll = a && a === 'left' ? 'scrollLeft' : 'scrollTop', has = false;
      if (el[scroll] > 0) {
        return true;
      }
      // TODO: determine which cases actually cause this to happen
      // if the element doesn't have the scroll set, see if it's possible to
      // set the scroll
      el[scroll] = 1;
      has = el[scroll] > 0;
      el[scroll] = 0;
      return has;
    }
  });
}(jQuery));
(function ($, undefined) {
  var uuid = 0, slice = Array.prototype.slice, _cleanData = $.cleanData;
  $.cleanData = function (elems) {
    for (var i = 0, elem; (elem = elems[i]) != null; i++) {
      try {
        $(elem).triggerHandler('remove');  // http://bugs.jquery.com/ticket/8235
      } catch (e) {
      }
    }
    _cleanData(elems);
  };
  $.widget = function (name, base, prototype) {
    var fullName, existingConstructor, constructor, basePrototype,
      // proxiedPrototype allows the provided prototype to remain unmodified
      // so that it can be used as a mixin for multiple widgets (#8876)
      proxiedPrototype = {}, namespace = name.split('.')[0];
    name = name.split('.')[1];
    fullName = namespace + '-' + name;
    if (!prototype) {
      prototype = base;
      base = $.Widget;
    }
    // create selector for plugin
    $.expr[':'][fullName.toLowerCase()] = function (elem) {
      return !!$.data(elem, fullName);
    };
    $[namespace] = $[namespace] || {};
    existingConstructor = $[namespace][name];
    constructor = $[namespace][name] = function (options, element) {
      // allow instantiation without "new" keyword
      if (!this._createWidget) {
        return new constructor(options, element);
      }
      // allow instantiation without initializing for simple inheritance
      // must use "new" keyword (the code above always passes args)
      if (arguments.length) {
        this._createWidget(options, element);
      }
    };
    // extend with the existing constructor to carry over any static properties
    $.extend(constructor, existingConstructor, {
      version: prototype.version,
      _proto: $.extend({}, prototype),
      _childConstructors: []
    });
    basePrototype = new base();
    // we need to make the options hash a property directly on the new instance
    // otherwise we'll modify the options hash on the prototype that we're
    // inheriting from
    basePrototype.options = $.widget.extend({}, basePrototype.options);
    $.each(prototype, function (prop, value) {
      if (!$.isFunction(value)) {
        proxiedPrototype[prop] = value;
        return;
      }
      proxiedPrototype[prop] = function () {
        var _super = function () {
            return base.prototype[prop].apply(this, arguments);
          }, _superApply = function (args) {
            return base.prototype[prop].apply(this, args);
          };
        return function () {
          var __super = this._super, __superApply = this._superApply, returnValue;
          this._super = _super;
          this._superApply = _superApply;
          returnValue = value.apply(this, arguments);
          this._super = __super;
          this._superApply = __superApply;
          return returnValue;
        };
      }();
    });
    constructor.prototype = $.widget.extend(basePrototype, { widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix : name }, proxiedPrototype, {
      constructor: constructor,
      namespace: namespace,
      widgetName: name,
      widgetFullName: fullName
    });
    // If this widget is being redefined then we need to find all widgets that
    // are inheriting from it and redefine all of them so that they inherit from
    // the new version of this widget. We're essentially trying to replace one
    // level in the prototype chain.
    if (existingConstructor) {
      $.each(existingConstructor._childConstructors, function (i, child) {
        var childPrototype = child.prototype;
        // redefine the child widget using the same prototype that was
        // originally used, but inherit from the new version of the base
        $.widget(childPrototype.namespace + '.' + childPrototype.widgetName, constructor, child._proto);
      });
      // remove the list of existing child constructors from the old constructor
      // so the old child constructors can be garbage collected
      delete existingConstructor._childConstructors;
    } else {
      base._childConstructors.push(constructor);
    }
    $.widget.bridge(name, constructor);
  };
  $.widget.extend = function (target) {
    var input = slice.call(arguments, 1), inputIndex = 0, inputLength = input.length, key, value;
    for (; inputIndex < inputLength; inputIndex++) {
      for (key in input[inputIndex]) {
        value = input[inputIndex][key];
        if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
          // Clone objects
          if ($.isPlainObject(value)) {
            target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : $.widget.extend({}, value);  // Copy everything else by reference
          } else {
            target[key] = value;
          }
        }
      }
    }
    return target;
  };
  $.widget.bridge = function (name, object) {
    var fullName = object.prototype.widgetFullName || name;
    $.fn[name] = function (options) {
      var isMethodCall = typeof options === 'string', args = slice.call(arguments, 1), returnValue = this;
      // allow multiple hashes to be passed on init
      options = !isMethodCall && args.length ? $.widget.extend.apply(null, [options].concat(args)) : options;
      if (isMethodCall) {
        this.each(function () {
          var methodValue, instance = $.data(this, fullName);
          if (!instance) {
            return $.error('cannot call methods on ' + name + ' prior to initialization; ' + 'attempted to call method \'' + options + '\'');
          }
          if (!$.isFunction(instance[options]) || options.charAt(0) === '_') {
            return $.error('no such method \'' + options + '\' for ' + name + ' widget instance');
          }
          methodValue = instance[options].apply(instance, args);
          if (methodValue !== instance && methodValue !== undefined) {
            returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
            return false;
          }
        });
      } else {
        this.each(function () {
          var instance = $.data(this, fullName);
          if (instance) {
            instance.option(options || {})._init();
          } else {
            $.data(this, fullName, new object(options, this));
          }
        });
      }
      return returnValue;
    };
  };
  $.Widget = function () {
  };
  $.Widget._childConstructors = [];
  $.Widget.prototype = {
    widgetName: 'widget',
    widgetEventPrefix: '',
    defaultElement: '<div>',
    options: {
      disabled: false,
      create: null
    },
    _createWidget: function (options, element) {
      element = $(element || this.defaultElement || this)[0];
      this.element = $(element);
      this.uuid = uuid++;
      this.eventNamespace = '.' + this.widgetName + this.uuid;
      this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);
      this.bindings = $();
      this.hoverable = $();
      this.focusable = $();
      if (element !== this) {
        $.data(element, this.widgetFullName, this);
        this._on(true, this.element, {
          remove: function (event) {
            if (event.target === element) {
              this.destroy();
            }
          }
        });
        this.document = $(element.style ? element.ownerDocument : element.document || element);
        this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
      }
      this._create();
      this._trigger('create', null, this._getCreateEventData());
      this._init();
    },
    _getCreateOptions: $.noop,
    _getCreateEventData: $.noop,
    _create: $.noop,
    _init: $.noop,
    destroy: function () {
      this._destroy();
      // we can probably remove the unbind calls in 2.0
      // all event bindings should go through this._on()
      this.element.unbind(this.eventNamespace).removeData(this.widgetName).removeData(this.widgetFullName).removeData($.camelCase(this.widgetFullName));
      this.widget().unbind(this.eventNamespace).removeAttr('aria-disabled').removeClass(this.widgetFullName + '-disabled ' + 'ui-state-disabled');
      // clean up events and states
      this.bindings.unbind(this.eventNamespace);
      this.hoverable.removeClass('ui-state-hover');
      this.focusable.removeClass('ui-state-focus');
    },
    _destroy: $.noop,
    widget: function () {
      return this.element;
    },
    option: function (key, value) {
      var options = key, parts, curOption, i;
      if (arguments.length === 0) {
        // don't return a reference to the internal hash
        return $.widget.extend({}, this.options);
      }
      if (typeof key === 'string') {
        // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
        options = {};
        parts = key.split('.');
        key = parts.shift();
        if (parts.length) {
          curOption = options[key] = $.widget.extend({}, this.options[key]);
          for (i = 0; i < parts.length - 1; i++) {
            curOption[parts[i]] = curOption[parts[i]] || {};
            curOption = curOption[parts[i]];
          }
          key = parts.pop();
          if (value === undefined) {
            return curOption[key] === undefined ? null : curOption[key];
          }
          curOption[key] = value;
        } else {
          if (value === undefined) {
            return this.options[key] === undefined ? null : this.options[key];
          }
          options[key] = value;
        }
      }
      this._setOptions(options);
      return this;
    },
    _setOptions: function (options) {
      var key;
      for (key in options) {
        this._setOption(key, options[key]);
      }
      return this;
    },
    _setOption: function (key, value) {
      this.options[key] = value;
      if (key === 'disabled') {
        this.widget().toggleClass(this.widgetFullName + '-disabled ui-state-disabled', !!value).attr('aria-disabled', value);
        this.hoverable.removeClass('ui-state-hover');
        this.focusable.removeClass('ui-state-focus');
      }
      return this;
    },
    enable: function () {
      return this._setOption('disabled', false);
    },
    disable: function () {
      return this._setOption('disabled', true);
    },
    _on: function (suppressDisabledCheck, element, handlers) {
      var delegateElement, instance = this;
      // no suppressDisabledCheck flag, shuffle arguments
      if (typeof suppressDisabledCheck !== 'boolean') {
        handlers = element;
        element = suppressDisabledCheck;
        suppressDisabledCheck = false;
      }
      // no element argument, shuffle and use this.element
      if (!handlers) {
        handlers = element;
        element = this.element;
        delegateElement = this.widget();
      } else {
        // accept selectors, DOM elements
        element = delegateElement = $(element);
        this.bindings = this.bindings.add(element);
      }
      $.each(handlers, function (event, handler) {
        function handlerProxy() {
          // allow widgets to customize the disabled handling
          // - disabled as an array instead of boolean
          // - disabled class as method for disabling individual parts
          if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass('ui-state-disabled'))) {
            return;
          }
          return (typeof handler === 'string' ? instance[handler] : handler).apply(instance, arguments);
        }
        // copy the guid so direct unbinding works
        if (typeof handler !== 'string') {
          handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
        }
        var match = event.match(/^(\w+)\s*(.*)$/), eventName = match[1] + instance.eventNamespace, selector = match[2];
        if (selector) {
          delegateElement.delegate(selector, eventName, handlerProxy);
        } else {
          element.bind(eventName, handlerProxy);
        }
      });
    },
    _off: function (element, eventName) {
      eventName = (eventName || '').split(' ').join(this.eventNamespace + ' ') + this.eventNamespace;
      element.unbind(eventName).undelegate(eventName);
    },
    _delay: function (handler, delay) {
      function handlerProxy() {
        return (typeof handler === 'string' ? instance[handler] : handler).apply(instance, arguments);
      }
      var instance = this;
      return setTimeout(handlerProxy, delay || 0);
    },
    _hoverable: function (element) {
      this.hoverable = this.hoverable.add(element);
      this._on(element, {
        mouseenter: function (event) {
          $(event.currentTarget).addClass('ui-state-hover');
        },
        mouseleave: function (event) {
          $(event.currentTarget).removeClass('ui-state-hover');
        }
      });
    },
    _focusable: function (element) {
      this.focusable = this.focusable.add(element);
      this._on(element, {
        focusin: function (event) {
          $(event.currentTarget).addClass('ui-state-focus');
        },
        focusout: function (event) {
          $(event.currentTarget).removeClass('ui-state-focus');
        }
      });
    },
    _trigger: function (type, event, data) {
      var prop, orig, callback = this.options[type];
      data = data || {};
      event = $.Event(event);
      event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();
      // the original event may come from any element
      // so we need to reset the target on the new event
      event.target = this.element[0];
      // copy original event properties over to the new event
      orig = event.originalEvent;
      if (orig) {
        for (prop in orig) {
          if (!(prop in event)) {
            event[prop] = orig[prop];
          }
        }
      }
      this.element.trigger(event, data);
      return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());
    }
  };
  $.each({
    show: 'fadeIn',
    hide: 'fadeOut'
  }, function (method, defaultEffect) {
    $.Widget.prototype['_' + method] = function (element, options, callback) {
      if (typeof options === 'string') {
        options = { effect: options };
      }
      var hasOptions, effectName = !options ? method : options === true || typeof options === 'number' ? defaultEffect : options.effect || defaultEffect;
      options = options || {};
      if (typeof options === 'number') {
        options = { duration: options };
      }
      hasOptions = !$.isEmptyObject(options);
      options.complete = callback;
      if (options.delay) {
        element.delay(options.delay);
      }
      if (hasOptions && $.effects && $.effects.effect[effectName]) {
        element[method](options);
      } else if (effectName !== method && element[effectName]) {
        element[effectName](options.duration, options.easing, callback);
      } else {
        element.queue(function (next) {
          $(this)[method]();
          if (callback) {
            callback.call(element[0]);
          }
          next();
        });
      }
    };
  });
}(jQuery));
(function ($, undefined) {
  var mouseHandled = false;
  $(document).mouseup(function () {
    mouseHandled = false;
  });
  $.widget('ui.mouse', {
    version: '1.10.3',
    options: {
      cancel: 'input,textarea,button,select,option',
      distance: 1,
      delay: 0
    },
    _mouseInit: function () {
      var that = this;
      this.element.bind('mousedown.' + this.widgetName, function (event) {
        return that._mouseDown(event);
      }).bind('click.' + this.widgetName, function (event) {
        if (true === $.data(event.target, that.widgetName + '.preventClickEvent')) {
          $.removeData(event.target, that.widgetName + '.preventClickEvent');
          event.stopImmediatePropagation();
          return false;
        }
      });
      this.started = false;
    },
    _mouseDestroy: function () {
      this.element.unbind('.' + this.widgetName);
      if (this._mouseMoveDelegate) {
        $(document).unbind('mousemove.' + this.widgetName, this._mouseMoveDelegate).unbind('mouseup.' + this.widgetName, this._mouseUpDelegate);
      }
    },
    _mouseDown: function (event) {
      // don't let more than one widget handle mouseStart
      if (mouseHandled) {
        return;
      }
      // we may have missed mouseup (out of window)
      this._mouseStarted && this._mouseUp(event);
      this._mouseDownEvent = event;
      var that = this, btnIsLeft = event.which === 1,
        // event.target.nodeName works around a bug in IE 8 with
        // disabled inputs (#7620)
        elIsCancel = typeof this.options.cancel === 'string' && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false;
      if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
        return true;
      }
      this.mouseDelayMet = !this.options.delay;
      if (!this.mouseDelayMet) {
        this._mouseDelayTimer = setTimeout(function () {
          that.mouseDelayMet = true;
        }, this.options.delay);
      }
      if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
        this._mouseStarted = this._mouseStart(event) !== false;
        if (!this._mouseStarted) {
          event.preventDefault();
          return true;
        }
      }
      // Click event may never have fired (Gecko & Opera)
      if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) {
        $.removeData(event.target, this.widgetName + '.preventClickEvent');
      }
      // these delegates are required to keep context
      this._mouseMoveDelegate = function (event) {
        return that._mouseMove(event);
      };
      this._mouseUpDelegate = function (event) {
        return that._mouseUp(event);
      };
      $(document).bind('mousemove.' + this.widgetName, this._mouseMoveDelegate).bind('mouseup.' + this.widgetName, this._mouseUpDelegate);
      event.preventDefault();
      mouseHandled = true;
      return true;
    },
    _mouseMove: function (event) {
      // IE mouseup check - mouseup happened when mouse was out of window
      if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
        return this._mouseUp(event);
      }
      if (this._mouseStarted) {
        this._mouseDrag(event);
        return event.preventDefault();
      }
      if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
        this._mouseStarted = this._mouseStart(this._mouseDownEvent, event) !== false;
        this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event);
      }
      return !this._mouseStarted;
    },
    _mouseUp: function (event) {
      $(document).unbind('mousemove.' + this.widgetName, this._mouseMoveDelegate).unbind('mouseup.' + this.widgetName, this._mouseUpDelegate);
      if (this._mouseStarted) {
        this._mouseStarted = false;
        if (event.target === this._mouseDownEvent.target) {
          $.data(event.target, this.widgetName + '.preventClickEvent', true);
        }
        this._mouseStop(event);
      }
      return false;
    },
    _mouseDistanceMet: function (event) {
      return Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance;
    },
    _mouseDelayMet: function () {
      return this.mouseDelayMet;
    },
    _mouseStart: function () {
    },
    _mouseDrag: function () {
    },
    _mouseStop: function () {
    },
    _mouseCapture: function () {
      return true;
    }
  });
}(jQuery));
(function ($, undefined) {
  $.widget('ui.draggable', $.ui.mouse, {
    version: '1.10.3',
    widgetEventPrefix: 'drag',
    options: {
      addClasses: true,
      appendTo: 'parent',
      axis: false,
      connectToSortable: false,
      containment: false,
      cursor: 'auto',
      cursorAt: false,
      grid: false,
      handle: false,
      helper: 'original',
      iframeFix: false,
      opacity: false,
      refreshPositions: false,
      revert: false,
      revertDuration: 500,
      scope: 'default',
      scroll: true,
      scrollSensitivity: 20,
      scrollSpeed: 20,
      snap: false,
      snapMode: 'both',
      snapTolerance: 20,
      stack: false,
      zIndex: false,
      drag: null,
      start: null,
      stop: null
    },
    _create: function () {
      if (this.options.helper === 'original' && !/^(?:r|a|f)/.test(this.element.css('position'))) {
        this.element[0].style.position = 'relative';
      }
      if (this.options.addClasses) {
        this.element.addClass('ui-draggable');
      }
      if (this.options.disabled) {
        this.element.addClass('ui-draggable-disabled');
      }
      this._mouseInit();
    },
    _destroy: function () {
      this.element.removeClass('ui-draggable ui-draggable-dragging ui-draggable-disabled');
      this._mouseDestroy();
    },
    _mouseCapture: function (event) {
      var o = this.options;
      // among others, prevent a drag on a resizable-handle
      if (this.helper || o.disabled || $(event.target).closest('.ui-resizable-handle').length > 0) {
        return false;
      }
      //Quit if we're not on a valid handle
      this.handle = this._getHandle(event);
      if (!this.handle) {
        return false;
      }
      $(o.iframeFix === true ? 'iframe' : o.iframeFix).each(function () {
        $('<div class=\'ui-draggable-iframeFix\' style=\'background: #fff;\'></div>').css({
          width: this.offsetWidth + 'px',
          height: this.offsetHeight + 'px',
          position: 'absolute',
          opacity: '0.001',
          zIndex: 1000
        }).css($(this).offset()).appendTo('body');
      });
      return true;
    },
    _mouseStart: function (event) {
      var o = this.options;
      //Create and append the visible helper
      this.helper = this._createHelper(event);
      this.helper.addClass('ui-draggable-dragging');
      //Cache the helper size
      this._cacheHelperProportions();
      //If ddmanager is used for droppables, set the global draggable
      if ($.ui.ddmanager) {
        $.ui.ddmanager.current = this;
      }
      /*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */
      //Cache the margins of the original element
      this._cacheMargins();
      //Store the helper's css position
      this.cssPosition = this.helper.css('position');
      this.scrollParent = this.helper.scrollParent();
      this.offsetParent = this.helper.offsetParent();
      this.offsetParentCssPosition = this.offsetParent.css('position');
      //The element's absolute position on the page minus margins
      this.offset = this.positionAbs = this.element.offset();
      this.offset = {
        top: this.offset.top - this.margins.top,
        left: this.offset.left - this.margins.left
      };
      //Reset scroll cache
      this.offset.scroll = false;
      $.extend(this.offset, {
        click: {
          left: event.pageX - this.offset.left,
          top: event.pageY - this.offset.top
        },
        parent: this._getParentOffset(),
        relative: this._getRelativeOffset()
      });
      //Generate the original position
      this.originalPosition = this.position = this._generatePosition(event);
      this.originalPageX = event.pageX;
      this.originalPageY = event.pageY;
      //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
      o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);
      //Set a containment if given in the options
      this._setContainment();
      //Trigger event + callbacks
      if (this._trigger('start', event) === false) {
        this._clear();
        return false;
      }
      //Recache the helper size
      this._cacheHelperProportions();
      //Prepare the droppable offsets
      if ($.ui.ddmanager && !o.dropBehaviour) {
        $.ui.ddmanager.prepareOffsets(this, event);
      }
      this._mouseDrag(event, true);
      //Execute the drag once - this causes the helper not to be visible before getting its correct position
      //If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
      if ($.ui.ddmanager) {
        $.ui.ddmanager.dragStart(this, event);
      }
      return true;
    },
    _mouseDrag: function (event, noPropagation) {
      // reset any necessary cached properties (see #5009)
      if (this.offsetParentCssPosition === 'fixed') {
        this.offset.parent = this._getParentOffset();
      }
      //Compute the helpers position
      this.position = this._generatePosition(event);
      this.positionAbs = this._convertPositionTo('absolute');
      //Call plugins and callbacks and use the resulting position if something is returned
      if (!noPropagation) {
        var ui = this._uiHash();
        if (this._trigger('drag', event, ui) === false) {
          this._mouseUp({});
          return false;
        }
        this.position = ui.position;
      }
      if (!this.options.axis || this.options.axis !== 'y') {
        this.helper[0].style.left = this.position.left + 'px';
      }
      if (!this.options.axis || this.options.axis !== 'x') {
        this.helper[0].style.top = this.position.top + 'px';
      }
      if ($.ui.ddmanager) {
        $.ui.ddmanager.drag(this, event);
      }
      return false;
    },
    _mouseStop: function (event) {
      //If we are using droppables, inform the manager about the drop
      var that = this, dropped = false;
      if ($.ui.ddmanager && !this.options.dropBehaviour) {
        dropped = $.ui.ddmanager.drop(this, event);
      }
      //if a drop comes from outside (a sortable)
      if (this.dropped) {
        dropped = this.dropped;
        this.dropped = false;
      }
      //if the original element is no longer in the DOM don't bother to continue (see #8269)
      if (this.options.helper === 'original' && !$.contains(this.element[0].ownerDocument, this.element[0])) {
        return false;
      }
      if (this.options.revert === 'invalid' && !dropped || this.options.revert === 'valid' && dropped || this.options.revert === true || $.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped)) {
        $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function () {
          if (that._trigger('stop', event) !== false) {
            that._clear();
          }
        });
      } else {
        if (this._trigger('stop', event) !== false) {
          this._clear();
        }
      }
      return false;
    },
    _mouseUp: function (event) {
      //Remove frame helpers
      $('div.ui-draggable-iframeFix').each(function () {
        this.parentNode.removeChild(this);
      });
      //If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
      if ($.ui.ddmanager) {
        $.ui.ddmanager.dragStop(this, event);
      }
      return $.ui.mouse.prototype._mouseUp.call(this, event);
    },
    cancel: function () {
      if (this.helper.is('.ui-draggable-dragging')) {
        this._mouseUp({});
      } else {
        this._clear();
      }
      return this;
    },
    _getHandle: function (event) {
      return this.options.handle ? !!$(event.target).closest(this.element.find(this.options.handle)).length : true;
    },
    _createHelper: function (event) {
      var o = this.options, helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : o.helper === 'clone' ? this.element.clone().removeAttr('id') : this.element;
      if (!helper.parents('body').length) {
        helper.appendTo(o.appendTo === 'parent' ? this.element[0].parentNode : o.appendTo);
      }
      if (helper[0] !== this.element[0] && !/(fixed|absolute)/.test(helper.css('position'))) {
        helper.css('position', 'absolute');
      }
      return helper;
    },
    _adjustOffsetFromHelper: function (obj) {
      if (typeof obj === 'string') {
        obj = obj.split(' ');
      }
      if ($.isArray(obj)) {
        obj = {
          left: +obj[0],
          top: +obj[1] || 0
        };
      }
      if ('left' in obj) {
        this.offset.click.left = obj.left + this.margins.left;
      }
      if ('right' in obj) {
        this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
      }
      if ('top' in obj) {
        this.offset.click.top = obj.top + this.margins.top;
      }
      if ('bottom' in obj) {
        this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
      }
    },
    _getParentOffset: function () {
      //Get the offsetParent and cache its position
      var po = this.offsetParent.offset();
      // This is a special case where we need to modify a offset calculated on start, since the following happened:
      // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
      // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
      //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
      if (this.cssPosition === 'absolute' && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
        po.left += this.scrollParent.scrollLeft();
        po.top += this.scrollParent.scrollTop();
      }
      //This needs to be actually done for all browsers, since pageX/pageY includes this information
      //Ugly IE fix
      if (this.offsetParent[0] === document.body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === 'html' && $.ui.ie) {
        po = {
          top: 0,
          left: 0
        };
      }
      return {
        top: po.top + (parseInt(this.offsetParent.css('borderTopWidth'), 10) || 0),
        left: po.left + (parseInt(this.offsetParent.css('borderLeftWidth'), 10) || 0)
      };
    },
    _getRelativeOffset: function () {
      if (this.cssPosition === 'relative') {
        var p = this.element.position();
        return {
          top: p.top - (parseInt(this.helper.css('top'), 10) || 0) + this.scrollParent.scrollTop(),
          left: p.left - (parseInt(this.helper.css('left'), 10) || 0) + this.scrollParent.scrollLeft()
        };
      } else {
        return {
          top: 0,
          left: 0
        };
      }
    },
    _cacheMargins: function () {
      this.margins = {
        left: parseInt(this.element.css('marginLeft'), 10) || 0,
        top: parseInt(this.element.css('marginTop'), 10) || 0,
        right: parseInt(this.element.css('marginRight'), 10) || 0,
        bottom: parseInt(this.element.css('marginBottom'), 10) || 0
      };
    },
    _cacheHelperProportions: function () {
      this.helperProportions = {
        width: this.helper.outerWidth(),
        height: this.helper.outerHeight()
      };
    },
    _setContainment: function () {
      var over, c, ce, o = this.options;
      if (!o.containment) {
        this.containment = null;
        return;
      }
      if (o.containment === 'window') {
        this.containment = [
          $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
          $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
          $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left,
          $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
        ];
        return;
      }
      if (o.containment === 'document') {
        this.containment = [
          0,
          0,
          $(document).width() - this.helperProportions.width - this.margins.left,
          ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
        ];
        return;
      }
      if (o.containment.constructor === Array) {
        this.containment = o.containment;
        return;
      }
      if (o.containment === 'parent') {
        o.containment = this.helper[0].parentNode;
      }
      c = $(o.containment);
      ce = c[0];
      if (!ce) {
        return;
      }
      over = c.css('overflow') !== 'hidden';
      this.containment = [
        (parseInt(c.css('borderLeftWidth'), 10) || 0) + (parseInt(c.css('paddingLeft'), 10) || 0),
        (parseInt(c.css('borderTopWidth'), 10) || 0) + (parseInt(c.css('paddingTop'), 10) || 0),
        (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt(c.css('borderRightWidth'), 10) || 0) - (parseInt(c.css('paddingRight'), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
        (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt(c.css('borderBottomWidth'), 10) || 0) - (parseInt(c.css('paddingBottom'), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom
      ];
      this.relative_container = c;
    },
    _convertPositionTo: function (d, pos) {
      if (!pos) {
        pos = this.position;
      }
      var mod = d === 'absolute' ? 1 : -1, scroll = this.cssPosition === 'absolute' && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent;
      //Cache the scroll
      if (!this.offset.scroll) {
        this.offset.scroll = {
          top: scroll.scrollTop(),
          left: scroll.scrollLeft()
        };
      }
      return {
        top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - (this.cssPosition === 'fixed' ? -this.scrollParent.scrollTop() : this.offset.scroll.top) * mod,
        left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - (this.cssPosition === 'fixed' ? -this.scrollParent.scrollLeft() : this.offset.scroll.left) * mod
      };
    },
    _generatePosition: function (event) {
      var containment, co, top, left, o = this.options, scroll = this.cssPosition === 'absolute' && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, pageX = event.pageX, pageY = event.pageY;
      //Cache the scroll
      if (!this.offset.scroll) {
        this.offset.scroll = {
          top: scroll.scrollTop(),
          left: scroll.scrollLeft()
        };
      }
      /*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */
      // If we are not dragging yet, we won't check for options
      if (this.originalPosition) {
        if (this.containment) {
          if (this.relative_container) {
            co = this.relative_container.offset();
            containment = [
              this.containment[0] + co.left,
              this.containment[1] + co.top,
              this.containment[2] + co.left,
              this.containment[3] + co.top
            ];
          } else {
            containment = this.containment;
          }
          if (event.pageX - this.offset.click.left < containment[0]) {
            pageX = containment[0] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top < containment[1]) {
            pageY = containment[1] + this.offset.click.top;
          }
          if (event.pageX - this.offset.click.left > containment[2]) {
            pageX = containment[2] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top > containment[3]) {
            pageY = containment[3] + this.offset.click.top;
          }
        }
        if (o.grid) {
          //Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
          top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
          pageY = containment ? top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3] ? top : top - this.offset.click.top >= containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
          left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
          pageX = containment ? left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2] ? left : left - this.offset.click.left >= containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
        }
      }
      return {
        top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition === 'fixed' ? -this.scrollParent.scrollTop() : this.offset.scroll.top),
        left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition === 'fixed' ? -this.scrollParent.scrollLeft() : this.offset.scroll.left)
      };
    },
    _clear: function () {
      this.helper.removeClass('ui-draggable-dragging');
      if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
        this.helper.remove();
      }
      this.helper = null;
      this.cancelHelperRemoval = false;
    },
    _trigger: function (type, event, ui) {
      ui = ui || this._uiHash();
      $.ui.plugin.call(this, type, [
        event,
        ui
      ]);
      //The absolute position has to be recalculated after plugins
      if (type === 'drag') {
        this.positionAbs = this._convertPositionTo('absolute');
      }
      return $.Widget.prototype._trigger.call(this, type, event, ui);
    },
    plugins: {},
    _uiHash: function () {
      return {
        helper: this.helper,
        position: this.position,
        originalPosition: this.originalPosition,
        offset: this.positionAbs
      };
    }
  });
  $.ui.plugin.add('draggable', 'connectToSortable', {
    start: function (event, ui) {
      var inst = $(this).data('ui-draggable'), o = inst.options, uiSortable = $.extend({}, ui, { item: inst.element });
      inst.sortables = [];
      $(o.connectToSortable).each(function () {
        var sortable = $.data(this, 'ui-sortable');
        if (sortable && !sortable.options.disabled) {
          inst.sortables.push({
            instance: sortable,
            shouldRevert: sortable.options.revert
          });
          sortable.refreshPositions();
          // Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
          sortable._trigger('activate', event, uiSortable);
        }
      });
    },
    stop: function (event, ui) {
      //If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
      var inst = $(this).data('ui-draggable'), uiSortable = $.extend({}, ui, { item: inst.element });
      $.each(inst.sortables, function () {
        if (this.instance.isOver) {
          this.instance.isOver = 0;
          inst.cancelHelperRemoval = true;
          //Don't remove the helper in the draggable instance
          this.instance.cancelHelperRemoval = false;
          //Remove it in the sortable instance (so sortable plugins like revert still work)
          //The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: "valid/invalid"
          if (this.shouldRevert) {
            this.instance.options.revert = this.shouldRevert;
          }
          //Trigger the stop of the sortable
          this.instance._mouseStop(event);
          this.instance.options.helper = this.instance.options._helper;
          //If the helper has been the original item, restore properties in the sortable
          if (inst.options.helper === 'original') {
            this.instance.currentItem.css({
              top: 'auto',
              left: 'auto'
            });
          }
        } else {
          this.instance.cancelHelperRemoval = false;
          //Remove the helper in the sortable instance
          this.instance._trigger('deactivate', event, uiSortable);
        }
      });
    },
    drag: function (event, ui) {
      var inst = $(this).data('ui-draggable'), that = this;
      $.each(inst.sortables, function () {
        var innermostIntersecting = false, thisSortable = this;
        //Copy over some variables to allow calling the sortable's native _intersectsWith
        this.instance.positionAbs = inst.positionAbs;
        this.instance.helperProportions = inst.helperProportions;
        this.instance.offset.click = inst.offset.click;
        if (this.instance._intersectsWith(this.instance.containerCache)) {
          innermostIntersecting = true;
          $.each(inst.sortables, function () {
            this.instance.positionAbs = inst.positionAbs;
            this.instance.helperProportions = inst.helperProportions;
            this.instance.offset.click = inst.offset.click;
            if (this !== thisSortable && this.instance._intersectsWith(this.instance.containerCache) && $.contains(thisSortable.instance.element[0], this.instance.element[0])) {
              innermostIntersecting = false;
            }
            return innermostIntersecting;
          });
        }
        if (innermostIntersecting) {
          //If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
          if (!this.instance.isOver) {
            this.instance.isOver = 1;
            //Now we fake the start of dragging for the sortable instance,
            //by cloning the list group item, appending it to the sortable and using it as inst.currentItem
            //We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
            this.instance.currentItem = $(that).clone().removeAttr('id').appendTo(this.instance.element).data('ui-sortable-item', true);
            this.instance.options._helper = this.instance.options.helper;
            //Store helper option to later restore it
            this.instance.options.helper = function () {
              return ui.helper[0];
            };
            event.target = this.instance.currentItem[0];
            this.instance._mouseCapture(event, true);
            this.instance._mouseStart(event, true, true);
            //Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
            this.instance.offset.click.top = inst.offset.click.top;
            this.instance.offset.click.left = inst.offset.click.left;
            this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
            this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;
            inst._trigger('toSortable', event);
            inst.dropped = this.instance.element;
            //draggable revert needs that
            //hack so receive/update callbacks work (mostly)
            inst.currentItem = inst.element;
            this.instance.fromOutside = inst;
          }
          //Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
          if (this.instance.currentItem) {
            this.instance._mouseDrag(event);
          }
        } else {
          //If it doesn't intersect with the sortable, and it intersected before,
          //we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
          if (this.instance.isOver) {
            this.instance.isOver = 0;
            this.instance.cancelHelperRemoval = true;
            //Prevent reverting on this forced stop
            this.instance.options.revert = false;
            // The out event needs to be triggered independently
            this.instance._trigger('out', event, this.instance._uiHash(this.instance));
            this.instance._mouseStop(event, true);
            this.instance.options.helper = this.instance.options._helper;
            //Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
            this.instance.currentItem.remove();
            if (this.instance.placeholder) {
              this.instance.placeholder.remove();
            }
            inst._trigger('fromSortable', event);
            inst.dropped = false;  //draggable revert needs that
          }
        }
      });
    }
  });
  $.ui.plugin.add('draggable', 'cursor', {
    start: function () {
      var t = $('body'), o = $(this).data('ui-draggable').options;
      if (t.css('cursor')) {
        o._cursor = t.css('cursor');
      }
      t.css('cursor', o.cursor);
    },
    stop: function () {
      var o = $(this).data('ui-draggable').options;
      if (o._cursor) {
        $('body').css('cursor', o._cursor);
      }
    }
  });
  $.ui.plugin.add('draggable', 'opacity', {
    start: function (event, ui) {
      var t = $(ui.helper), o = $(this).data('ui-draggable').options;
      if (t.css('opacity')) {
        o._opacity = t.css('opacity');
      }
      t.css('opacity', o.opacity);
    },
    stop: function (event, ui) {
      var o = $(this).data('ui-draggable').options;
      if (o._opacity) {
        $(ui.helper).css('opacity', o._opacity);
      }
    }
  });
  $.ui.plugin.add('draggable', 'scroll', {
    start: function () {
      var i = $(this).data('ui-draggable');
      if (i.scrollParent[0] !== document && i.scrollParent[0].tagName !== 'HTML') {
        i.overflowOffset = i.scrollParent.offset();
      }
    },
    drag: function (event) {
      var i = $(this).data('ui-draggable'), o = i.options, scrolled = false;
      if (i.scrollParent[0] !== document && i.scrollParent[0].tagName !== 'HTML') {
        if (!o.axis || o.axis !== 'x') {
          if (i.overflowOffset.top + i.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) {
            i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
          } else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
            i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
          }
        }
        if (!o.axis || o.axis !== 'y') {
          if (i.overflowOffset.left + i.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) {
            i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
          } else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
            i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
          }
        }
      } else {
        if (!o.axis || o.axis !== 'x') {
          if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
            scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
          } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
            scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
          }
        }
        if (!o.axis || o.axis !== 'y') {
          if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
            scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
          } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
            scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
          }
        }
      }
      if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
        $.ui.ddmanager.prepareOffsets(i, event);
      }
    }
  });
  $.ui.plugin.add('draggable', 'snap', {
    start: function () {
      var i = $(this).data('ui-draggable'), o = i.options;
      i.snapElements = [];
      $(o.snap.constructor !== String ? o.snap.items || ':data(ui-draggable)' : o.snap).each(function () {
        var $t = $(this), $o = $t.offset();
        if (this !== i.element[0]) {
          i.snapElements.push({
            item: this,
            width: $t.outerWidth(),
            height: $t.outerHeight(),
            top: $o.top,
            left: $o.left
          });
        }
      });
    },
    drag: function (event, ui) {
      var ts, bs, ls, rs, l, r, t, b, i, first, inst = $(this).data('ui-draggable'), o = inst.options, d = o.snapTolerance, x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width, y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;
      for (i = inst.snapElements.length - 1; i >= 0; i--) {
        l = inst.snapElements[i].left;
        r = l + inst.snapElements[i].width;
        t = inst.snapElements[i].top;
        b = t + inst.snapElements[i].height;
        if (x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item)) {
          if (inst.snapElements[i].snapping) {
            inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item }));
          }
          inst.snapElements[i].snapping = false;
          continue;
        }
        if (o.snapMode !== 'inner') {
          ts = Math.abs(t - y2) <= d;
          bs = Math.abs(b - y1) <= d;
          ls = Math.abs(l - x2) <= d;
          rs = Math.abs(r - x1) <= d;
          if (ts) {
            ui.position.top = inst._convertPositionTo('relative', {
              top: t - inst.helperProportions.height,
              left: 0
            }).top - inst.margins.top;
          }
          if (bs) {
            ui.position.top = inst._convertPositionTo('relative', {
              top: b,
              left: 0
            }).top - inst.margins.top;
          }
          if (ls) {
            ui.position.left = inst._convertPositionTo('relative', {
              top: 0,
              left: l - inst.helperProportions.width
            }).left - inst.margins.left;
          }
          if (rs) {
            ui.position.left = inst._convertPositionTo('relative', {
              top: 0,
              left: r
            }).left - inst.margins.left;
          }
        }
        first = ts || bs || ls || rs;
        if (o.snapMode !== 'outer') {
          ts = Math.abs(t - y1) <= d;
          bs = Math.abs(b - y2) <= d;
          ls = Math.abs(l - x1) <= d;
          rs = Math.abs(r - x2) <= d;
          if (ts) {
            ui.position.top = inst._convertPositionTo('relative', {
              top: t,
              left: 0
            }).top - inst.margins.top;
          }
          if (bs) {
            ui.position.top = inst._convertPositionTo('relative', {
              top: b - inst.helperProportions.height,
              left: 0
            }).top - inst.margins.top;
          }
          if (ls) {
            ui.position.left = inst._convertPositionTo('relative', {
              top: 0,
              left: l
            }).left - inst.margins.left;
          }
          if (rs) {
            ui.position.left = inst._convertPositionTo('relative', {
              top: 0,
              left: r - inst.helperProportions.width
            }).left - inst.margins.left;
          }
        }
        if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
          inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item }));
        }
        inst.snapElements[i].snapping = ts || bs || ls || rs || first;
      }
    }
  });
  $.ui.plugin.add('draggable', 'stack', {
    start: function () {
      var min, o = this.data('ui-draggable').options, group = $.makeArray($(o.stack)).sort(function (a, b) {
          return (parseInt($(a).css('zIndex'), 10) || 0) - (parseInt($(b).css('zIndex'), 10) || 0);
        });
      if (!group.length) {
        return;
      }
      min = parseInt($(group[0]).css('zIndex'), 10) || 0;
      $(group).each(function (i) {
        $(this).css('zIndex', min + i);
      });
      this.css('zIndex', min + group.length);
    }
  });
  $.ui.plugin.add('draggable', 'zIndex', {
    start: function (event, ui) {
      var t = $(ui.helper), o = $(this).data('ui-draggable').options;
      if (t.css('zIndex')) {
        o._zIndex = t.css('zIndex');
      }
      t.css('zIndex', o.zIndex);
    },
    stop: function (event, ui) {
      var o = $(this).data('ui-draggable').options;
      if (o._zIndex) {
        $(ui.helper).css('zIndex', o._zIndex);
      }
    }
  });
}(jQuery));
(function ($, undefined) {
  function isOverAxis(x, reference, size) {
    return x > reference && x < reference + size;
  }
  $.widget('ui.droppable', {
    version: '1.10.3',
    widgetEventPrefix: 'drop',
    options: {
      accept: '*',
      activeClass: false,
      addClasses: true,
      greedy: false,
      hoverClass: false,
      scope: 'default',
      tolerance: 'intersect',
      activate: null,
      deactivate: null,
      drop: null,
      out: null,
      over: null
    },
    _create: function () {
      var o = this.options, accept = o.accept;
      this.isover = false;
      this.isout = true;
      this.accept = $.isFunction(accept) ? accept : function (d) {
        return d.is(accept);
      };
      //Store the droppable's proportions
      this.proportions = {
        width: this.element[0].offsetWidth,
        height: this.element[0].offsetHeight
      };
      // Add the reference and positions to the manager
      $.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
      $.ui.ddmanager.droppables[o.scope].push(this);
      o.addClasses && this.element.addClass('ui-droppable');
    },
    _destroy: function () {
      var i = 0, drop = $.ui.ddmanager.droppables[this.options.scope];
      for (; i < drop.length; i++) {
        if (drop[i] === this) {
          drop.splice(i, 1);
        }
      }
      this.element.removeClass('ui-droppable ui-droppable-disabled');
    },
    _setOption: function (key, value) {
      if (key === 'accept') {
        this.accept = $.isFunction(value) ? value : function (d) {
          return d.is(value);
        };
      }
      $.Widget.prototype._setOption.apply(this, arguments);
    },
    _activate: function (event) {
      var draggable = $.ui.ddmanager.current;
      if (this.options.activeClass) {
        this.element.addClass(this.options.activeClass);
      }
      if (draggable) {
        this._trigger('activate', event, this.ui(draggable));
      }
    },
    _deactivate: function (event) {
      var draggable = $.ui.ddmanager.current;
      if (this.options.activeClass) {
        this.element.removeClass(this.options.activeClass);
      }
      if (draggable) {
        this._trigger('deactivate', event, this.ui(draggable));
      }
    },
    _over: function (event) {
      var draggable = $.ui.ddmanager.current;
      // Bail if draggable and droppable are same element
      if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
        return;
      }
      if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
        if (this.options.hoverClass) {
          this.element.addClass(this.options.hoverClass);
        }
        this._trigger('over', event, this.ui(draggable));
      }
    },
    _out: function (event) {
      var draggable = $.ui.ddmanager.current;
      // Bail if draggable and droppable are same element
      if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
        return;
      }
      if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
        if (this.options.hoverClass) {
          this.element.removeClass(this.options.hoverClass);
        }
        this._trigger('out', event, this.ui(draggable));
      }
    },
    _drop: function (event, custom) {
      var draggable = custom || $.ui.ddmanager.current, childrenIntersection = false;
      // Bail if draggable and droppable are same element
      if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
        return false;
      }
      this.element.find(':data(ui-droppable)').not('.ui-draggable-dragging').each(function () {
        var inst = $.data(this, 'ui-droppable');
        if (inst.options.greedy && !inst.options.disabled && inst.options.scope === draggable.options.scope && inst.accept.call(inst.element[0], draggable.currentItem || draggable.element) && $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)) {
          childrenIntersection = true;
          return false;
        }
      });
      if (childrenIntersection) {
        return false;
      }
      if (this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
        if (this.options.activeClass) {
          this.element.removeClass(this.options.activeClass);
        }
        if (this.options.hoverClass) {
          this.element.removeClass(this.options.hoverClass);
        }
        this._trigger('drop', event, this.ui(draggable));
        return this.element;
      }
      return false;
    },
    ui: function (c) {
      return {
        draggable: c.currentItem || c.element,
        helper: c.helper,
        position: c.position,
        offset: c.positionAbs
      };
    }
  });
  $.ui.intersect = function (draggable, droppable, toleranceMode) {
    if (!droppable.offset) {
      return false;
    }
    var draggableLeft, draggableTop, x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width, y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height, l = droppable.offset.left, r = l + droppable.proportions.width, t = droppable.offset.top, b = t + droppable.proportions.height;
    switch (toleranceMode) {
    case 'fit':
      return l <= x1 && x2 <= r && t <= y1 && y2 <= b;
    case 'intersect':
      return l < x1 + draggable.helperProportions.width / 2 && x2 - draggable.helperProportions.width / 2 < r && t < y1 + draggable.helperProportions.height / 2 && y2 - draggable.helperProportions.height / 2 < b;
    // Top Half
    case 'pointer':
      draggableLeft = (draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left;
      draggableTop = (draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top;
      return isOverAxis(draggableTop, t, droppable.proportions.height) && isOverAxis(draggableLeft, l, droppable.proportions.width);
    case 'touch':
      return (y1 >= t && y1 <= b || y2 >= t && y2 <= b || y1 < t && y2 > b) && (x1 >= l && x1 <= r || x2 >= l && x2 <= r || x1 < l && x2 > r);
    default:
      return false;
    }
  };
  /*
	This manager tracks offsets of draggables and droppables
*/
  $.ui.ddmanager = {
    current: null,
    droppables: { 'default': [] },
    prepareOffsets: function (t, event) {
      var i, j, m = $.ui.ddmanager.droppables[t.options.scope] || [], type = event ? event.type : null,
        // workaround for #2317
        list = (t.currentItem || t.element).find(':data(ui-droppable)').addBack();
      droppablesLoop:
        for (i = 0; i < m.length; i++) {
          //No disabled and non-accepted
          if (m[i].options.disabled || t && !m[i].accept.call(m[i].element[0], t.currentItem || t.element)) {
            continue;
          }
          // Filter out elements in the current dragged item
          for (j = 0; j < list.length; j++) {
            if (list[j] === m[i].element[0]) {
              m[i].proportions.height = 0;
              continue droppablesLoop;
            }
          }
          m[i].visible = m[i].element.css('display') !== 'none';
          if (!m[i].visible) {
            continue;
          }
          //Activate the droppable if used directly from draggables
          if (type === 'mousedown') {
            m[i]._activate.call(m[i], event);
          }
          m[i].offset = m[i].element.offset();
          m[i].proportions = {
            width: m[i].element[0].offsetWidth,
            height: m[i].element[0].offsetHeight
          };
        }
    },
    drop: function (draggable, event) {
      var dropped = false;
      // Create a copy of the droppables in case the list changes during the drop (#9116)
      $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function () {
        if (!this.options) {
          return;
        }
        if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance)) {
          dropped = this._drop.call(this, event) || dropped;
        }
        if (!this.options.disabled && this.visible && this.accept.call(this.element[0], draggable.currentItem || draggable.element)) {
          this.isout = true;
          this.isover = false;
          this._deactivate.call(this, event);
        }
      });
      return dropped;
    },
    dragStart: function (draggable, event) {
      //Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
      draggable.element.parentsUntil('body').bind('scroll.droppable', function () {
        if (!draggable.options.refreshPositions) {
          $.ui.ddmanager.prepareOffsets(draggable, event);
        }
      });
    },
    drag: function (draggable, event) {
      //If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
      if (draggable.options.refreshPositions) {
        $.ui.ddmanager.prepareOffsets(draggable, event);
      }
      //Run through all droppables and check their positions based on specific tolerance options
      $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function () {
        if (this.options.disabled || this.greedyChild || !this.visible) {
          return;
        }
        var parentInstance, scope, parent, intersects = $.ui.intersect(draggable, this, this.options.tolerance), c = !intersects && this.isover ? 'isout' : intersects && !this.isover ? 'isover' : null;
        if (!c) {
          return;
        }
        if (this.options.greedy) {
          // find droppable parents with same scope
          scope = this.options.scope;
          parent = this.element.parents(':data(ui-droppable)').filter(function () {
            return $.data(this, 'ui-droppable').options.scope === scope;
          });
          if (parent.length) {
            parentInstance = $.data(parent[0], 'ui-droppable');
            parentInstance.greedyChild = c === 'isover';
          }
        }
        // we just moved into a greedy child
        if (parentInstance && c === 'isover') {
          parentInstance.isover = false;
          parentInstance.isout = true;
          parentInstance._out.call(parentInstance, event);
        }
        this[c] = true;
        this[c === 'isout' ? 'isover' : 'isout'] = false;
        this[c === 'isover' ? '_over' : '_out'].call(this, event);
        // we just moved out of a greedy child
        if (parentInstance && c === 'isout') {
          parentInstance.isout = false;
          parentInstance.isover = true;
          parentInstance._over.call(parentInstance, event);
        }
      });
    },
    dragStop: function (draggable, event) {
      draggable.element.parentsUntil('body').unbind('scroll.droppable');
      //Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
      if (!draggable.options.refreshPositions) {
        $.ui.ddmanager.prepareOffsets(draggable, event);
      }
    }
  };
}(jQuery));
(function ($, undefined) {
  function num(v) {
    return parseInt(v, 10) || 0;
  }
  function isNumber(value) {
    return !isNaN(parseInt(value, 10));
  }
  $.widget('ui.resizable', $.ui.mouse, {
    version: '1.10.3',
    widgetEventPrefix: 'resize',
    options: {
      alsoResize: false,
      animate: false,
      animateDuration: 'slow',
      animateEasing: 'swing',
      aspectRatio: false,
      autoHide: false,
      containment: false,
      ghost: false,
      grid: false,
      handles: 'e,s,se',
      helper: false,
      maxHeight: null,
      maxWidth: null,
      minHeight: 10,
      minWidth: 10,
      zIndex: 90,
      resize: null,
      start: null,
      stop: null
    },
    _create: function () {
      var n, i, handle, axis, hname, that = this, o = this.options;
      this.element.addClass('ui-resizable');
      $.extend(this, {
        _aspectRatio: !!o.aspectRatio,
        aspectRatio: o.aspectRatio,
        originalElement: this.element,
        _proportionallyResizeElements: [],
        _helper: o.helper || o.ghost || o.animate ? o.helper || 'ui-resizable-helper' : null
      });
      //Wrap the element if it cannot hold child nodes
      if (this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {
        //Create a wrapper element and set the wrapper to the new current internal element
        this.element.wrap($('<div class=\'ui-wrapper\' style=\'overflow: hidden;\'></div>').css({
          position: this.element.css('position'),
          width: this.element.outerWidth(),
          height: this.element.outerHeight(),
          top: this.element.css('top'),
          left: this.element.css('left')
        }));
        //Overwrite the original this.element
        this.element = this.element.parent().data('ui-resizable', this.element.data('ui-resizable'));
        this.elementIsWrapper = true;
        //Move margins to the wrapper
        this.element.css({
          marginLeft: this.originalElement.css('marginLeft'),
          marginTop: this.originalElement.css('marginTop'),
          marginRight: this.originalElement.css('marginRight'),
          marginBottom: this.originalElement.css('marginBottom')
        });
        this.originalElement.css({
          marginLeft: 0,
          marginTop: 0,
          marginRight: 0,
          marginBottom: 0
        });
        //Prevent Safari textarea resize
        this.originalResizeStyle = this.originalElement.css('resize');
        this.originalElement.css('resize', 'none');
        //Push the actual element to our proportionallyResize internal array
        this._proportionallyResizeElements.push(this.originalElement.css({
          position: 'static',
          zoom: 1,
          display: 'block'
        }));
        // avoid IE jump (hard set the margin)
        this.originalElement.css({ margin: this.originalElement.css('margin') });
        // fix handlers offset
        this._proportionallyResize();
      }
      this.handles = o.handles || (!$('.ui-resizable-handle', this.element).length ? 'e,s,se' : {
        n: '.ui-resizable-n',
        e: '.ui-resizable-e',
        s: '.ui-resizable-s',
        w: '.ui-resizable-w',
        se: '.ui-resizable-se',
        sw: '.ui-resizable-sw',
        ne: '.ui-resizable-ne',
        nw: '.ui-resizable-nw'
      });
      if (this.handles.constructor === String) {
        if (this.handles === 'all') {
          this.handles = 'n,e,s,w,se,sw,ne,nw';
        }
        n = this.handles.split(',');
        this.handles = {};
        for (i = 0; i < n.length; i++) {
          handle = $.trim(n[i]);
          hname = 'ui-resizable-' + handle;
          axis = $('<div class=\'ui-resizable-handle ' + hname + '\'></div>');
          // Apply zIndex to all handles - see #7960
          axis.css({ zIndex: o.zIndex });
          //TODO : What's going on here?
          if ('se' === handle) {
            axis.addClass('ui-icon ui-icon-gripsmall-diagonal-se');
          }
          //Insert into internal handles object and append to element
          this.handles[handle] = '.ui-resizable-' + handle;
          this.element.append(axis);
        }
      }
      this._renderAxis = function (target) {
        var i, axis, padPos, padWrapper;
        target = target || this.element;
        for (i in this.handles) {
          if (this.handles[i].constructor === String) {
            this.handles[i] = $(this.handles[i], this.element).show();
          }
          //Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
          if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {
            axis = $(this.handles[i], this.element);
            //Checking the correct pad and border
            padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();
            //The padding type i have to apply...
            padPos = [
              'padding',
              /ne|nw|n/.test(i) ? 'Top' : /se|sw|s/.test(i) ? 'Bottom' : /^e$/.test(i) ? 'Right' : 'Left'
            ].join('');
            target.css(padPos, padWrapper);
            this._proportionallyResize();
          }
          //TODO: What's that good for? There's not anything to be executed left
          if (!$(this.handles[i]).length) {
            continue;
          }
        }
      };
      //TODO: make renderAxis a prototype function
      this._renderAxis(this.element);
      this._handles = $('.ui-resizable-handle', this.element).disableSelection();
      //Matching axis name
      this._handles.mouseover(function () {
        if (!that.resizing) {
          if (this.className) {
            axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
          }
          //Axis, default = se
          that.axis = axis && axis[1] ? axis[1] : 'se';
        }
      });
      //If we want to auto hide the elements
      if (o.autoHide) {
        this._handles.hide();
        $(this.element).addClass('ui-resizable-autohide').mouseenter(function () {
          if (o.disabled) {
            return;
          }
          $(this).removeClass('ui-resizable-autohide');
          that._handles.show();
        }).mouseleave(function () {
          if (o.disabled) {
            return;
          }
          if (!that.resizing) {
            $(this).addClass('ui-resizable-autohide');
            that._handles.hide();
          }
        });
      }
      //Initialize the mouse interaction
      this._mouseInit();
    },
    _destroy: function () {
      this._mouseDestroy();
      var wrapper, _destroy = function (exp) {
          $(exp).removeClass('ui-resizable ui-resizable-disabled ui-resizable-resizing').removeData('resizable').removeData('ui-resizable').unbind('.resizable').find('.ui-resizable-handle').remove();
        };
      //TODO: Unwrap at same DOM position
      if (this.elementIsWrapper) {
        _destroy(this.element);
        wrapper = this.element;
        this.originalElement.css({
          position: wrapper.css('position'),
          width: wrapper.outerWidth(),
          height: wrapper.outerHeight(),
          top: wrapper.css('top'),
          left: wrapper.css('left')
        }).insertAfter(wrapper);
        wrapper.remove();
      }
      this.originalElement.css('resize', this.originalResizeStyle);
      _destroy(this.originalElement);
      return this;
    },
    _mouseCapture: function (event) {
      var i, handle, capture = false;
      for (i in this.handles) {
        handle = $(this.handles[i])[0];
        if (handle === event.target || $.contains(handle, event.target)) {
          capture = true;
        }
      }
      return !this.options.disabled && capture;
    },
    _mouseStart: function (event) {
      var curleft, curtop, cursor, o = this.options, iniPos = this.element.position(), el = this.element;
      this.resizing = true;
      // bugfix for http://dev.jquery.com/ticket/1749
      if (/absolute/.test(el.css('position'))) {
        el.css({
          position: 'absolute',
          top: el.css('top'),
          left: el.css('left')
        });
      } else if (el.is('.ui-draggable')) {
        el.css({
          position: 'absolute',
          top: iniPos.top,
          left: iniPos.left
        });
      }
      this._renderProxy();
      curleft = num(this.helper.css('left'));
      curtop = num(this.helper.css('top'));
      if (o.containment) {
        curleft += $(o.containment).scrollLeft() || 0;
        curtop += $(o.containment).scrollTop() || 0;
      }
      //Store needed variables
      this.offset = this.helper.offset();
      this.position = {
        left: curleft,
        top: curtop
      };
      this.size = this._helper ? {
        width: el.outerWidth(),
        height: el.outerHeight()
      } : {
        width: el.width(),
        height: el.height()
      };
      this.originalSize = this._helper ? {
        width: el.outerWidth(),
        height: el.outerHeight()
      } : {
        width: el.width(),
        height: el.height()
      };
      this.originalPosition = {
        left: curleft,
        top: curtop
      };
      this.sizeDiff = {
        width: el.outerWidth() - el.width(),
        height: el.outerHeight() - el.height()
      };
      this.originalMousePosition = {
        left: event.pageX,
        top: event.pageY
      };
      //Aspect Ratio
      this.aspectRatio = typeof o.aspectRatio === 'number' ? o.aspectRatio : this.originalSize.width / this.originalSize.height || 1;
      cursor = $('.ui-resizable-' + this.axis).css('cursor');
      $('body').css('cursor', cursor === 'auto' ? this.axis + '-resize' : cursor);
      el.addClass('ui-resizable-resizing');
      this._propagate('start', event);
      return true;
    },
    _mouseDrag: function (event) {
      //Increase performance, avoid regex
      var data, el = this.helper, props = {}, smp = this.originalMousePosition, a = this.axis, prevTop = this.position.top, prevLeft = this.position.left, prevWidth = this.size.width, prevHeight = this.size.height, dx = event.pageX - smp.left || 0, dy = event.pageY - smp.top || 0, trigger = this._change[a];
      if (!trigger) {
        return false;
      }
      // Calculate the attrs that will be change
      data = trigger.apply(this, [
        event,
        dx,
        dy
      ]);
      // Put this in the mouseDrag handler since the user can start pressing shift while resizing
      this._updateVirtualBoundaries(event.shiftKey);
      if (this._aspectRatio || event.shiftKey) {
        data = this._updateRatio(data, event);
      }
      data = this._respectSize(data, event);
      this._updateCache(data);
      // plugins callbacks need to be called first
      this._propagate('resize', event);
      if (this.position.top !== prevTop) {
        props.top = this.position.top + 'px';
      }
      if (this.position.left !== prevLeft) {
        props.left = this.position.left + 'px';
      }
      if (this.size.width !== prevWidth) {
        props.width = this.size.width + 'px';
      }
      if (this.size.height !== prevHeight) {
        props.height = this.size.height + 'px';
      }
      el.css(props);
      if (!this._helper && this._proportionallyResizeElements.length) {
        this._proportionallyResize();
      }
      // Call the user callback if the element was resized
      if (!$.isEmptyObject(props)) {
        this._trigger('resize', event, this.ui());
      }
      return false;
    },
    _mouseStop: function (event) {
      this.resizing = false;
      var pr, ista, soffseth, soffsetw, s, left, top, o = this.options, that = this;
      if (this._helper) {
        pr = this._proportionallyResizeElements;
        ista = pr.length && /textarea/i.test(pr[0].nodeName);
        soffseth = ista && $.ui.hasScroll(pr[0], 'left') ? 0 : that.sizeDiff.height;
        soffsetw = ista ? 0 : that.sizeDiff.width;
        s = {
          width: that.helper.width() - soffsetw,
          height: that.helper.height() - soffseth
        };
        left = parseInt(that.element.css('left'), 10) + (that.position.left - that.originalPosition.left) || null;
        top = parseInt(that.element.css('top'), 10) + (that.position.top - that.originalPosition.top) || null;
        if (!o.animate) {
          this.element.css($.extend(s, {
            top: top,
            left: left
          }));
        }
        that.helper.height(that.size.height);
        that.helper.width(that.size.width);
        if (this._helper && !o.animate) {
          this._proportionallyResize();
        }
      }
      $('body').css('cursor', 'auto');
      this.element.removeClass('ui-resizable-resizing');
      this._propagate('stop', event);
      if (this._helper) {
        this.helper.remove();
      }
      return false;
    },
    _updateVirtualBoundaries: function (forceAspectRatio) {
      var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b, o = this.options;
      b = {
        minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
        maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
        minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
        maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
      };
      if (this._aspectRatio || forceAspectRatio) {
        // We want to create an enclosing box whose aspect ration is the requested one
        // First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
        pMinWidth = b.minHeight * this.aspectRatio;
        pMinHeight = b.minWidth / this.aspectRatio;
        pMaxWidth = b.maxHeight * this.aspectRatio;
        pMaxHeight = b.maxWidth / this.aspectRatio;
        if (pMinWidth > b.minWidth) {
          b.minWidth = pMinWidth;
        }
        if (pMinHeight > b.minHeight) {
          b.minHeight = pMinHeight;
        }
        if (pMaxWidth < b.maxWidth) {
          b.maxWidth = pMaxWidth;
        }
        if (pMaxHeight < b.maxHeight) {
          b.maxHeight = pMaxHeight;
        }
      }
      this._vBoundaries = b;
    },
    _updateCache: function (data) {
      this.offset = this.helper.offset();
      if (isNumber(data.left)) {
        this.position.left = data.left;
      }
      if (isNumber(data.top)) {
        this.position.top = data.top;
      }
      if (isNumber(data.height)) {
        this.size.height = data.height;
      }
      if (isNumber(data.width)) {
        this.size.width = data.width;
      }
    },
    _updateRatio: function (data) {
      var cpos = this.position, csize = this.size, a = this.axis;
      if (isNumber(data.height)) {
        data.width = data.height * this.aspectRatio;
      } else if (isNumber(data.width)) {
        data.height = data.width / this.aspectRatio;
      }
      if (a === 'sw') {
        data.left = cpos.left + (csize.width - data.width);
        data.top = null;
      }
      if (a === 'nw') {
        data.top = cpos.top + (csize.height - data.height);
        data.left = cpos.left + (csize.width - data.width);
      }
      return data;
    },
    _respectSize: function (data) {
      var o = this._vBoundaries, a = this.axis, ismaxw = isNumber(data.width) && o.maxWidth && o.maxWidth < data.width, ismaxh = isNumber(data.height) && o.maxHeight && o.maxHeight < data.height, isminw = isNumber(data.width) && o.minWidth && o.minWidth > data.width, isminh = isNumber(data.height) && o.minHeight && o.minHeight > data.height, dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height, cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);
      if (isminw) {
        data.width = o.minWidth;
      }
      if (isminh) {
        data.height = o.minHeight;
      }
      if (ismaxw) {
        data.width = o.maxWidth;
      }
      if (ismaxh) {
        data.height = o.maxHeight;
      }
      if (isminw && cw) {
        data.left = dw - o.minWidth;
      }
      if (ismaxw && cw) {
        data.left = dw - o.maxWidth;
      }
      if (isminh && ch) {
        data.top = dh - o.minHeight;
      }
      if (ismaxh && ch) {
        data.top = dh - o.maxHeight;
      }
      // fixing jump error on top/left - bug #2330
      if (!data.width && !data.height && !data.left && data.top) {
        data.top = null;
      } else if (!data.width && !data.height && !data.top && data.left) {
        data.left = null;
      }
      return data;
    },
    _proportionallyResize: function () {
      if (!this._proportionallyResizeElements.length) {
        return;
      }
      var i, j, borders, paddings, prel, element = this.helper || this.element;
      for (i = 0; i < this._proportionallyResizeElements.length; i++) {
        prel = this._proportionallyResizeElements[i];
        if (!this.borderDif) {
          this.borderDif = [];
          borders = [
            prel.css('borderTopWidth'),
            prel.css('borderRightWidth'),
            prel.css('borderBottomWidth'),
            prel.css('borderLeftWidth')
          ];
          paddings = [
            prel.css('paddingTop'),
            prel.css('paddingRight'),
            prel.css('paddingBottom'),
            prel.css('paddingLeft')
          ];
          for (j = 0; j < borders.length; j++) {
            this.borderDif[j] = (parseInt(borders[j], 10) || 0) + (parseInt(paddings[j], 10) || 0);
          }
        }
        prel.css({
          height: element.height() - this.borderDif[0] - this.borderDif[2] || 0,
          width: element.width() - this.borderDif[1] - this.borderDif[3] || 0
        });
      }
    },
    _renderProxy: function () {
      var el = this.element, o = this.options;
      this.elementOffset = el.offset();
      if (this._helper) {
        this.helper = this.helper || $('<div style=\'overflow:hidden;\'></div>');
        this.helper.addClass(this._helper).css({
          width: this.element.outerWidth() - 1,
          height: this.element.outerHeight() - 1,
          position: 'absolute',
          left: this.elementOffset.left + 'px',
          top: this.elementOffset.top + 'px',
          zIndex: ++o.zIndex
        });
        this.helper.appendTo('body').disableSelection();
      } else {
        this.helper = this.element;
      }
    },
    _change: {
      e: function (event, dx) {
        return { width: this.originalSize.width + dx };
      },
      w: function (event, dx) {
        var cs = this.originalSize, sp = this.originalPosition;
        return {
          left: sp.left + dx,
          width: cs.width - dx
        };
      },
      n: function (event, dx, dy) {
        var cs = this.originalSize, sp = this.originalPosition;
        return {
          top: sp.top + dy,
          height: cs.height - dy
        };
      },
      s: function (event, dx, dy) {
        return { height: this.originalSize.height + dy };
      },
      se: function (event, dx, dy) {
        return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [
          event,
          dx,
          dy
        ]));
      },
      sw: function (event, dx, dy) {
        return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [
          event,
          dx,
          dy
        ]));
      },
      ne: function (event, dx, dy) {
        return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [
          event,
          dx,
          dy
        ]));
      },
      nw: function (event, dx, dy) {
        return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [
          event,
          dx,
          dy
        ]));
      }
    },
    _propagate: function (n, event) {
      $.ui.plugin.call(this, n, [
        event,
        this.ui()
      ]);
      n !== 'resize' && this._trigger(n, event, this.ui());
    },
    plugins: {},
    ui: function () {
      return {
        originalElement: this.originalElement,
        element: this.element,
        helper: this.helper,
        position: this.position,
        size: this.size,
        originalSize: this.originalSize,
        originalPosition: this.originalPosition
      };
    }
  });
  /*
 * Resizable Extensions
 */
  $.ui.plugin.add('resizable', 'animate', {
    stop: function (event) {
      var that = $(this).data('ui-resizable'), o = that.options, pr = that._proportionallyResizeElements, ista = pr.length && /textarea/i.test(pr[0].nodeName), soffseth = ista && $.ui.hasScroll(pr[0], 'left') ? 0 : that.sizeDiff.height, soffsetw = ista ? 0 : that.sizeDiff.width, style = {
          width: that.size.width - soffsetw,
          height: that.size.height - soffseth
        }, left = parseInt(that.element.css('left'), 10) + (that.position.left - that.originalPosition.left) || null, top = parseInt(that.element.css('top'), 10) + (that.position.top - that.originalPosition.top) || null;
      that.element.animate($.extend(style, top && left ? {
        top: top,
        left: left
      } : {}), {
        duration: o.animateDuration,
        easing: o.animateEasing,
        step: function () {
          var data = {
              width: parseInt(that.element.css('width'), 10),
              height: parseInt(that.element.css('height'), 10),
              top: parseInt(that.element.css('top'), 10),
              left: parseInt(that.element.css('left'), 10)
            };
          if (pr && pr.length) {
            $(pr[0]).css({
              width: data.width,
              height: data.height
            });
          }
          // propagating resize, and updating values for each animation step
          that._updateCache(data);
          that._propagate('resize', event);
        }
      });
    }
  });
  $.ui.plugin.add('resizable', 'containment', {
    start: function () {
      var element, p, co, ch, cw, width, height, that = $(this).data('ui-resizable'), o = that.options, el = that.element, oc = o.containment, ce = oc instanceof $ ? oc.get(0) : /parent/.test(oc) ? el.parent().get(0) : oc;
      if (!ce) {
        return;
      }
      that.containerElement = $(ce);
      if (/document/.test(oc) || oc === document) {
        that.containerOffset = {
          left: 0,
          top: 0
        };
        that.containerPosition = {
          left: 0,
          top: 0
        };
        that.parentData = {
          element: $(document),
          left: 0,
          top: 0,
          width: $(document).width(),
          height: $(document).height() || document.body.parentNode.scrollHeight
        };
      }  // i'm a node, so compute top, left, right, bottom
      else {
        element = $(ce);
        p = [];
        $([
          'Top',
          'Right',
          'Left',
          'Bottom'
        ]).each(function (i, name) {
          p[i] = num(element.css('padding' + name));
        });
        that.containerOffset = element.offset();
        that.containerPosition = element.position();
        that.containerSize = {
          height: element.innerHeight() - p[3],
          width: element.innerWidth() - p[1]
        };
        co = that.containerOffset;
        ch = that.containerSize.height;
        cw = that.containerSize.width;
        width = $.ui.hasScroll(ce, 'left') ? ce.scrollWidth : cw;
        height = $.ui.hasScroll(ce) ? ce.scrollHeight : ch;
        that.parentData = {
          element: ce,
          left: co.left,
          top: co.top,
          width: width,
          height: height
        };
      }
    },
    resize: function (event) {
      var woset, hoset, isParent, isOffsetRelative, that = $(this).data('ui-resizable'), o = that.options, co = that.containerOffset, cp = that.position, pRatio = that._aspectRatio || event.shiftKey, cop = {
          top: 0,
          left: 0
        }, ce = that.containerElement;
      if (ce[0] !== document && /static/.test(ce.css('position'))) {
        cop = co;
      }
      if (cp.left < (that._helper ? co.left : 0)) {
        that.size.width = that.size.width + (that._helper ? that.position.left - co.left : that.position.left - cop.left);
        if (pRatio) {
          that.size.height = that.size.width / that.aspectRatio;
        }
        that.position.left = o.helper ? co.left : 0;
      }
      if (cp.top < (that._helper ? co.top : 0)) {
        that.size.height = that.size.height + (that._helper ? that.position.top - co.top : that.position.top);
        if (pRatio) {
          that.size.width = that.size.height * that.aspectRatio;
        }
        that.position.top = that._helper ? co.top : 0;
      }
      that.offset.left = that.parentData.left + that.position.left;
      that.offset.top = that.parentData.top + that.position.top;
      woset = Math.abs((that._helper ? that.offset.left - cop.left : that.offset.left - cop.left) + that.sizeDiff.width);
      hoset = Math.abs((that._helper ? that.offset.top - cop.top : that.offset.top - co.top) + that.sizeDiff.height);
      isParent = that.containerElement.get(0) === that.element.parent().get(0);
      isOffsetRelative = /relative|absolute/.test(that.containerElement.css('position'));
      if (isParent && isOffsetRelative) {
        woset -= that.parentData.left;
      }
      if (woset + that.size.width >= that.parentData.width) {
        that.size.width = that.parentData.width - woset;
        if (pRatio) {
          that.size.height = that.size.width / that.aspectRatio;
        }
      }
      if (hoset + that.size.height >= that.parentData.height) {
        that.size.height = that.parentData.height - hoset;
        if (pRatio) {
          that.size.width = that.size.height * that.aspectRatio;
        }
      }
    },
    stop: function () {
      var that = $(this).data('ui-resizable'), o = that.options, co = that.containerOffset, cop = that.containerPosition, ce = that.containerElement, helper = $(that.helper), ho = helper.offset(), w = helper.outerWidth() - that.sizeDiff.width, h = helper.outerHeight() - that.sizeDiff.height;
      if (that._helper && !o.animate && /relative/.test(ce.css('position'))) {
        $(this).css({
          left: ho.left - cop.left - co.left,
          width: w,
          height: h
        });
      }
      if (that._helper && !o.animate && /static/.test(ce.css('position'))) {
        $(this).css({
          left: ho.left - cop.left - co.left,
          width: w,
          height: h
        });
      }
    }
  });
  $.ui.plugin.add('resizable', 'alsoResize', {
    start: function () {
      var that = $(this).data('ui-resizable'), o = that.options, _store = function (exp) {
          $(exp).each(function () {
            var el = $(this);
            el.data('ui-resizable-alsoresize', {
              width: parseInt(el.width(), 10),
              height: parseInt(el.height(), 10),
              left: parseInt(el.css('left'), 10),
              top: parseInt(el.css('top'), 10)
            });
          });
        };
      if (typeof o.alsoResize === 'object' && !o.alsoResize.parentNode) {
        if (o.alsoResize.length) {
          o.alsoResize = o.alsoResize[0];
          _store(o.alsoResize);
        } else {
          $.each(o.alsoResize, function (exp) {
            _store(exp);
          });
        }
      } else {
        _store(o.alsoResize);
      }
    },
    resize: function (event, ui) {
      var that = $(this).data('ui-resizable'), o = that.options, os = that.originalSize, op = that.originalPosition, delta = {
          height: that.size.height - os.height || 0,
          width: that.size.width - os.width || 0,
          top: that.position.top - op.top || 0,
          left: that.position.left - op.left || 0
        }, _alsoResize = function (exp, c) {
          $(exp).each(function () {
            var el = $(this), start = $(this).data('ui-resizable-alsoresize'), style = {}, css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? [
                'width',
                'height'
              ] : [
                'width',
                'height',
                'top',
                'left'
              ];
            $.each(css, function (i, prop) {
              var sum = (start[prop] || 0) + (delta[prop] || 0);
              if (sum && sum >= 0) {
                style[prop] = sum || null;
              }
            });
            el.css(style);
          });
        };
      if (typeof o.alsoResize === 'object' && !o.alsoResize.nodeType) {
        $.each(o.alsoResize, function (exp, c) {
          _alsoResize(exp, c);
        });
      } else {
        _alsoResize(o.alsoResize);
      }
    },
    stop: function () {
      $(this).removeData('resizable-alsoresize');
    }
  });
  $.ui.plugin.add('resizable', 'ghost', {
    start: function () {
      var that = $(this).data('ui-resizable'), o = that.options, cs = that.size;
      that.ghost = that.originalElement.clone();
      that.ghost.css({
        opacity: 0.25,
        display: 'block',
        position: 'relative',
        height: cs.height,
        width: cs.width,
        margin: 0,
        left: 0,
        top: 0
      }).addClass('ui-resizable-ghost').addClass(typeof o.ghost === 'string' ? o.ghost : '');
      that.ghost.appendTo(that.helper);
    },
    resize: function () {
      var that = $(this).data('ui-resizable');
      if (that.ghost) {
        that.ghost.css({
          position: 'relative',
          height: that.size.height,
          width: that.size.width
        });
      }
    },
    stop: function () {
      var that = $(this).data('ui-resizable');
      if (that.ghost && that.helper) {
        that.helper.get(0).removeChild(that.ghost.get(0));
      }
    }
  });
  $.ui.plugin.add('resizable', 'grid', {
    resize: function () {
      var that = $(this).data('ui-resizable'), o = that.options, cs = that.size, os = that.originalSize, op = that.originalPosition, a = that.axis, grid = typeof o.grid === 'number' ? [
          o.grid,
          o.grid
        ] : o.grid, gridX = grid[0] || 1, gridY = grid[1] || 1, ox = Math.round((cs.width - os.width) / gridX) * gridX, oy = Math.round((cs.height - os.height) / gridY) * gridY, newWidth = os.width + ox, newHeight = os.height + oy, isMaxWidth = o.maxWidth && o.maxWidth < newWidth, isMaxHeight = o.maxHeight && o.maxHeight < newHeight, isMinWidth = o.minWidth && o.minWidth > newWidth, isMinHeight = o.minHeight && o.minHeight > newHeight;
      o.grid = grid;
      if (isMinWidth) {
        newWidth = newWidth + gridX;
      }
      if (isMinHeight) {
        newHeight = newHeight + gridY;
      }
      if (isMaxWidth) {
        newWidth = newWidth - gridX;
      }
      if (isMaxHeight) {
        newHeight = newHeight - gridY;
      }
      if (/^(se|s|e)$/.test(a)) {
        that.size.width = newWidth;
        that.size.height = newHeight;
      } else if (/^(ne)$/.test(a)) {
        that.size.width = newWidth;
        that.size.height = newHeight;
        that.position.top = op.top - oy;
      } else if (/^(sw)$/.test(a)) {
        that.size.width = newWidth;
        that.size.height = newHeight;
        that.position.left = op.left - ox;
      } else {
        that.size.width = newWidth;
        that.size.height = newHeight;
        that.position.top = op.top - oy;
        that.position.left = op.left - ox;
      }
    }
  });
}(jQuery));
(function ($, undefined) {
  $.widget('ui.selectable', $.ui.mouse, {
    version: '1.10.3',
    options: {
      appendTo: 'body',
      autoRefresh: true,
      distance: 0,
      filter: '*',
      tolerance: 'touch',
      selected: null,
      selecting: null,
      start: null,
      stop: null,
      unselected: null,
      unselecting: null
    },
    _create: function () {
      var selectees, that = this;
      this.element.addClass('ui-selectable');
      this.dragged = false;
      // cache selectee children based on filter
      this.refresh = function () {
        selectees = $(that.options.filter, that.element[0]);
        selectees.addClass('ui-selectee');
        selectees.each(function () {
          var $this = $(this), pos = $this.offset();
          $.data(this, 'selectable-item', {
            element: this,
            $element: $this,
            left: pos.left,
            top: pos.top,
            right: pos.left + $this.outerWidth(),
            bottom: pos.top + $this.outerHeight(),
            startselected: false,
            selected: $this.hasClass('ui-selected'),
            selecting: $this.hasClass('ui-selecting'),
            unselecting: $this.hasClass('ui-unselecting')
          });
        });
      };
      this.refresh();
      this.selectees = selectees.addClass('ui-selectee');
      this._mouseInit();
      this.helper = $('<div class=\'ui-selectable-helper\'></div>');
    },
    _destroy: function () {
      this.selectees.removeClass('ui-selectee').removeData('selectable-item');
      this.element.removeClass('ui-selectable ui-selectable-disabled');
      this._mouseDestroy();
    },
    _mouseStart: function (event) {
      var that = this, options = this.options;
      this.opos = [
        event.pageX,
        event.pageY
      ];
      if (this.options.disabled) {
        return;
      }
      this.selectees = $(options.filter, this.element[0]);
      this._trigger('start', event);
      $(options.appendTo).append(this.helper);
      // position helper (lasso)
      this.helper.css({
        'left': event.pageX,
        'top': event.pageY,
        'width': 0,
        'height': 0
      });
      if (options.autoRefresh) {
        this.refresh();
      }
      this.selectees.filter('.ui-selected').each(function () {
        var selectee = $.data(this, 'selectable-item');
        selectee.startselected = true;
        if (!event.metaKey && !event.ctrlKey) {
          selectee.$element.removeClass('ui-selected');
          selectee.selected = false;
          selectee.$element.addClass('ui-unselecting');
          selectee.unselecting = true;
          // selectable UNSELECTING callback
          that._trigger('unselecting', event, { unselecting: selectee.element });
        }
      });
      $(event.target).parents().addBack().each(function () {
        var doSelect, selectee = $.data(this, 'selectable-item');
        if (selectee) {
          doSelect = !event.metaKey && !event.ctrlKey || !selectee.$element.hasClass('ui-selected');
          selectee.$element.removeClass(doSelect ? 'ui-unselecting' : 'ui-selected').addClass(doSelect ? 'ui-selecting' : 'ui-unselecting');
          selectee.unselecting = !doSelect;
          selectee.selecting = doSelect;
          selectee.selected = doSelect;
          // selectable (UN)SELECTING callback
          if (doSelect) {
            that._trigger('selecting', event, { selecting: selectee.element });
          } else {
            that._trigger('unselecting', event, { unselecting: selectee.element });
          }
          return false;
        }
      });
    },
    _mouseDrag: function (event) {
      this.dragged = true;
      if (this.options.disabled) {
        return;
      }
      var tmp, that = this, options = this.options, x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
      if (x1 > x2) {
        tmp = x2;
        x2 = x1;
        x1 = tmp;
      }
      if (y1 > y2) {
        tmp = y2;
        y2 = y1;
        y1 = tmp;
      }
      this.helper.css({
        left: x1,
        top: y1,
        width: x2 - x1,
        height: y2 - y1
      });
      this.selectees.each(function () {
        var selectee = $.data(this, 'selectable-item'), hit = false;
        //prevent helper from being selected if appendTo: selectable
        if (!selectee || selectee.element === that.element[0]) {
          return;
        }
        if (options.tolerance === 'touch') {
          hit = !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1);
        } else if (options.tolerance === 'fit') {
          hit = selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2;
        }
        if (hit) {
          // SELECT
          if (selectee.selected) {
            selectee.$element.removeClass('ui-selected');
            selectee.selected = false;
          }
          if (selectee.unselecting) {
            selectee.$element.removeClass('ui-unselecting');
            selectee.unselecting = false;
          }
          if (!selectee.selecting) {
            selectee.$element.addClass('ui-selecting');
            selectee.selecting = true;
            // selectable SELECTING callback
            that._trigger('selecting', event, { selecting: selectee.element });
          }
        } else {
          // UNSELECT
          if (selectee.selecting) {
            if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
              selectee.$element.removeClass('ui-selecting');
              selectee.selecting = false;
              selectee.$element.addClass('ui-selected');
              selectee.selected = true;
            } else {
              selectee.$element.removeClass('ui-selecting');
              selectee.selecting = false;
              if (selectee.startselected) {
                selectee.$element.addClass('ui-unselecting');
                selectee.unselecting = true;
              }
              // selectable UNSELECTING callback
              that._trigger('unselecting', event, { unselecting: selectee.element });
            }
          }
          if (selectee.selected) {
            if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
              selectee.$element.removeClass('ui-selected');
              selectee.selected = false;
              selectee.$element.addClass('ui-unselecting');
              selectee.unselecting = true;
              // selectable UNSELECTING callback
              that._trigger('unselecting', event, { unselecting: selectee.element });
            }
          }
        }
      });
      return false;
    },
    _mouseStop: function (event) {
      var that = this;
      this.dragged = false;
      $('.ui-unselecting', this.element[0]).each(function () {
        var selectee = $.data(this, 'selectable-item');
        selectee.$element.removeClass('ui-unselecting');
        selectee.unselecting = false;
        selectee.startselected = false;
        that._trigger('unselected', event, { unselected: selectee.element });
      });
      $('.ui-selecting', this.element[0]).each(function () {
        var selectee = $.data(this, 'selectable-item');
        selectee.$element.removeClass('ui-selecting').addClass('ui-selected');
        selectee.selecting = false;
        selectee.selected = true;
        selectee.startselected = true;
        that._trigger('selected', event, { selected: selectee.element });
      });
      this._trigger('stop', event);
      this.helper.remove();
      return false;
    }
  });
}(jQuery));
(function ($, undefined) {
  /*jshint loopfunc: true */
  function isOverAxis(x, reference, size) {
    return x > reference && x < reference + size;
  }
  function isFloating(item) {
    return /left|right/.test(item.css('float')) || /inline|table-cell/.test(item.css('display'));
  }
  $.widget('ui.sortable', $.ui.mouse, {
    version: '1.10.3',
    widgetEventPrefix: 'sort',
    ready: false,
    options: {
      appendTo: 'parent',
      axis: false,
      connectWith: false,
      containment: false,
      cursor: 'auto',
      cursorAt: false,
      dropOnEmpty: true,
      forcePlaceholderSize: false,
      forceHelperSize: false,
      grid: false,
      handle: false,
      helper: 'original',
      items: '> *',
      opacity: false,
      placeholder: false,
      revert: false,
      scroll: true,
      scrollSensitivity: 20,
      scrollSpeed: 20,
      scope: 'default',
      tolerance: 'intersect',
      zIndex: 1000,
      activate: null,
      beforeStop: null,
      change: null,
      deactivate: null,
      out: null,
      over: null,
      receive: null,
      remove: null,
      sort: null,
      start: null,
      stop: null,
      update: null
    },
    _create: function () {
      var o = this.options;
      this.containerCache = {};
      this.element.addClass('ui-sortable');
      //Get the items
      this.refresh();
      //Let's determine if the items are being displayed horizontally
      this.floating = this.items.length ? o.axis === 'x' || isFloating(this.items[0].item) : false;
      //Let's determine the parent's offset
      this.offset = this.element.offset();
      //Initialize mouse events for interaction
      this._mouseInit();
      //We're ready to go
      this.ready = true;
    },
    _destroy: function () {
      this.element.removeClass('ui-sortable ui-sortable-disabled');
      this._mouseDestroy();
      for (var i = this.items.length - 1; i >= 0; i--) {
        this.items[i].item.removeData(this.widgetName + '-item');
      }
      return this;
    },
    _setOption: function (key, value) {
      if (key === 'disabled') {
        this.options[key] = value;
        this.widget().toggleClass('ui-sortable-disabled', !!value);
      } else {
        // Don't call widget base _setOption for disable as it adds ui-state-disabled class
        $.Widget.prototype._setOption.apply(this, arguments);
      }
    },
    _mouseCapture: function (event, overrideHandle) {
      var currentItem = null, validHandle = false, that = this;
      if (this.reverting) {
        return false;
      }
      if (this.options.disabled || this.options.type === 'static') {
        return false;
      }
      //We have to refresh the items data once first
      this._refreshItems(event);
      //Find out if the clicked node (or one of its parents) is a actual item in this.items
      $(event.target).parents().each(function () {
        if ($.data(this, that.widgetName + '-item') === that) {
          currentItem = $(this);
          return false;
        }
      });
      if ($.data(event.target, that.widgetName + '-item') === that) {
        currentItem = $(event.target);
      }
      if (!currentItem) {
        return false;
      }
      if (this.options.handle && !overrideHandle) {
        $(this.options.handle, currentItem).find('*').addBack().each(function () {
          if (this === event.target) {
            validHandle = true;
          }
        });
        if (!validHandle) {
          return false;
        }
      }
      this.currentItem = currentItem;
      this._removeCurrentsFromItems();
      return true;
    },
    _mouseStart: function (event, overrideHandle, noActivation) {
      var i, body, o = this.options;
      this.currentContainer = this;
      //We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
      this.refreshPositions();
      //Create and append the visible helper
      this.helper = this._createHelper(event);
      //Cache the helper size
      this._cacheHelperProportions();
      /*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */
      //Cache the margins of the original element
      this._cacheMargins();
      //Get the next scrolling parent
      this.scrollParent = this.helper.scrollParent();
      //The element's absolute position on the page minus margins
      this.offset = this.currentItem.offset();
      this.offset = {
        top: this.offset.top - this.margins.top,
        left: this.offset.left - this.margins.left
      };
      $.extend(this.offset, {
        click: {
          left: event.pageX - this.offset.left,
          top: event.pageY - this.offset.top
        },
        parent: this._getParentOffset(),
        relative: this._getRelativeOffset()
      });
      // Only after we got the offset, we can change the helper's position to absolute
      // TODO: Still need to figure out a way to make relative sorting possible
      this.helper.css('position', 'absolute');
      this.cssPosition = this.helper.css('position');
      //Generate the original position
      this.originalPosition = this._generatePosition(event);
      this.originalPageX = event.pageX;
      this.originalPageY = event.pageY;
      //Adjust the mouse offset relative to the helper if "cursorAt" is supplied
      o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt);
      //Cache the former DOM position
      this.domPosition = {
        prev: this.currentItem.prev()[0],
        parent: this.currentItem.parent()[0]
      };
      //If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
      if (this.helper[0] !== this.currentItem[0]) {
        this.currentItem.hide();
      }
      //Create the placeholder
      this._createPlaceholder();
      //Set a containment if given in the options
      if (o.containment) {
        this._setContainment();
      }
      if (o.cursor && o.cursor !== 'auto') {
        // cursor option
        body = this.document.find('body');
        // support: IE
        this.storedCursor = body.css('cursor');
        body.css('cursor', o.cursor);
        this.storedStylesheet = $('<style>*{ cursor: ' + o.cursor + ' !important; }</style>').appendTo(body);
      }
      if (o.opacity) {
        // opacity option
        if (this.helper.css('opacity')) {
          this._storedOpacity = this.helper.css('opacity');
        }
        this.helper.css('opacity', o.opacity);
      }
      if (o.zIndex) {
        // zIndex option
        if (this.helper.css('zIndex')) {
          this._storedZIndex = this.helper.css('zIndex');
        }
        this.helper.css('zIndex', o.zIndex);
      }
      //Prepare scrolling
      if (this.scrollParent[0] !== document && this.scrollParent[0].tagName !== 'HTML') {
        this.overflowOffset = this.scrollParent.offset();
      }
      //Call callbacks
      this._trigger('start', event, this._uiHash());
      //Recache the helper size
      if (!this._preserveHelperProportions) {
        this._cacheHelperProportions();
      }
      //Post "activate" events to possible containers
      if (!noActivation) {
        for (i = this.containers.length - 1; i >= 0; i--) {
          this.containers[i]._trigger('activate', event, this._uiHash(this));
        }
      }
      //Prepare possible droppables
      if ($.ui.ddmanager) {
        $.ui.ddmanager.current = this;
      }
      if ($.ui.ddmanager && !o.dropBehaviour) {
        $.ui.ddmanager.prepareOffsets(this, event);
      }
      this.dragging = true;
      this.helper.addClass('ui-sortable-helper');
      this._mouseDrag(event);
      //Execute the drag once - this causes the helper not to be visible before getting its correct position
      return true;
    },
    _mouseDrag: function (event) {
      var i, item, itemElement, intersection, o = this.options, scrolled = false;
      //Compute the helpers position
      this.position = this._generatePosition(event);
      this.positionAbs = this._convertPositionTo('absolute');
      if (!this.lastPositionAbs) {
        this.lastPositionAbs = this.positionAbs;
      }
      //Do scrolling
      if (this.options.scroll) {
        if (this.scrollParent[0] !== document && this.scrollParent[0].tagName !== 'HTML') {
          if (this.overflowOffset.top + this.scrollParent[0].offsetHeight - event.pageY < o.scrollSensitivity) {
            this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
          } else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
            this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
          }
          if (this.overflowOffset.left + this.scrollParent[0].offsetWidth - event.pageX < o.scrollSensitivity) {
            this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
          } else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
            this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
          }
        } else {
          if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
            scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
          } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
            scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
          }
          if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
            scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
          } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
            scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
          }
        }
        if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
          $.ui.ddmanager.prepareOffsets(this, event);
        }
      }
      //Regenerate the absolute position used for position checks
      this.positionAbs = this._convertPositionTo('absolute');
      //Set the helper position
      if (!this.options.axis || this.options.axis !== 'y') {
        this.helper[0].style.left = this.position.left + 'px';
      }
      if (!this.options.axis || this.options.axis !== 'x') {
        this.helper[0].style.top = this.position.top + 'px';
      }
      //Rearrange
      for (i = this.items.length - 1; i >= 0; i--) {
        //Cache variables and intersection, continue if no intersection
        item = this.items[i];
        itemElement = item.item[0];
        intersection = this._intersectsWithPointer(item);
        if (!intersection) {
          continue;
        }
        // Only put the placeholder inside the current Container, skip all
        // items form other containers. This works because when moving
        // an item from one container to another the
        // currentContainer is switched before the placeholder is moved.
        //
        // Without this moving items in "sub-sortables" can cause the placeholder to jitter
        // beetween the outer and inner container.
        if (item.instance !== this.currentContainer) {
          continue;
        }
        // cannot intersect with itself
        // no useless actions that have been done before
        // no action if the item moved is the parent of the item checked
        if (itemElement !== this.currentItem[0] && this.placeholder[intersection === 1 ? 'next' : 'prev']()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && (this.options.type === 'semi-dynamic' ? !$.contains(this.element[0], itemElement) : true)) {
          this.direction = intersection === 1 ? 'down' : 'up';
          if (this.options.tolerance === 'pointer' || this._intersectsWithSides(item)) {
            this._rearrange(event, item);
          } else {
            break;
          }
          this._trigger('change', event, this._uiHash());
          break;
        }
      }
      //Post events to containers
      this._contactContainers(event);
      //Interconnect with droppables
      if ($.ui.ddmanager) {
        $.ui.ddmanager.drag(this, event);
      }
      //Call callbacks
      this._trigger('sort', event, this._uiHash());
      this.lastPositionAbs = this.positionAbs;
      return false;
    },
    _mouseStop: function (event, noPropagation) {
      if (!event) {
        return;
      }
      //If we are using droppables, inform the manager about the drop
      if ($.ui.ddmanager && !this.options.dropBehaviour) {
        $.ui.ddmanager.drop(this, event);
      }
      if (this.options.revert) {
        var that = this, cur = this.placeholder.offset(), axis = this.options.axis, animation = {};
        if (!axis || axis === 'x') {
          animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft);
        }
        if (!axis || axis === 'y') {
          animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop);
        }
        this.reverting = true;
        $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function () {
          that._clear(event);
        });
      } else {
        this._clear(event, noPropagation);
      }
      return false;
    },
    cancel: function () {
      if (this.dragging) {
        this._mouseUp({ target: null });
        if (this.options.helper === 'original') {
          this.currentItem.css(this._storedCSS).removeClass('ui-sortable-helper');
        } else {
          this.currentItem.show();
        }
        //Post deactivating events to containers
        for (var i = this.containers.length - 1; i >= 0; i--) {
          this.containers[i]._trigger('deactivate', null, this._uiHash(this));
          if (this.containers[i].containerCache.over) {
            this.containers[i]._trigger('out', null, this._uiHash(this));
            this.containers[i].containerCache.over = 0;
          }
        }
      }
      if (this.placeholder) {
        //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
        if (this.placeholder[0].parentNode) {
          this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
        }
        if (this.options.helper !== 'original' && this.helper && this.helper[0].parentNode) {
          this.helper.remove();
        }
        $.extend(this, {
          helper: null,
          dragging: false,
          reverting: false,
          _noFinalSort: null
        });
        if (this.domPosition.prev) {
          $(this.domPosition.prev).after(this.currentItem);
        } else {
          $(this.domPosition.parent).prepend(this.currentItem);
        }
      }
      return this;
    },
    serialize: function (o) {
      var items = this._getItemsAsjQuery(o && o.connected), str = [];
      o = o || {};
      $(items).each(function () {
        var res = ($(o.item || this).attr(o.attribute || 'id') || '').match(o.expression || /(.+)[\-=_](.+)/);
        if (res) {
          str.push((o.key || res[1] + '[]') + '=' + (o.key && o.expression ? res[1] : res[2]));
        }
      });
      if (!str.length && o.key) {
        str.push(o.key + '=');
      }
      return str.join('&');
    },
    toArray: function (o) {
      var items = this._getItemsAsjQuery(o && o.connected), ret = [];
      o = o || {};
      items.each(function () {
        ret.push($(o.item || this).attr(o.attribute || 'id') || '');
      });
      return ret;
    },
    _intersectsWith: function (item) {
      var x1 = this.positionAbs.left, x2 = x1 + this.helperProportions.width, y1 = this.positionAbs.top, y2 = y1 + this.helperProportions.height, l = item.left, r = l + item.width, t = item.top, b = t + item.height, dyClick = this.offset.click.top, dxClick = this.offset.click.left, isOverElementHeight = this.options.axis === 'x' || y1 + dyClick > t && y1 + dyClick < b, isOverElementWidth = this.options.axis === 'y' || x1 + dxClick > l && x1 + dxClick < r, isOverElement = isOverElementHeight && isOverElementWidth;
      if (this.options.tolerance === 'pointer' || this.options.forcePointerForContainers || this.options.tolerance !== 'pointer' && this.helperProportions[this.floating ? 'width' : 'height'] > item[this.floating ? 'width' : 'height']) {
        return isOverElement;
      } else {
        return l < x1 + this.helperProportions.width / 2 && x2 - this.helperProportions.width / 2 < r && t < y1 + this.helperProportions.height / 2 && y2 - this.helperProportions.height / 2 < b;  // Top Half
      }
    },
    _intersectsWithPointer: function (item) {
      var isOverElementHeight = this.options.axis === 'x' || isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height), isOverElementWidth = this.options.axis === 'y' || isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width), isOverElement = isOverElementHeight && isOverElementWidth, verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection();
      if (!isOverElement) {
        return false;
      }
      return this.floating ? horizontalDirection && horizontalDirection === 'right' || verticalDirection === 'down' ? 2 : 1 : verticalDirection && (verticalDirection === 'down' ? 2 : 1);
    },
    _intersectsWithSides: function (item) {
      var isOverBottomHalf = isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + item.height / 2, item.height), isOverRightHalf = isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + item.width / 2, item.width), verticalDirection = this._getDragVerticalDirection(), horizontalDirection = this._getDragHorizontalDirection();
      if (this.floating && horizontalDirection) {
        return horizontalDirection === 'right' && isOverRightHalf || horizontalDirection === 'left' && !isOverRightHalf;
      } else {
        return verticalDirection && (verticalDirection === 'down' && isOverBottomHalf || verticalDirection === 'up' && !isOverBottomHalf);
      }
    },
    _getDragVerticalDirection: function () {
      var delta = this.positionAbs.top - this.lastPositionAbs.top;
      return delta !== 0 && (delta > 0 ? 'down' : 'up');
    },
    _getDragHorizontalDirection: function () {
      var delta = this.positionAbs.left - this.lastPositionAbs.left;
      return delta !== 0 && (delta > 0 ? 'right' : 'left');
    },
    refresh: function (event) {
      this._refreshItems(event);
      this.refreshPositions();
      return this;
    },
    _connectWith: function () {
      var options = this.options;
      return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
    },
    _getItemsAsjQuery: function (connected) {
      var i, j, cur, inst, items = [], queries = [], connectWith = this._connectWith();
      if (connectWith && connected) {
        for (i = connectWith.length - 1; i >= 0; i--) {
          cur = $(connectWith[i]);
          for (j = cur.length - 1; j >= 0; j--) {
            inst = $.data(cur[j], this.widgetFullName);
            if (inst && inst !== this && !inst.options.disabled) {
              queries.push([
                $.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not('.ui-sortable-helper').not('.ui-sortable-placeholder'),
                inst
              ]);
            }
          }
        }
      }
      queries.push([
        $.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
          options: this.options,
          item: this.currentItem
        }) : $(this.options.items, this.element).not('.ui-sortable-helper').not('.ui-sortable-placeholder'),
        this
      ]);
      for (i = queries.length - 1; i >= 0; i--) {
        queries[i][0].each(function () {
          items.push(this);
        });
      }
      return $(items);
    },
    _removeCurrentsFromItems: function () {
      var list = this.currentItem.find(':data(' + this.widgetName + '-item)');
      this.items = $.grep(this.items, function (item) {
        for (var j = 0; j < list.length; j++) {
          if (list[j] === item.item[0]) {
            return false;
          }
        }
        return true;
      });
    },
    _refreshItems: function (event) {
      this.items = [];
      this.containers = [this];
      var i, j, cur, inst, targetData, _queries, item, queriesLength, items = this.items, queries = [[
            $.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element),
            this
          ]], connectWith = this._connectWith();
      if (connectWith && this.ready) {
        //Shouldn't be run the first time through due to massive slow-down
        for (i = connectWith.length - 1; i >= 0; i--) {
          cur = $(connectWith[i]);
          for (j = cur.length - 1; j >= 0; j--) {
            inst = $.data(cur[j], this.widgetFullName);
            if (inst && inst !== this && !inst.options.disabled) {
              queries.push([
                $.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element),
                inst
              ]);
              this.containers.push(inst);
            }
          }
        }
      }
      for (i = queries.length - 1; i >= 0; i--) {
        targetData = queries[i][1];
        _queries = queries[i][0];
        for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
          item = $(_queries[j]);
          item.data(this.widgetName + '-item', targetData);
          // Data for target checking (mouse manager)
          items.push({
            item: item,
            instance: targetData,
            width: 0,
            height: 0,
            left: 0,
            top: 0
          });
        }
      }
    },
    refreshPositions: function (fast) {
      //This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
      if (this.offsetParent && this.helper) {
        this.offset.parent = this._getParentOffset();
      }
      var i, item, t, p;
      for (i = this.items.length - 1; i >= 0; i--) {
        item = this.items[i];
        //We ignore calculating positions of all connected containers when we're not over them
        if (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
          continue;
        }
        t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
        if (!fast) {
          item.width = t.outerWidth();
          item.height = t.outerHeight();
        }
        p = t.offset();
        item.left = p.left;
        item.top = p.top;
      }
      if (this.options.custom && this.options.custom.refreshContainers) {
        this.options.custom.refreshContainers.call(this);
      } else {
        for (i = this.containers.length - 1; i >= 0; i--) {
          p = this.containers[i].element.offset();
          this.containers[i].containerCache.left = p.left;
          this.containers[i].containerCache.top = p.top;
          this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
          this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
        }
      }
      return this;
    },
    _createPlaceholder: function (that) {
      that = that || this;
      var className, o = that.options;
      if (!o.placeholder || o.placeholder.constructor === String) {
        className = o.placeholder;
        o.placeholder = {
          element: function () {
            var nodeName = that.currentItem[0].nodeName.toLowerCase(), element = $('<' + nodeName + '>', that.document[0]).addClass(className || that.currentItem[0].className + ' ui-sortable-placeholder').removeClass('ui-sortable-helper');
            if (nodeName === 'tr') {
              that.currentItem.children().each(function () {
                $('<td>&#160;</td>', that.document[0]).attr('colspan', $(this).attr('colspan') || 1).appendTo(element);
              });
            } else if (nodeName === 'img') {
              element.attr('src', that.currentItem.attr('src'));
            }
            if (!className) {
              element.css('visibility', 'hidden');
            }
            return element;
          },
          update: function (container, p) {
            // 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
            // 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
            if (className && !o.forcePlaceholderSize) {
              return;
            }
            //If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
            if (!p.height()) {
              p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css('paddingTop') || 0, 10) - parseInt(that.currentItem.css('paddingBottom') || 0, 10));
            }
            if (!p.width()) {
              p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css('paddingLeft') || 0, 10) - parseInt(that.currentItem.css('paddingRight') || 0, 10));
            }
          }
        };
      }
      //Create the placeholder
      that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
      //Append it after the actual current item
      that.currentItem.after(that.placeholder);
      //Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
      o.placeholder.update(that, that.placeholder);
    },
    _contactContainers: function (event) {
      var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, base, cur, nearBottom, floating, innermostContainer = null, innermostIndex = null;
      // get innermost container that intersects with item
      for (i = this.containers.length - 1; i >= 0; i--) {
        // never consider a container that's located within the item itself
        if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
          continue;
        }
        if (this._intersectsWith(this.containers[i].containerCache)) {
          // if we've already found a container and it's more "inner" than this, then continue
          if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
            continue;
          }
          innermostContainer = this.containers[i];
          innermostIndex = i;
        } else {
          // container doesn't intersect. trigger "out" event if necessary
          if (this.containers[i].containerCache.over) {
            this.containers[i]._trigger('out', event, this._uiHash(this));
            this.containers[i].containerCache.over = 0;
          }
        }
      }
      // if no intersecting containers found, return
      if (!innermostContainer) {
        return;
      }
      // move the item into the container if it's not there already
      if (this.containers.length === 1) {
        if (!this.containers[innermostIndex].containerCache.over) {
          this.containers[innermostIndex]._trigger('over', event, this._uiHash(this));
          this.containers[innermostIndex].containerCache.over = 1;
        }
      } else {
        //When entering a new container, we will find the item with the least distance and append our item near it
        dist = 10000;
        itemWithLeastDistance = null;
        floating = innermostContainer.floating || isFloating(this.currentItem);
        posProperty = floating ? 'left' : 'top';
        sizeProperty = floating ? 'width' : 'height';
        base = this.positionAbs[posProperty] + this.offset.click[posProperty];
        for (j = this.items.length - 1; j >= 0; j--) {
          if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
            continue;
          }
          if (this.items[j].item[0] === this.currentItem[0]) {
            continue;
          }
          if (floating && !isOverAxis(this.positionAbs.top + this.offset.click.top, this.items[j].top, this.items[j].height)) {
            continue;
          }
          cur = this.items[j].item.offset()[posProperty];
          nearBottom = false;
          if (Math.abs(cur - base) > Math.abs(cur + this.items[j][sizeProperty] - base)) {
            nearBottom = true;
            cur += this.items[j][sizeProperty];
          }
          if (Math.abs(cur - base) < dist) {
            dist = Math.abs(cur - base);
            itemWithLeastDistance = this.items[j];
            this.direction = nearBottom ? 'up' : 'down';
          }
        }
        //Check if dropOnEmpty is enabled
        if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
          return;
        }
        if (this.currentContainer === this.containers[innermostIndex]) {
          return;
        }
        itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
        this._trigger('change', event, this._uiHash());
        this.containers[innermostIndex]._trigger('change', event, this._uiHash(this));
        this.currentContainer = this.containers[innermostIndex];
        //Update the placeholder
        this.options.placeholder.update(this.currentContainer, this.placeholder);
        this.containers[innermostIndex]._trigger('over', event, this._uiHash(this));
        this.containers[innermostIndex].containerCache.over = 1;
      }
    },
    _createHelper: function (event) {
      var o = this.options, helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [
          event,
          this.currentItem
        ])) : o.helper === 'clone' ? this.currentItem.clone() : this.currentItem;
      //Add the helper to the DOM if that didn't happen already
      if (!helper.parents('body').length) {
        $(o.appendTo !== 'parent' ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
      }
      if (helper[0] === this.currentItem[0]) {
        this._storedCSS = {
          width: this.currentItem[0].style.width,
          height: this.currentItem[0].style.height,
          position: this.currentItem.css('position'),
          top: this.currentItem.css('top'),
          left: this.currentItem.css('left')
        };
      }
      if (!helper[0].style.width || o.forceHelperSize) {
        helper.width(this.currentItem.width());
      }
      if (!helper[0].style.height || o.forceHelperSize) {
        helper.height(this.currentItem.height());
      }
      return helper;
    },
    _adjustOffsetFromHelper: function (obj) {
      if (typeof obj === 'string') {
        obj = obj.split(' ');
      }
      if ($.isArray(obj)) {
        obj = {
          left: +obj[0],
          top: +obj[1] || 0
        };
      }
      if ('left' in obj) {
        this.offset.click.left = obj.left + this.margins.left;
      }
      if ('right' in obj) {
        this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
      }
      if ('top' in obj) {
        this.offset.click.top = obj.top + this.margins.top;
      }
      if ('bottom' in obj) {
        this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
      }
    },
    _getParentOffset: function () {
      //Get the offsetParent and cache its position
      this.offsetParent = this.helper.offsetParent();
      var po = this.offsetParent.offset();
      // This is a special case where we need to modify a offset calculated on start, since the following happened:
      // 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
      // 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
      //    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
      if (this.cssPosition === 'absolute' && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
        po.left += this.scrollParent.scrollLeft();
        po.top += this.scrollParent.scrollTop();
      }
      // This needs to be actually done for all browsers, since pageX/pageY includes this information
      // with an ugly IE fix
      if (this.offsetParent[0] === document.body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === 'html' && $.ui.ie) {
        po = {
          top: 0,
          left: 0
        };
      }
      return {
        top: po.top + (parseInt(this.offsetParent.css('borderTopWidth'), 10) || 0),
        left: po.left + (parseInt(this.offsetParent.css('borderLeftWidth'), 10) || 0)
      };
    },
    _getRelativeOffset: function () {
      if (this.cssPosition === 'relative') {
        var p = this.currentItem.position();
        return {
          top: p.top - (parseInt(this.helper.css('top'), 10) || 0) + this.scrollParent.scrollTop(),
          left: p.left - (parseInt(this.helper.css('left'), 10) || 0) + this.scrollParent.scrollLeft()
        };
      } else {
        return {
          top: 0,
          left: 0
        };
      }
    },
    _cacheMargins: function () {
      this.margins = {
        left: parseInt(this.currentItem.css('marginLeft'), 10) || 0,
        top: parseInt(this.currentItem.css('marginTop'), 10) || 0
      };
    },
    _cacheHelperProportions: function () {
      this.helperProportions = {
        width: this.helper.outerWidth(),
        height: this.helper.outerHeight()
      };
    },
    _setContainment: function () {
      var ce, co, over, o = this.options;
      if (o.containment === 'parent') {
        o.containment = this.helper[0].parentNode;
      }
      if (o.containment === 'document' || o.containment === 'window') {
        this.containment = [
          0 - this.offset.relative.left - this.offset.parent.left,
          0 - this.offset.relative.top - this.offset.parent.top,
          $(o.containment === 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
          ($(o.containment === 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
        ];
      }
      if (!/^(document|window|parent)$/.test(o.containment)) {
        ce = $(o.containment)[0];
        co = $(o.containment).offset();
        over = $(ce).css('overflow') !== 'hidden';
        this.containment = [
          co.left + (parseInt($(ce).css('borderLeftWidth'), 10) || 0) + (parseInt($(ce).css('paddingLeft'), 10) || 0) - this.margins.left,
          co.top + (parseInt($(ce).css('borderTopWidth'), 10) || 0) + (parseInt($(ce).css('paddingTop'), 10) || 0) - this.margins.top,
          co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css('borderLeftWidth'), 10) || 0) - (parseInt($(ce).css('paddingRight'), 10) || 0) - this.helperProportions.width - this.margins.left,
          co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css('borderTopWidth'), 10) || 0) - (parseInt($(ce).css('paddingBottom'), 10) || 0) - this.helperProportions.height - this.margins.top
        ];
      }
    },
    _convertPositionTo: function (d, pos) {
      if (!pos) {
        pos = this.position;
      }
      var mod = d === 'absolute' ? 1 : -1, scroll = this.cssPosition === 'absolute' && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
      return {
        top: pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - (this.cssPosition === 'fixed' ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()) * mod,
        left: pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - (this.cssPosition === 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod
      };
    },
    _generatePosition: function (event) {
      var top, left, o = this.options, pageX = event.pageX, pageY = event.pageY, scroll = this.cssPosition === 'absolute' && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = /(html|body)/i.test(scroll[0].tagName);
      // This is another very weird special case that only happens for relative elements:
      // 1. If the css position is relative
      // 2. and the scroll parent is the document or similar to the offset parent
      // we have to refresh the relative offset during the scroll so there are no jumps
      if (this.cssPosition === 'relative' && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {
        this.offset.relative = this._getRelativeOffset();
      }
      /*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */
      if (this.originalPosition) {
        //If we are not dragging yet, we won't check for options
        if (this.containment) {
          if (event.pageX - this.offset.click.left < this.containment[0]) {
            pageX = this.containment[0] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top < this.containment[1]) {
            pageY = this.containment[1] + this.offset.click.top;
          }
          if (event.pageX - this.offset.click.left > this.containment[2]) {
            pageX = this.containment[2] + this.offset.click.left;
          }
          if (event.pageY - this.offset.click.top > this.containment[3]) {
            pageY = this.containment[3] + this.offset.click.top;
          }
        }
        if (o.grid) {
          top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
          pageY = this.containment ? top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3] ? top : top - this.offset.click.top >= this.containment[1] ? top - o.grid[1] : top + o.grid[1] : top;
          left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
          pageX = this.containment ? left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2] ? left : left - this.offset.click.left >= this.containment[0] ? left - o.grid[0] : left + o.grid[0] : left;
        }
      }
      return {
        top: pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition === 'fixed' ? -this.scrollParent.scrollTop() : scrollIsRootNode ? 0 : scroll.scrollTop()),
        left: pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition === 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())
      };
    },
    _rearrange: function (event, i, a, hardRefresh) {
      a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], this.direction === 'down' ? i.item[0] : i.item[0].nextSibling);
      //Various things done here to improve the performance:
      // 1. we create a setTimeout, that calls refreshPositions
      // 2. on the instance, we have a counter variable, that get's higher after every append
      // 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
      // 4. this lets only the last addition to the timeout stack through
      this.counter = this.counter ? ++this.counter : 1;
      var counter = this.counter;
      this._delay(function () {
        if (counter === this.counter) {
          this.refreshPositions(!hardRefresh);  //Precompute after each DOM insertion, NOT on mousemove
        }
      });
    },
    _clear: function (event, noPropagation) {
      this.reverting = false;
      // We delay all events that have to be triggered to after the point where the placeholder has been removed and
      // everything else normalized again
      var i, delayedTriggers = [];
      // We first have to update the dom position of the actual currentItem
      // Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
      if (!this._noFinalSort && this.currentItem.parent().length) {
        this.placeholder.before(this.currentItem);
      }
      this._noFinalSort = null;
      if (this.helper[0] === this.currentItem[0]) {
        for (i in this._storedCSS) {
          if (this._storedCSS[i] === 'auto' || this._storedCSS[i] === 'static') {
            this._storedCSS[i] = '';
          }
        }
        this.currentItem.css(this._storedCSS).removeClass('ui-sortable-helper');
      } else {
        this.currentItem.show();
      }
      if (this.fromOutside && !noPropagation) {
        delayedTriggers.push(function (event) {
          this._trigger('receive', event, this._uiHash(this.fromOutside));
        });
      }
      if ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not('.ui-sortable-helper')[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
        delayedTriggers.push(function (event) {
          this._trigger('update', event, this._uiHash());
        });  //Trigger update callback if the DOM position has changed
      }
      // Check if the items Container has Changed and trigger appropriate
      // events.
      if (this !== this.currentContainer) {
        if (!noPropagation) {
          delayedTriggers.push(function (event) {
            this._trigger('remove', event, this._uiHash());
          });
          delayedTriggers.push(function (c) {
            return function (event) {
              c._trigger('receive', event, this._uiHash(this));
            };
          }.call(this, this.currentContainer));
          delayedTriggers.push(function (c) {
            return function (event) {
              c._trigger('update', event, this._uiHash(this));
            };
          }.call(this, this.currentContainer));
        }
      }
      //Post events to containers
      for (i = this.containers.length - 1; i >= 0; i--) {
        if (!noPropagation) {
          delayedTriggers.push(function (c) {
            return function (event) {
              c._trigger('deactivate', event, this._uiHash(this));
            };
          }.call(this, this.containers[i]));
        }
        if (this.containers[i].containerCache.over) {
          delayedTriggers.push(function (c) {
            return function (event) {
              c._trigger('out', event, this._uiHash(this));
            };
          }.call(this, this.containers[i]));
          this.containers[i].containerCache.over = 0;
        }
      }
      //Do what was originally in plugins
      if (this.storedCursor) {
        this.document.find('body').css('cursor', this.storedCursor);
        this.storedStylesheet.remove();
      }
      if (this._storedOpacity) {
        this.helper.css('opacity', this._storedOpacity);
      }
      if (this._storedZIndex) {
        this.helper.css('zIndex', this._storedZIndex === 'auto' ? '' : this._storedZIndex);
      }
      this.dragging = false;
      if (this.cancelHelperRemoval) {
        if (!noPropagation) {
          this._trigger('beforeStop', event, this._uiHash());
          for (i = 0; i < delayedTriggers.length; i++) {
            delayedTriggers[i].call(this, event);
          }
          //Trigger all delayed events
          this._trigger('stop', event, this._uiHash());
        }
        this.fromOutside = false;
        return false;
      }
      if (!noPropagation) {
        this._trigger('beforeStop', event, this._uiHash());
      }
      //$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
      this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
      if (this.helper[0] !== this.currentItem[0]) {
        this.helper.remove();
      }
      this.helper = null;
      if (!noPropagation) {
        for (i = 0; i < delayedTriggers.length; i++) {
          delayedTriggers[i].call(this, event);
        }
        //Trigger all delayed events
        this._trigger('stop', event, this._uiHash());
      }
      this.fromOutside = false;
      return true;
    },
    _trigger: function () {
      if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
        this.cancel();
      }
    },
    _uiHash: function (_inst) {
      var inst = _inst || this;
      return {
        helper: inst.helper,
        placeholder: inst.placeholder || $([]),
        position: inst.position,
        originalPosition: inst.originalPosition,
        offset: inst.positionAbs,
        item: inst.currentItem,
        sender: _inst ? _inst.element : null
      };
    }
  });
}(jQuery));
(function ($, undefined) {
  var dataSpace = 'ui-effects-';
  $.effects = { effect: {} };
  /*!
 * jQuery Color Animations v2.1.2
 * https://github.com/jquery/jquery-color
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Wed Jan 16 08:47:09 2013 -0600
 */
  (function (jQuery, undefined) {
    var stepHooks = 'backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor',
      // plusequals test for += 100 -= 100
      rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
      // a set of RE's that can match strings and generate color tuples.
      stringParsers = [
        {
          re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
          parse: function (execResult) {
            return [
              execResult[1],
              execResult[2],
              execResult[3],
              execResult[4]
            ];
          }
        },
        {
          re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
          parse: function (execResult) {
            return [
              execResult[1] * 2.55,
              execResult[2] * 2.55,
              execResult[3] * 2.55,
              execResult[4]
            ];
          }
        },
        {
          re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
          parse: function (execResult) {
            return [
              parseInt(execResult[1], 16),
              parseInt(execResult[2], 16),
              parseInt(execResult[3], 16)
            ];
          }
        },
        {
          re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
          parse: function (execResult) {
            return [
              parseInt(execResult[1] + execResult[1], 16),
              parseInt(execResult[2] + execResult[2], 16),
              parseInt(execResult[3] + execResult[3], 16)
            ];
          }
        },
        {
          re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
          space: 'hsla',
          parse: function (execResult) {
            return [
              execResult[1],
              execResult[2] / 100,
              execResult[3] / 100,
              execResult[4]
            ];
          }
        }
      ],
      // jQuery.Color( )
      color = jQuery.Color = function (color, green, blue, alpha) {
        return new jQuery.Color.fn.parse(color, green, blue, alpha);
      }, spaces = {
        rgba: {
          props: {
            red: {
              idx: 0,
              type: 'byte'
            },
            green: {
              idx: 1,
              type: 'byte'
            },
            blue: {
              idx: 2,
              type: 'byte'
            }
          }
        },
        hsla: {
          props: {
            hue: {
              idx: 0,
              type: 'degrees'
            },
            saturation: {
              idx: 1,
              type: 'percent'
            },
            lightness: {
              idx: 2,
              type: 'percent'
            }
          }
        }
      }, propTypes = {
        'byte': {
          floor: true,
          max: 255
        },
        'percent': { max: 1 },
        'degrees': {
          mod: 360,
          floor: true
        }
      }, support = color.support = {},
      // element for support tests
      supportElem = jQuery('<p>')[0],
      // colors = jQuery.Color.names
      colors,
      // local aliases of functions called often
      each = jQuery.each;
    // determine rgba support immediately
    supportElem.style.cssText = 'background-color:rgba(1,1,1,.5)';
    support.rgba = supportElem.style.backgroundColor.indexOf('rgba') > -1;
    // define cache name and alpha properties
    // for rgba and hsla spaces
    each(spaces, function (spaceName, space) {
      space.cache = '_' + spaceName;
      space.props.alpha = {
        idx: 3,
        type: 'percent',
        def: 1
      };
    });
    function clamp(value, prop, allowEmpty) {
      var type = propTypes[prop.type] || {};
      if (value == null) {
        return allowEmpty || !prop.def ? null : prop.def;
      }
      // ~~ is an short way of doing floor for positive numbers
      value = type.floor ? ~~value : parseFloat(value);
      // IE will pass in empty strings as value for alpha,
      // which will hit this case
      if (isNaN(value)) {
        return prop.def;
      }
      if (type.mod) {
        // we add mod before modding to make sure that negatives values
        // get converted properly: -10 -> 350
        return (value + type.mod) % type.mod;
      }
      // for now all property types without mod have min and max
      return 0 > value ? 0 : type.max < value ? type.max : value;
    }
    function stringParse(string) {
      var inst = color(), rgba = inst._rgba = [];
      string = string.toLowerCase();
      each(stringParsers, function (i, parser) {
        var parsed, match = parser.re.exec(string), values = match && parser.parse(match), spaceName = parser.space || 'rgba';
        if (values) {
          parsed = inst[spaceName](values);
          // if this was an rgba parse the assignment might happen twice
          // oh well....
          inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];
          rgba = inst._rgba = parsed._rgba;
          // exit each( stringParsers ) here because we matched
          return false;
        }
      });
      // Found a stringParser that handled it
      if (rgba.length) {
        // if this came from a parsed string, force "transparent" when alpha is 0
        // chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
        if (rgba.join() === '0,0,0,0') {
          jQuery.extend(rgba, colors.transparent);
        }
        return inst;
      }
      // named colors
      return colors[string];
    }
    color.fn = jQuery.extend(color.prototype, {
      parse: function (red, green, blue, alpha) {
        if (red === undefined) {
          this._rgba = [
            null,
            null,
            null,
            null
          ];
          return this;
        }
        if (red.jquery || red.nodeType) {
          red = jQuery(red).css(green);
          green = undefined;
        }
        var inst = this, type = jQuery.type(red), rgba = this._rgba = [];
        // more than 1 argument specified - assume ( red, green, blue, alpha )
        if (green !== undefined) {
          red = [
            red,
            green,
            blue,
            alpha
          ];
          type = 'array';
        }
        if (type === 'string') {
          return this.parse(stringParse(red) || colors._default);
        }
        if (type === 'array') {
          each(spaces.rgba.props, function (key, prop) {
            rgba[prop.idx] = clamp(red[prop.idx], prop);
          });
          return this;
        }
        if (type === 'object') {
          if (red instanceof color) {
            each(spaces, function (spaceName, space) {
              if (red[space.cache]) {
                inst[space.cache] = red[space.cache].slice();
              }
            });
          } else {
            each(spaces, function (spaceName, space) {
              var cache = space.cache;
              each(space.props, function (key, prop) {
                // if the cache doesn't exist, and we know how to convert
                if (!inst[cache] && space.to) {
                  // if the value was null, we don't need to copy it
                  // if the key was alpha, we don't need to copy it either
                  if (key === 'alpha' || red[key] == null) {
                    return;
                  }
                  inst[cache] = space.to(inst._rgba);
                }
                // this is the only case where we allow nulls for ALL properties.
                // call clamp with alwaysAllowEmpty
                inst[cache][prop.idx] = clamp(red[key], prop, true);
              });
              // everything defined but alpha?
              if (inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0) {
                // use the default of 1
                inst[cache][3] = 1;
                if (space.from) {
                  inst._rgba = space.from(inst[cache]);
                }
              }
            });
          }
          return this;
        }
      },
      is: function (compare) {
        var is = color(compare), same = true, inst = this;
        each(spaces, function (_, space) {
          var localCache, isCache = is[space.cache];
          if (isCache) {
            localCache = inst[space.cache] || space.to && space.to(inst._rgba) || [];
            each(space.props, function (_, prop) {
              if (isCache[prop.idx] != null) {
                same = isCache[prop.idx] === localCache[prop.idx];
                return same;
              }
            });
          }
          return same;
        });
        return same;
      },
      _space: function () {
        var used = [], inst = this;
        each(spaces, function (spaceName, space) {
          if (inst[space.cache]) {
            used.push(spaceName);
          }
        });
        return used.pop();
      },
      transition: function (other, distance) {
        var end = color(other), spaceName = end._space(), space = spaces[spaceName], startColor = this.alpha() === 0 ? color('transparent') : this, start = startColor[space.cache] || space.to(startColor._rgba), result = start.slice();
        end = end[space.cache];
        each(space.props, function (key, prop) {
          var index = prop.idx, startValue = start[index], endValue = end[index], type = propTypes[prop.type] || {};
          // if null, don't override start value
          if (endValue === null) {
            return;
          }
          // if null - use end
          if (startValue === null) {
            result[index] = endValue;
          } else {
            if (type.mod) {
              if (endValue - startValue > type.mod / 2) {
                startValue += type.mod;
              } else if (startValue - endValue > type.mod / 2) {
                startValue -= type.mod;
              }
            }
            result[index] = clamp((endValue - startValue) * distance + startValue, prop);
          }
        });
        return this[spaceName](result);
      },
      blend: function (opaque) {
        // if we are already opaque - return ourself
        if (this._rgba[3] === 1) {
          return this;
        }
        var rgb = this._rgba.slice(), a = rgb.pop(), blend = color(opaque)._rgba;
        return color(jQuery.map(rgb, function (v, i) {
          return (1 - a) * blend[i] + a * v;
        }));
      },
      toRgbaString: function () {
        var prefix = 'rgba(', rgba = jQuery.map(this._rgba, function (v, i) {
            return v == null ? i > 2 ? 1 : 0 : v;
          });
        if (rgba[3] === 1) {
          rgba.pop();
          prefix = 'rgb(';
        }
        return prefix + rgba.join() + ')';
      },
      toHslaString: function () {
        var prefix = 'hsla(', hsla = jQuery.map(this.hsla(), function (v, i) {
            if (v == null) {
              v = i > 2 ? 1 : 0;
            }
            // catch 1 and 2
            if (i && i < 3) {
              v = Math.round(v * 100) + '%';
            }
            return v;
          });
        if (hsla[3] === 1) {
          hsla.pop();
          prefix = 'hsl(';
        }
        return prefix + hsla.join() + ')';
      },
      toHexString: function (includeAlpha) {
        var rgba = this._rgba.slice(), alpha = rgba.pop();
        if (includeAlpha) {
          rgba.push(~~(alpha * 255));
        }
        return '#' + jQuery.map(rgba, function (v) {
          // default to 0 when nulls exist
          v = (v || 0).toString(16);
          return v.length === 1 ? '0' + v : v;
        }).join('');
      },
      toString: function () {
        return this._rgba[3] === 0 ? 'transparent' : this.toRgbaString();
      }
    });
    color.fn.parse.prototype = color.fn;
    // hsla conversions adapted from:
    // https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021
    function hue2rgb(p, q, h) {
      h = (h + 1) % 1;
      if (h * 6 < 1) {
        return p + (q - p) * h * 6;
      }
      if (h * 2 < 1) {
        return q;
      }
      if (h * 3 < 2) {
        return p + (q - p) * (2 / 3 - h) * 6;
      }
      return p;
    }
    spaces.hsla.to = function (rgba) {
      if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {
        return [
          null,
          null,
          null,
          rgba[3]
        ];
      }
      var r = rgba[0] / 255, g = rgba[1] / 255, b = rgba[2] / 255, a = rgba[3], max = Math.max(r, g, b), min = Math.min(r, g, b), diff = max - min, add = max + min, l = add * 0.5, h, s;
      if (min === max) {
        h = 0;
      } else if (r === max) {
        h = 60 * (g - b) / diff + 360;
      } else if (g === max) {
        h = 60 * (b - r) / diff + 120;
      } else {
        h = 60 * (r - g) / diff + 240;
      }
      // chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
      // otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
      if (diff === 0) {
        s = 0;
      } else if (l <= 0.5) {
        s = diff / add;
      } else {
        s = diff / (2 - add);
      }
      return [
        Math.round(h) % 360,
        s,
        l,
        a == null ? 1 : a
      ];
    };
    spaces.hsla.from = function (hsla) {
      if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {
        return [
          null,
          null,
          null,
          hsla[3]
        ];
      }
      var h = hsla[0] / 360, s = hsla[1], l = hsla[2], a = hsla[3], q = l <= 0.5 ? l * (1 + s) : l + s - l * s, p = 2 * l - q;
      return [
        Math.round(hue2rgb(p, q, h + 1 / 3) * 255),
        Math.round(hue2rgb(p, q, h) * 255),
        Math.round(hue2rgb(p, q, h - 1 / 3) * 255),
        a
      ];
    };
    each(spaces, function (spaceName, space) {
      var props = space.props, cache = space.cache, to = space.to, from = space.from;
      // makes rgba() and hsla()
      color.fn[spaceName] = function (value) {
        // generate a cache for this space if it doesn't exist
        if (to && !this[cache]) {
          this[cache] = to(this._rgba);
        }
        if (value === undefined) {
          return this[cache].slice();
        }
        var ret, type = jQuery.type(value), arr = type === 'array' || type === 'object' ? value : arguments, local = this[cache].slice();
        each(props, function (key, prop) {
          var val = arr[type === 'object' ? key : prop.idx];
          if (val == null) {
            val = local[prop.idx];
          }
          local[prop.idx] = clamp(val, prop);
        });
        if (from) {
          ret = color(from(local));
          ret[cache] = local;
          return ret;
        } else {
          return color(local);
        }
      };
      // makes red() green() blue() alpha() hue() saturation() lightness()
      each(props, function (key, prop) {
        // alpha is included in more than one space
        if (color.fn[key]) {
          return;
        }
        color.fn[key] = function (value) {
          var vtype = jQuery.type(value), fn = key === 'alpha' ? this._hsla ? 'hsla' : 'rgba' : spaceName, local = this[fn](), cur = local[prop.idx], match;
          if (vtype === 'undefined') {
            return cur;
          }
          if (vtype === 'function') {
            value = value.call(this, cur);
            vtype = jQuery.type(value);
          }
          if (value == null && prop.empty) {
            return this;
          }
          if (vtype === 'string') {
            match = rplusequals.exec(value);
            if (match) {
              value = cur + parseFloat(match[2]) * (match[1] === '+' ? 1 : -1);
            }
          }
          local[prop.idx] = value;
          return this[fn](local);
        };
      });
    });
    // add cssHook and .fx.step function for each named hook.
    // accept a space separated string of properties
    color.hook = function (hook) {
      var hooks = hook.split(' ');
      each(hooks, function (i, hook) {
        jQuery.cssHooks[hook] = {
          set: function (elem, value) {
            var parsed, curElem, backgroundColor = '';
            if (value !== 'transparent' && (jQuery.type(value) !== 'string' || (parsed = stringParse(value)))) {
              value = color(parsed || value);
              if (!support.rgba && value._rgba[3] !== 1) {
                curElem = hook === 'backgroundColor' ? elem.parentNode : elem;
                while ((backgroundColor === '' || backgroundColor === 'transparent') && curElem && curElem.style) {
                  try {
                    backgroundColor = jQuery.css(curElem, 'backgroundColor');
                    curElem = curElem.parentNode;
                  } catch (e) {
                  }
                }
                value = value.blend(backgroundColor && backgroundColor !== 'transparent' ? backgroundColor : '_default');
              }
              value = value.toRgbaString();
            }
            try {
              elem.style[hook] = value;
            } catch (e) {
            }
          }
        };
        jQuery.fx.step[hook] = function (fx) {
          if (!fx.colorInit) {
            fx.start = color(fx.elem, hook);
            fx.end = color(fx.end);
            fx.colorInit = true;
          }
          jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));
        };
      });
    };
    color.hook(stepHooks);
    jQuery.cssHooks.borderColor = {
      expand: function (value) {
        var expanded = {};
        each([
          'Top',
          'Right',
          'Bottom',
          'Left'
        ], function (i, part) {
          expanded['border' + part + 'Color'] = value;
        });
        return expanded;
      }
    };
    // Basic color names only.
    // Usage of any of the other color names requires adding yourself or including
    // jquery.color.svg-names.js.
    colors = jQuery.Color.names = {
      aqua: '#00ffff',
      black: '#000000',
      blue: '#0000ff',
      fuchsia: '#ff00ff',
      gray: '#808080',
      green: '#008000',
      lime: '#00ff00',
      maroon: '#800000',
      navy: '#000080',
      olive: '#808000',
      purple: '#800080',
      red: '#ff0000',
      silver: '#c0c0c0',
      teal: '#008080',
      white: '#ffffff',
      yellow: '#ffff00',
      transparent: [
        null,
        null,
        null,
        0
      ],
      _default: '#ffffff'
    };
  }(jQuery));
  /******************************************************************************/
  /****************************** CLASS ANIMATIONS ******************************/
  /******************************************************************************/
  (function () {
    var classAnimationActions = [
        'add',
        'remove',
        'toggle'
      ], shorthandStyles = {
        border: 1,
        borderBottom: 1,
        borderColor: 1,
        borderLeft: 1,
        borderRight: 1,
        borderTop: 1,
        borderWidth: 1,
        margin: 1,
        padding: 1
      };
    $.each([
      'borderLeftStyle',
      'borderRightStyle',
      'borderBottomStyle',
      'borderTopStyle'
    ], function (_, prop) {
      $.fx.step[prop] = function (fx) {
        if (fx.end !== 'none' && !fx.setAttr || fx.pos === 1 && !fx.setAttr) {
          jQuery.style(fx.elem, prop, fx.end);
          fx.setAttr = true;
        }
      };
    });
    function getElementStyles(elem) {
      var key, len, style = elem.ownerDocument.defaultView ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : elem.currentStyle, styles = {};
      if (style && style.length && style[0] && style[style[0]]) {
        len = style.length;
        while (len--) {
          key = style[len];
          if (typeof style[key] === 'string') {
            styles[$.camelCase(key)] = style[key];
          }
        }  // support: Opera, IE <9
      } else {
        for (key in style) {
          if (typeof style[key] === 'string') {
            styles[key] = style[key];
          }
        }
      }
      return styles;
    }
    function styleDifference(oldStyle, newStyle) {
      var diff = {}, name, value;
      for (name in newStyle) {
        value = newStyle[name];
        if (oldStyle[name] !== value) {
          if (!shorthandStyles[name]) {
            if ($.fx.step[name] || !isNaN(parseFloat(value))) {
              diff[name] = value;
            }
          }
        }
      }
      return diff;
    }
    // support: jQuery <1.8
    if (!$.fn.addBack) {
      $.fn.addBack = function (selector) {
        return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
      };
    }
    $.effects.animateClass = function (value, duration, easing, callback) {
      var o = $.speed(duration, easing, callback);
      return this.queue(function () {
        var animated = $(this), baseClass = animated.attr('class') || '', applyClassChange, allAnimations = o.children ? animated.find('*').addBack() : animated;
        // map the animated objects to store the original styles.
        allAnimations = allAnimations.map(function () {
          var el = $(this);
          return {
            el: el,
            start: getElementStyles(this)
          };
        });
        // apply class change
        applyClassChange = function () {
          $.each(classAnimationActions, function (i, action) {
            if (value[action]) {
              animated[action + 'Class'](value[action]);
            }
          });
        };
        applyClassChange();
        // map all animated objects again - calculate new styles and diff
        allAnimations = allAnimations.map(function () {
          this.end = getElementStyles(this.el[0]);
          this.diff = styleDifference(this.start, this.end);
          return this;
        });
        // apply original class
        animated.attr('class', baseClass);
        // map all animated objects again - this time collecting a promise
        allAnimations = allAnimations.map(function () {
          var styleInfo = this, dfd = $.Deferred(), opts = $.extend({}, o, {
              queue: false,
              complete: function () {
                dfd.resolve(styleInfo);
              }
            });
          this.el.animate(this.diff, opts);
          return dfd.promise();
        });
        // once all animations have completed:
        $.when.apply($, allAnimations.get()).done(function () {
          // set the final class
          applyClassChange();
          // for each animated element,
          // clear all css properties that were animated
          $.each(arguments, function () {
            var el = this.el;
            $.each(this.diff, function (key) {
              el.css(key, '');
            });
          });
          // this is guarnteed to be there if you use jQuery.speed()
          // it also handles dequeuing the next anim...
          o.complete.call(animated[0]);
        });
      });
    };
    $.fn.extend({
      addClass: function (orig) {
        return function (classNames, speed, easing, callback) {
          return speed ? $.effects.animateClass.call(this, { add: classNames }, speed, easing, callback) : orig.apply(this, arguments);
        };
      }($.fn.addClass),
      removeClass: function (orig) {
        return function (classNames, speed, easing, callback) {
          return arguments.length > 1 ? $.effects.animateClass.call(this, { remove: classNames }, speed, easing, callback) : orig.apply(this, arguments);
        };
      }($.fn.removeClass),
      toggleClass: function (orig) {
        return function (classNames, force, speed, easing, callback) {
          if (typeof force === 'boolean' || force === undefined) {
            if (!speed) {
              // without speed parameter
              return orig.apply(this, arguments);
            } else {
              return $.effects.animateClass.call(this, force ? { add: classNames } : { remove: classNames }, speed, easing, callback);
            }
          } else {
            // without force parameter
            return $.effects.animateClass.call(this, { toggle: classNames }, force, speed, easing);
          }
        };
      }($.fn.toggleClass),
      switchClass: function (remove, add, speed, easing, callback) {
        return $.effects.animateClass.call(this, {
          add: add,
          remove: remove
        }, speed, easing, callback);
      }
    });
  }());
  /******************************************************************************/
  /*********************************** EFFECTS **********************************/
  /******************************************************************************/
  (function () {
    $.extend($.effects, {
      version: '1.10.3',
      save: function (element, set) {
        for (var i = 0; i < set.length; i++) {
          if (set[i] !== null) {
            element.data(dataSpace + set[i], element[0].style[set[i]]);
          }
        }
      },
      restore: function (element, set) {
        var val, i;
        for (i = 0; i < set.length; i++) {
          if (set[i] !== null) {
            val = element.data(dataSpace + set[i]);
            // support: jQuery 1.6.2
            // http://bugs.jquery.com/ticket/9917
            // jQuery 1.6.2 incorrectly returns undefined for any falsy value.
            // We can't differentiate between "" and 0 here, so we just assume
            // empty string since it's likely to be a more common value...
            if (val === undefined) {
              val = '';
            }
            element.css(set[i], val);
          }
        }
      },
      setMode: function (el, mode) {
        if (mode === 'toggle') {
          mode = el.is(':hidden') ? 'show' : 'hide';
        }
        return mode;
      },
      getBaseline: function (origin, original) {
        var y, x;
        switch (origin[0]) {
        case 'top':
          y = 0;
          break;
        case 'middle':
          y = 0.5;
          break;
        case 'bottom':
          y = 1;
          break;
        default:
          y = origin[0] / original.height;
        }
        switch (origin[1]) {
        case 'left':
          x = 0;
          break;
        case 'center':
          x = 0.5;
          break;
        case 'right':
          x = 1;
          break;
        default:
          x = origin[1] / original.width;
        }
        return {
          x: x,
          y: y
        };
      },
      createWrapper: function (element) {
        // if the element is already wrapped, return it
        if (element.parent().is('.ui-effects-wrapper')) {
          return element.parent();
        }
        // wrap the element
        var props = {
            width: element.outerWidth(true),
            height: element.outerHeight(true),
            'float': element.css('float')
          }, wrapper = $('<div></div>').addClass('ui-effects-wrapper').css({
            fontSize: '100%',
            background: 'transparent',
            border: 'none',
            margin: 0,
            padding: 0
          }),
          // Store the size in case width/height are defined in % - Fixes #5245
          size = {
            width: element.width(),
            height: element.height()
          }, active = document.activeElement;
        // support: Firefox
        // Firefox incorrectly exposes anonymous content
        // https://bugzilla.mozilla.org/show_bug.cgi?id=561664
        try {
          active.id;
        } catch (e) {
          active = document.body;
        }
        element.wrap(wrapper);
        // Fixes #7595 - Elements lose focus when wrapped.
        if (element[0] === active || $.contains(element[0], active)) {
          $(active).focus();
        }
        wrapper = element.parent();
        //Hotfix for jQuery 1.4 since some change in wrap() seems to actually lose the reference to the wrapped element
        // transfer positioning properties to the wrapper
        if (element.css('position') === 'static') {
          wrapper.css({ position: 'relative' });
          element.css({ position: 'relative' });
        } else {
          $.extend(props, {
            position: element.css('position'),
            zIndex: element.css('z-index')
          });
          $.each([
            'top',
            'left',
            'bottom',
            'right'
          ], function (i, pos) {
            props[pos] = element.css(pos);
            if (isNaN(parseInt(props[pos], 10))) {
              props[pos] = 'auto';
            }
          });
          element.css({
            position: 'relative',
            top: 0,
            left: 0,
            right: 'auto',
            bottom: 'auto'
          });
        }
        element.css(size);
        return wrapper.css(props).show();
      },
      removeWrapper: function (element) {
        var active = document.activeElement;
        if (element.parent().is('.ui-effects-wrapper')) {
          element.parent().replaceWith(element);
          // Fixes #7595 - Elements lose focus when wrapped.
          if (element[0] === active || $.contains(element[0], active)) {
            $(active).focus();
          }
        }
        return element;
      },
      setTransition: function (element, list, factor, value) {
        value = value || {};
        $.each(list, function (i, x) {
          var unit = element.cssUnit(x);
          if (unit[0] > 0) {
            value[x] = unit[0] * factor + unit[1];
          }
        });
        return value;
      }
    });
    // return an effect options object for the given parameters:
    function _normalizeArguments(effect, options, speed, callback) {
      // allow passing all options as the first parameter
      if ($.isPlainObject(effect)) {
        options = effect;
        effect = effect.effect;
      }
      // convert to an object
      effect = { effect: effect };
      // catch (effect, null, ...)
      if (options == null) {
        options = {};
      }
      // catch (effect, callback)
      if ($.isFunction(options)) {
        callback = options;
        speed = null;
        options = {};
      }
      // catch (effect, speed, ?)
      if (typeof options === 'number' || $.fx.speeds[options]) {
        callback = speed;
        speed = options;
        options = {};
      }
      // catch (effect, options, callback)
      if ($.isFunction(speed)) {
        callback = speed;
        speed = null;
      }
      // add options to effect
      if (options) {
        $.extend(effect, options);
      }
      speed = speed || options.duration;
      effect.duration = $.fx.off ? 0 : typeof speed === 'number' ? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;
      effect.complete = callback || options.complete;
      return effect;
    }
    function standardAnimationOption(option) {
      // Valid standard speeds (nothing, number, named speed)
      if (!option || typeof option === 'number' || $.fx.speeds[option]) {
        return true;
      }
      // Invalid strings - treat as "normal" speed
      if (typeof option === 'string' && !$.effects.effect[option]) {
        return true;
      }
      // Complete callback
      if ($.isFunction(option)) {
        return true;
      }
      // Options hash (but not naming an effect)
      if (typeof option === 'object' && !option.effect) {
        return true;
      }
      // Didn't match any standard API
      return false;
    }
    $.fn.extend({
      effect: function () {
        var args = _normalizeArguments.apply(this, arguments), mode = args.mode, queue = args.queue, effectMethod = $.effects.effect[args.effect];
        if ($.fx.off || !effectMethod) {
          // delegate to the original method (e.g., .show()) if possible
          if (mode) {
            return this[mode](args.duration, args.complete);
          } else {
            return this.each(function () {
              if (args.complete) {
                args.complete.call(this);
              }
            });
          }
        }
        function run(next) {
          var elem = $(this), complete = args.complete, mode = args.mode;
          function done() {
            if ($.isFunction(complete)) {
              complete.call(elem[0]);
            }
            if ($.isFunction(next)) {
              next();
            }
          }
          // If the element already has the correct final state, delegate to
          // the core methods so the internal tracking of "olddisplay" works.
          if (elem.is(':hidden') ? mode === 'hide' : mode === 'show') {
            elem[mode]();
            done();
          } else {
            effectMethod.call(elem[0], args, done);
          }
        }
        return queue === false ? this.each(run) : this.queue(queue || 'fx', run);
      },
      show: function (orig) {
        return function (option) {
          if (standardAnimationOption(option)) {
            return orig.apply(this, arguments);
          } else {
            var args = _normalizeArguments.apply(this, arguments);
            args.mode = 'show';
            return this.effect.call(this, args);
          }
        };
      }($.fn.show),
      hide: function (orig) {
        return function (option) {
          if (standardAnimationOption(option)) {
            return orig.apply(this, arguments);
          } else {
            var args = _normalizeArguments.apply(this, arguments);
            args.mode = 'hide';
            return this.effect.call(this, args);
          }
        };
      }($.fn.hide),
      toggle: function (orig) {
        return function (option) {
          if (standardAnimationOption(option) || typeof option === 'boolean') {
            return orig.apply(this, arguments);
          } else {
            var args = _normalizeArguments.apply(this, arguments);
            args.mode = 'toggle';
            return this.effect.call(this, args);
          }
        };
      }($.fn.toggle),
      cssUnit: function (key) {
        var style = this.css(key), val = [];
        $.each([
          'em',
          'px',
          '%',
          'pt'
        ], function (i, unit) {
          if (style.indexOf(unit) > 0) {
            val = [
              parseFloat(style),
              unit
            ];
          }
        });
        return val;
      }
    });
  }());
  /******************************************************************************/
  /*********************************** EASING ***********************************/
  /******************************************************************************/
  (function () {
    // based on easing equations from Robert Penner (http://www.robertpenner.com/easing)
    var baseEasings = {};
    $.each([
      'Quad',
      'Cubic',
      'Quart',
      'Quint',
      'Expo'
    ], function (i, name) {
      baseEasings[name] = function (p) {
        return Math.pow(p, i + 2);
      };
    });
    $.extend(baseEasings, {
      Sine: function (p) {
        return 1 - Math.cos(p * Math.PI / 2);
      },
      Circ: function (p) {
        return 1 - Math.sqrt(1 - p * p);
      },
      Elastic: function (p) {
        return p === 0 || p === 1 ? p : -Math.pow(2, 8 * (p - 1)) * Math.sin(((p - 1) * 80 - 7.5) * Math.PI / 15);
      },
      Back: function (p) {
        return p * p * (3 * p - 2);
      },
      Bounce: function (p) {
        var pow2, bounce = 4;
        while (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) {
        }
        return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2);
      }
    });
    $.each(baseEasings, function (name, easeIn) {
      $.easing['easeIn' + name] = easeIn;
      $.easing['easeOut' + name] = function (p) {
        return 1 - easeIn(1 - p);
      };
      $.easing['easeInOut' + name] = function (p) {
        return p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn(p * -2 + 2) / 2;
      };
    });
  }());
}(jQuery));
(function ($, undefined) {
  var uid = 0, hideProps = {}, showProps = {};
  hideProps.height = hideProps.paddingTop = hideProps.paddingBottom = hideProps.borderTopWidth = hideProps.borderBottomWidth = 'hide';
  showProps.height = showProps.paddingTop = showProps.paddingBottom = showProps.borderTopWidth = showProps.borderBottomWidth = 'show';
  $.widget('ui.accordion', {
    version: '1.10.3',
    options: {
      active: 0,
      animate: {},
      collapsible: false,
      event: 'click',
      header: '> li > :first-child,> :not(li):even',
      heightStyle: 'auto',
      icons: {
        activeHeader: 'ui-icon-triangle-1-s',
        header: 'ui-icon-triangle-1-e'
      },
      activate: null,
      beforeActivate: null
    },
    _create: function () {
      var options = this.options;
      this.prevShow = this.prevHide = $();
      this.element.addClass('ui-accordion ui-widget ui-helper-reset').attr('role', 'tablist');
      // don't allow collapsible: false and active: false / null
      if (!options.collapsible && (options.active === false || options.active == null)) {
        options.active = 0;
      }
      this._processPanels();
      // handle negative values
      if (options.active < 0) {
        options.active += this.headers.length;
      }
      this._refresh();
    },
    _getCreateEventData: function () {
      return {
        header: this.active,
        panel: !this.active.length ? $() : this.active.next(),
        content: !this.active.length ? $() : this.active.next()
      };
    },
    _createIcons: function () {
      var icons = this.options.icons;
      if (icons) {
        $('<span>').addClass('ui-accordion-header-icon ui-icon ' + icons.header).prependTo(this.headers);
        this.active.children('.ui-accordion-header-icon').removeClass(icons.header).addClass(icons.activeHeader);
        this.headers.addClass('ui-accordion-icons');
      }
    },
    _destroyIcons: function () {
      this.headers.removeClass('ui-accordion-icons').children('.ui-accordion-header-icon').remove();
    },
    _destroy: function () {
      var contents;
      // clean up main element
      this.element.removeClass('ui-accordion ui-widget ui-helper-reset').removeAttr('role');
      // clean up headers
      this.headers.removeClass('ui-accordion-header ui-accordion-header-active ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top').removeAttr('role').removeAttr('aria-selected').removeAttr('aria-controls').removeAttr('tabIndex').each(function () {
        if (/^ui-accordion/.test(this.id)) {
          this.removeAttribute('id');
        }
      });
      this._destroyIcons();
      // clean up content panels
      contents = this.headers.next().css('display', '').removeAttr('role').removeAttr('aria-expanded').removeAttr('aria-hidden').removeAttr('aria-labelledby').removeClass('ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-state-disabled').each(function () {
        if (/^ui-accordion/.test(this.id)) {
          this.removeAttribute('id');
        }
      });
      if (this.options.heightStyle !== 'content') {
        contents.css('height', '');
      }
    },
    _setOption: function (key, value) {
      if (key === 'active') {
        // _activate() will handle invalid values and update this.options
        this._activate(value);
        return;
      }
      if (key === 'event') {
        if (this.options.event) {
          this._off(this.headers, this.options.event);
        }
        this._setupEvents(value);
      }
      this._super(key, value);
      // setting collapsible: false while collapsed; open first panel
      if (key === 'collapsible' && !value && this.options.active === false) {
        this._activate(0);
      }
      if (key === 'icons') {
        this._destroyIcons();
        if (value) {
          this._createIcons();
        }
      }
      // #5332 - opacity doesn't cascade to positioned elements in IE
      // so we need to add the disabled class to the headers and panels
      if (key === 'disabled') {
        this.headers.add(this.headers.next()).toggleClass('ui-state-disabled', !!value);
      }
    },
    _keydown: function (event) {
      /*jshint maxcomplexity:15*/
      if (event.altKey || event.ctrlKey) {
        return;
      }
      var keyCode = $.ui.keyCode, length = this.headers.length, currentIndex = this.headers.index(event.target), toFocus = false;
      switch (event.keyCode) {
      case keyCode.RIGHT:
      case keyCode.DOWN:
        toFocus = this.headers[(currentIndex + 1) % length];
        break;
      case keyCode.LEFT:
      case keyCode.UP:
        toFocus = this.headers[(currentIndex - 1 + length) % length];
        break;
      case keyCode.SPACE:
      case keyCode.ENTER:
        this._eventHandler(event);
        break;
      case keyCode.HOME:
        toFocus = this.headers[0];
        break;
      case keyCode.END:
        toFocus = this.headers[length - 1];
        break;
      }
      if (toFocus) {
        $(event.target).attr('tabIndex', -1);
        $(toFocus).attr('tabIndex', 0);
        toFocus.focus();
        event.preventDefault();
      }
    },
    _panelKeyDown: function (event) {
      if (event.keyCode === $.ui.keyCode.UP && event.ctrlKey) {
        $(event.currentTarget).prev().focus();
      }
    },
    refresh: function () {
      var options = this.options;
      this._processPanels();
      // was collapsed or no panel
      if (options.active === false && options.collapsible === true || !this.headers.length) {
        options.active = false;
        this.active = $();  // active false only when collapsible is true
      } else if (options.active === false) {
        this._activate(0);  // was active, but active panel is gone
      } else if (this.active.length && !$.contains(this.element[0], this.active[0])) {
        // all remaining panel are disabled
        if (this.headers.length === this.headers.find('.ui-state-disabled').length) {
          options.active = false;
          this.active = $();  // activate previous panel
        } else {
          this._activate(Math.max(0, options.active - 1));
        }  // was active, active panel still exists
      } else {
        // make sure active index is correct
        options.active = this.headers.index(this.active);
      }
      this._destroyIcons();
      this._refresh();
    },
    _processPanels: function () {
      this.headers = this.element.find(this.options.header).addClass('ui-accordion-header ui-helper-reset ui-state-default ui-corner-all');
      this.headers.next().addClass('ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom').filter(':not(.ui-accordion-content-active)').hide();
    },
    _refresh: function () {
      var maxHeight, options = this.options, heightStyle = options.heightStyle, parent = this.element.parent(), accordionId = this.accordionId = 'ui-accordion-' + (this.element.attr('id') || ++uid);
      this.active = this._findActive(options.active).addClass('ui-accordion-header-active ui-state-active ui-corner-top').removeClass('ui-corner-all');
      this.active.next().addClass('ui-accordion-content-active').show();
      this.headers.attr('role', 'tab').each(function (i) {
        var header = $(this), headerId = header.attr('id'), panel = header.next(), panelId = panel.attr('id');
        if (!headerId) {
          headerId = accordionId + '-header-' + i;
          header.attr('id', headerId);
        }
        if (!panelId) {
          panelId = accordionId + '-panel-' + i;
          panel.attr('id', panelId);
        }
        header.attr('aria-controls', panelId);
        panel.attr('aria-labelledby', headerId);
      }).next().attr('role', 'tabpanel');
      this.headers.not(this.active).attr({
        'aria-selected': 'false',
        tabIndex: -1
      }).next().attr({
        'aria-expanded': 'false',
        'aria-hidden': 'true'
      }).hide();
      // make sure at least one header is in the tab order
      if (!this.active.length) {
        this.headers.eq(0).attr('tabIndex', 0);
      } else {
        this.active.attr({
          'aria-selected': 'true',
          tabIndex: 0
        }).next().attr({
          'aria-expanded': 'true',
          'aria-hidden': 'false'
        });
      }
      this._createIcons();
      this._setupEvents(options.event);
      if (heightStyle === 'fill') {
        maxHeight = parent.height();
        this.element.siblings(':visible').each(function () {
          var elem = $(this), position = elem.css('position');
          if (position === 'absolute' || position === 'fixed') {
            return;
          }
          maxHeight -= elem.outerHeight(true);
        });
        this.headers.each(function () {
          maxHeight -= $(this).outerHeight(true);
        });
        this.headers.next().each(function () {
          $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
        }).css('overflow', 'auto');
      } else if (heightStyle === 'auto') {
        maxHeight = 0;
        this.headers.next().each(function () {
          maxHeight = Math.max(maxHeight, $(this).css('height', '').height());
        }).height(maxHeight);
      }
    },
    _activate: function (index) {
      var active = this._findActive(index)[0];
      // trying to activate the already active panel
      if (active === this.active[0]) {
        return;
      }
      // trying to collapse, simulate a click on the currently active header
      active = active || this.active[0];
      this._eventHandler({
        target: active,
        currentTarget: active,
        preventDefault: $.noop
      });
    },
    _findActive: function (selector) {
      return typeof selector === 'number' ? this.headers.eq(selector) : $();
    },
    _setupEvents: function (event) {
      var events = { keydown: '_keydown' };
      if (event) {
        $.each(event.split(' '), function (index, eventName) {
          events[eventName] = '_eventHandler';
        });
      }
      this._off(this.headers.add(this.headers.next()));
      this._on(this.headers, events);
      this._on(this.headers.next(), { keydown: '_panelKeyDown' });
      this._hoverable(this.headers);
      this._focusable(this.headers);
    },
    _eventHandler: function (event) {
      var options = this.options, active = this.active, clicked = $(event.currentTarget), clickedIsActive = clicked[0] === active[0], collapsing = clickedIsActive && options.collapsible, toShow = collapsing ? $() : clicked.next(), toHide = active.next(), eventData = {
          oldHeader: active,
          oldPanel: toHide,
          newHeader: collapsing ? $() : clicked,
          newPanel: toShow
        };
      event.preventDefault();
      if (clickedIsActive && !options.collapsible || this._trigger('beforeActivate', event, eventData) === false) {
        return;
      }
      options.active = collapsing ? false : this.headers.index(clicked);
      // when the call to ._toggle() comes after the class changes
      // it causes a very odd bug in IE 8 (see #6720)
      this.active = clickedIsActive ? $() : clicked;
      this._toggle(eventData);
      // switch classes
      // corner classes on the previously active header stay after the animation
      active.removeClass('ui-accordion-header-active ui-state-active');
      if (options.icons) {
        active.children('.ui-accordion-header-icon').removeClass(options.icons.activeHeader).addClass(options.icons.header);
      }
      if (!clickedIsActive) {
        clicked.removeClass('ui-corner-all').addClass('ui-accordion-header-active ui-state-active ui-corner-top');
        if (options.icons) {
          clicked.children('.ui-accordion-header-icon').removeClass(options.icons.header).addClass(options.icons.activeHeader);
        }
        clicked.next().addClass('ui-accordion-content-active');
      }
    },
    _toggle: function (data) {
      var toShow = data.newPanel, toHide = this.prevShow.length ? this.prevShow : data.oldPanel;
      // handle activating a panel during the animation for another activation
      this.prevShow.add(this.prevHide).stop(true, true);
      this.prevShow = toShow;
      this.prevHide = toHide;
      if (this.options.animate) {
        this._animate(toShow, toHide, data);
      } else {
        toHide.hide();
        toShow.show();
        this._toggleComplete(data);
      }
      toHide.attr({
        'aria-expanded': 'false',
        'aria-hidden': 'true'
      });
      toHide.prev().attr('aria-selected', 'false');
      // if we're switching panels, remove the old header from the tab order
      // if we're opening from collapsed state, remove the previous header from the tab order
      // if we're collapsing, then keep the collapsing header in the tab order
      if (toShow.length && toHide.length) {
        toHide.prev().attr('tabIndex', -1);
      } else if (toShow.length) {
        this.headers.filter(function () {
          return $(this).attr('tabIndex') === 0;
        }).attr('tabIndex', -1);
      }
      toShow.attr({
        'aria-expanded': 'true',
        'aria-hidden': 'false'
      }).prev().attr({
        'aria-selected': 'true',
        tabIndex: 0
      });
    },
    _animate: function (toShow, toHide, data) {
      var total, easing, duration, that = this, adjust = 0, down = toShow.length && (!toHide.length || toShow.index() < toHide.index()), animate = this.options.animate || {}, options = down && animate.down || animate, complete = function () {
          that._toggleComplete(data);
        };
      if (typeof options === 'number') {
        duration = options;
      }
      if (typeof options === 'string') {
        easing = options;
      }
      // fall back from options to animation in case of partial down settings
      easing = easing || options.easing || animate.easing;
      duration = duration || options.duration || animate.duration;
      if (!toHide.length) {
        return toShow.animate(showProps, duration, easing, complete);
      }
      if (!toShow.length) {
        return toHide.animate(hideProps, duration, easing, complete);
      }
      total = toShow.show().outerHeight();
      toHide.animate(hideProps, {
        duration: duration,
        easing: easing,
        step: function (now, fx) {
          fx.now = Math.round(now);
        }
      });
      toShow.hide().animate(showProps, {
        duration: duration,
        easing: easing,
        complete: complete,
        step: function (now, fx) {
          fx.now = Math.round(now);
          if (fx.prop !== 'height') {
            adjust += fx.now;
          } else if (that.options.heightStyle !== 'content') {
            fx.now = Math.round(total - toHide.outerHeight() - adjust);
            adjust = 0;
          }
        }
      });
    },
    _toggleComplete: function (data) {
      var toHide = data.oldPanel;
      toHide.removeClass('ui-accordion-content-active').prev().removeClass('ui-corner-top').addClass('ui-corner-all');
      // Work around for rendering bug in IE (#5421)
      if (toHide.length) {
        toHide.parent()[0].className = toHide.parent()[0].className;
      }
      this._trigger('activate', null, data);
    }
  });
}(jQuery));
(function ($, undefined) {
  // used to prevent race conditions with remote data sources
  var requestIndex = 0;
  $.widget('ui.autocomplete', {
    version: '1.10.3',
    defaultElement: '<input>',
    options: {
      appendTo: null,
      autoFocus: false,
      delay: 300,
      minLength: 1,
      position: {
        my: 'left top',
        at: 'left bottom',
        collision: 'none'
      },
      source: null,
      change: null,
      close: null,
      focus: null,
      open: null,
      response: null,
      search: null,
      select: null
    },
    pending: 0,
    _create: function () {
      // Some browsers only repeat keydown events, not keypress events,
      // so we use the suppressKeyPress flag to determine if we've already
      // handled the keydown event. #7269
      // Unfortunately the code for & in keypress is the same as the up arrow,
      // so we use the suppressKeyPressRepeat flag to avoid handling keypress
      // events when we know the keydown event was used to modify the
      // search term. #7799
      var suppressKeyPress, suppressKeyPressRepeat, suppressInput, nodeName = this.element[0].nodeName.toLowerCase(), isTextarea = nodeName === 'textarea', isInput = nodeName === 'input';
      this.isMultiLine = isTextarea ? true : isInput ? false : this.element.prop('isContentEditable');
      this.valueMethod = this.element[isTextarea || isInput ? 'val' : 'text'];
      this.isNewMenu = true;
      this.element.addClass('ui-autocomplete-input').attr('autocomplete', 'off');
      this._on(this.element, {
        keydown: function (event) {
          /*jshint maxcomplexity:15*/
          if (this.element.prop('readOnly')) {
            suppressKeyPress = true;
            suppressInput = true;
            suppressKeyPressRepeat = true;
            return;
          }
          suppressKeyPress = false;
          suppressInput = false;
          suppressKeyPressRepeat = false;
          var keyCode = $.ui.keyCode;
          switch (event.keyCode) {
          case keyCode.PAGE_UP:
            suppressKeyPress = true;
            this._move('previousPage', event);
            break;
          case keyCode.PAGE_DOWN:
            suppressKeyPress = true;
            this._move('nextPage', event);
            break;
          case keyCode.UP:
            suppressKeyPress = true;
            this._keyEvent('previous', event);
            break;
          case keyCode.DOWN:
            suppressKeyPress = true;
            this._keyEvent('next', event);
            break;
          case keyCode.ENTER:
          case keyCode.NUMPAD_ENTER:
            // when menu is open and has focus
            if (this.menu.active) {
              // #6055 - Opera still allows the keypress to occur
              // which causes forms to submit
              suppressKeyPress = true;
              event.preventDefault();
              this.menu.select(event);
            }
            break;
          case keyCode.TAB:
            if (this.menu.active) {
              this.menu.select(event);
            }
            break;
          case keyCode.ESCAPE:
            if (this.menu.element.is(':visible')) {
              this._value(this.term);
              this.close(event);
              // Different browsers have different default behavior for escape
              // Single press can mean undo or clear
              // Double press in IE means clear the whole form
              event.preventDefault();
            }
            break;
          default:
            suppressKeyPressRepeat = true;
            // search timeout should be triggered before the input value is changed
            this._searchTimeout(event);
            break;
          }
        },
        keypress: function (event) {
          if (suppressKeyPress) {
            suppressKeyPress = false;
            if (!this.isMultiLine || this.menu.element.is(':visible')) {
              event.preventDefault();
            }
            return;
          }
          if (suppressKeyPressRepeat) {
            return;
          }
          // replicate some key handlers to allow them to repeat in Firefox and Opera
          var keyCode = $.ui.keyCode;
          switch (event.keyCode) {
          case keyCode.PAGE_UP:
            this._move('previousPage', event);
            break;
          case keyCode.PAGE_DOWN:
            this._move('nextPage', event);
            break;
          case keyCode.UP:
            this._keyEvent('previous', event);
            break;
          case keyCode.DOWN:
            this._keyEvent('next', event);
            break;
          }
        },
        input: function (event) {
          if (suppressInput) {
            suppressInput = false;
            event.preventDefault();
            return;
          }
          this._searchTimeout(event);
        },
        focus: function () {
          this.selectedItem = null;
          this.previous = this._value();
        },
        blur: function (event) {
          if (this.cancelBlur) {
            delete this.cancelBlur;
            return;
          }
          clearTimeout(this.searching);
          this.close(event);
          this._change(event);
        }
      });
      this._initSource();
      this.menu = $('<ul>').addClass('ui-autocomplete ui-front').appendTo(this._appendTo()).menu({ role: null }).hide().data('ui-menu');
      this._on(this.menu.element, {
        mousedown: function (event) {
          // prevent moving focus out of the text field
          event.preventDefault();
          // IE doesn't prevent moving focus even with event.preventDefault()
          // so we set a flag to know when we should ignore the blur event
          this.cancelBlur = true;
          this._delay(function () {
            delete this.cancelBlur;
          });
          // clicking on the scrollbar causes focus to shift to the body
          // but we can't detect a mouseup or a click immediately afterward
          // so we have to track the next mousedown and close the menu if
          // the user clicks somewhere outside of the autocomplete
          var menuElement = this.menu.element[0];
          if (!$(event.target).closest('.ui-menu-item').length) {
            this._delay(function () {
              var that = this;
              this.document.one('mousedown', function (event) {
                if (event.target !== that.element[0] && event.target !== menuElement && !$.contains(menuElement, event.target)) {
                  that.close();
                }
              });
            });
          }
        },
        menufocus: function (event, ui) {
          // support: Firefox
          // Prevent accidental activation of menu items in Firefox (#7024 #9118)
          if (this.isNewMenu) {
            this.isNewMenu = false;
            if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {
              this.menu.blur();
              this.document.one('mousemove', function () {
                $(event.target).trigger(event.originalEvent);
              });
              return;
            }
          }
          var item = ui.item.data('ui-autocomplete-item');
          if (false !== this._trigger('focus', event, { item: item })) {
            // use value to match what will end up in the input, if it was a key event
            if (event.originalEvent && /^key/.test(event.originalEvent.type)) {
              this._value(item.value);
            }
          } else {
            // Normally the input is populated with the item's value as the
            // menu is navigated, causing screen readers to notice a change and
            // announce the item. Since the focus event was canceled, this doesn't
            // happen, so we update the live region so that screen readers can
            // still notice the change and announce it.
            this.liveRegion.text(item.value);
          }
        },
        menuselect: function (event, ui) {
          var item = ui.item.data('ui-autocomplete-item'), previous = this.previous;
          // only trigger when focus was lost (click on menu)
          if (this.element[0] !== this.document[0].activeElement) {
            this.element.focus();
            this.previous = previous;
            // #6109 - IE triggers two focus events and the second
            // is asynchronous, so we need to reset the previous
            // term synchronously and asynchronously :-(
            this._delay(function () {
              this.previous = previous;
              this.selectedItem = item;
            });
          }
          if (false !== this._trigger('select', event, { item: item })) {
            this._value(item.value);
          }
          // reset the term after the select event
          // this allows custom select handling to work properly
          this.term = this._value();
          this.close(event);
          this.selectedItem = item;
        }
      });
      this.liveRegion = $('<span>', {
        role: 'status',
        'aria-live': 'polite'
      }).addClass('ui-helper-hidden-accessible').insertBefore(this.element);
      // turning off autocomplete prevents the browser from remembering the
      // value when navigating through history, so we re-enable autocomplete
      // if the page is unloaded before the widget is destroyed. #7790
      this._on(this.window, {
        beforeunload: function () {
          this.element.removeAttr('autocomplete');
        }
      });
    },
    _destroy: function () {
      clearTimeout(this.searching);
      this.element.removeClass('ui-autocomplete-input').removeAttr('autocomplete');
      this.menu.element.remove();
      this.liveRegion.remove();
    },
    _setOption: function (key, value) {
      this._super(key, value);
      if (key === 'source') {
        this._initSource();
      }
      if (key === 'appendTo') {
        this.menu.element.appendTo(this._appendTo());
      }
      if (key === 'disabled' && value && this.xhr) {
        this.xhr.abort();
      }
    },
    _appendTo: function () {
      var element = this.options.appendTo;
      if (element) {
        element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);
      }
      if (!element) {
        element = this.element.closest('.ui-front');
      }
      if (!element.length) {
        element = this.document[0].body;
      }
      return element;
    },
    _initSource: function () {
      var array, url, that = this;
      if ($.isArray(this.options.source)) {
        array = this.options.source;
        this.source = function (request, response) {
          response($.ui.autocomplete.filter(array, request.term));
        };
      } else if (typeof this.options.source === 'string') {
        url = this.options.source;
        this.source = function (request, response) {
          if (that.xhr) {
            that.xhr.abort();
          }
          that.xhr = $.ajax({
            url: url,
            data: request,
            dataType: 'json',
            success: function (data) {
              response(data);
            },
            error: function () {
              response([]);
            }
          });
        };
      } else {
        this.source = this.options.source;
      }
    },
    _searchTimeout: function (event) {
      clearTimeout(this.searching);
      this.searching = this._delay(function () {
        // only search if the value has changed
        if (this.term !== this._value()) {
          this.selectedItem = null;
          this.search(null, event);
        }
      }, this.options.delay);
    },
    search: function (value, event) {
      value = value != null ? value : this._value();
      // always save the actual value, not the one passed as an argument
      this.term = this._value();
      if (value.length < this.options.minLength) {
        return this.close(event);
      }
      if (this._trigger('search', event) === false) {
        return;
      }
      return this._search(value);
    },
    _search: function (value) {
      this.pending++;
      this.element.addClass('ui-autocomplete-loading');
      this.cancelSearch = false;
      this.source({ term: value }, this._response());
    },
    _response: function () {
      var that = this, index = ++requestIndex;
      return function (content) {
        if (index === requestIndex) {
          that.__response(content);
        }
        that.pending--;
        if (!that.pending) {
          that.element.removeClass('ui-autocomplete-loading');
        }
      };
    },
    __response: function (content) {
      if (content) {
        content = this._normalize(content);
      }
      this._trigger('response', null, { content: content });
      if (!this.options.disabled && content && content.length && !this.cancelSearch) {
        this._suggest(content);
        this._trigger('open');
      } else {
        // use ._close() instead of .close() so we don't cancel future searches
        this._close();
      }
    },
    close: function (event) {
      this.cancelSearch = true;
      this._close(event);
    },
    _close: function (event) {
      if (this.menu.element.is(':visible')) {
        this.menu.element.hide();
        this.menu.blur();
        this.isNewMenu = true;
        this._trigger('close', event);
      }
    },
    _change: function (event) {
      if (this.previous !== this._value()) {
        this._trigger('change', event, { item: this.selectedItem });
      }
    },
    _normalize: function (items) {
      // assume all items have the right format when the first item is complete
      if (items.length && items[0].label && items[0].value) {
        return items;
      }
      return $.map(items, function (item) {
        if (typeof item === 'string') {
          return {
            label: item,
            value: item
          };
        }
        return $.extend({
          label: item.label || item.value,
          value: item.value || item.label
        }, item);
      });
    },
    _suggest: function (items) {
      var ul = this.menu.element.empty();
      this._renderMenu(ul, items);
      this.isNewMenu = true;
      this.menu.refresh();
      // size and position menu
      ul.show();
      this._resizeMenu();
      ul.position($.extend({ of: this.element }, this.options.position));
      if (this.options.autoFocus) {
        this.menu.next();
      }
    },
    _resizeMenu: function () {
      var ul = this.menu.element;
      ul.outerWidth(Math.max(ul.width('').outerWidth() + 1, this.element.outerWidth()));
    },
    _renderMenu: function (ul, items) {
      var that = this;
      $.each(items, function (index, item) {
        that._renderItemData(ul, item);
      });
    },
    _renderItemData: function (ul, item) {
      return this._renderItem(ul, item).data('ui-autocomplete-item', item);
    },
    _renderItem: function (ul, item) {
      return $('<li>').append($('<a>').text(item.label)).appendTo(ul);
    },
    _move: function (direction, event) {
      if (!this.menu.element.is(':visible')) {
        this.search(null, event);
        return;
      }
      if (this.menu.isFirstItem() && /^previous/.test(direction) || this.menu.isLastItem() && /^next/.test(direction)) {
        this._value(this.term);
        this.menu.blur();
        return;
      }
      this.menu[direction](event);
    },
    widget: function () {
      return this.menu.element;
    },
    _value: function () {
      return this.valueMethod.apply(this.element, arguments);
    },
    _keyEvent: function (keyEvent, event) {
      if (!this.isMultiLine || this.menu.element.is(':visible')) {
        this._move(keyEvent, event);
        // prevents moving cursor to beginning/end of the text field in some browsers
        event.preventDefault();
      }
    }
  });
  $.extend($.ui.autocomplete, {
    escapeRegex: function (value) {
      return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
    },
    filter: function (array, term) {
      var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), 'i');
      return $.grep(array, function (value) {
        return matcher.test(value.label || value.value || value);
      });
    }
  });
  // live region extension, adding a `messages` option
  // NOTE: This is an experimental API. We are still investigating
  // a full solution for string manipulation and internationalization.
  $.widget('ui.autocomplete', $.ui.autocomplete, {
    options: {
      messages: {
        noResults: 'No search results.',
        results: function (amount) {
          return amount + (amount > 1 ? ' results are' : ' result is') + ' available, use up and down arrow keys to navigate.';
        }
      }
    },
    __response: function (content) {
      var message;
      this._superApply(arguments);
      if (this.options.disabled || this.cancelSearch) {
        return;
      }
      if (content && content.length) {
        message = this.options.messages.results(content.length);
      } else {
        message = this.options.messages.noResults;
      }
      this.liveRegion.text(message);
    }
  });
}(jQuery));
(function ($, undefined) {
  var lastActive, startXPos, startYPos, clickDragged, baseClasses = 'ui-button ui-widget ui-state-default ui-corner-all', stateClasses = 'ui-state-hover ui-state-active ', typeClasses = 'ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only', formResetHandler = function () {
      var form = $(this);
      setTimeout(function () {
        form.find(':ui-button').button('refresh');
      }, 1);
    }, radioGroup = function (radio) {
      var name = radio.name, form = radio.form, radios = $([]);
      if (name) {
        name = name.replace(/'/g, '\\\'');
        if (form) {
          radios = $(form).find('[name=\'' + name + '\']');
        } else {
          radios = $('[name=\'' + name + '\']', radio.ownerDocument).filter(function () {
            return !this.form;
          });
        }
      }
      return radios;
    };
  $.widget('ui.button', {
    version: '1.10.3',
    defaultElement: '<button>',
    options: {
      disabled: null,
      text: true,
      label: null,
      icons: {
        primary: null,
        secondary: null
      }
    },
    _create: function () {
      this.element.closest('form').unbind('reset' + this.eventNamespace).bind('reset' + this.eventNamespace, formResetHandler);
      if (typeof this.options.disabled !== 'boolean') {
        this.options.disabled = !!this.element.prop('disabled');
      } else {
        this.element.prop('disabled', this.options.disabled);
      }
      this._determineButtonType();
      this.hasTitle = !!this.buttonElement.attr('title');
      var that = this, options = this.options, toggleButton = this.type === 'checkbox' || this.type === 'radio', activeClass = !toggleButton ? 'ui-state-active' : '', focusClass = 'ui-state-focus';
      if (options.label === null) {
        options.label = this.type === 'input' ? this.buttonElement.val() : this.buttonElement.html();
      }
      this._hoverable(this.buttonElement);
      this.buttonElement.addClass(baseClasses).attr('role', 'button').bind('mouseenter' + this.eventNamespace, function () {
        if (options.disabled) {
          return;
        }
        if (this === lastActive) {
          $(this).addClass('ui-state-active');
        }
      }).bind('mouseleave' + this.eventNamespace, function () {
        if (options.disabled) {
          return;
        }
        $(this).removeClass(activeClass);
      }).bind('click' + this.eventNamespace, function (event) {
        if (options.disabled) {
          event.preventDefault();
          event.stopImmediatePropagation();
        }
      });
      this.element.bind('focus' + this.eventNamespace, function () {
        // no need to check disabled, focus won't be triggered anyway
        that.buttonElement.addClass(focusClass);
      }).bind('blur' + this.eventNamespace, function () {
        that.buttonElement.removeClass(focusClass);
      });
      if (toggleButton) {
        this.element.bind('change' + this.eventNamespace, function () {
          if (clickDragged) {
            return;
          }
          that.refresh();
        });
        // if mouse moves between mousedown and mouseup (drag) set clickDragged flag
        // prevents issue where button state changes but checkbox/radio checked state
        // does not in Firefox (see ticket #6970)
        this.buttonElement.bind('mousedown' + this.eventNamespace, function (event) {
          if (options.disabled) {
            return;
          }
          clickDragged = false;
          startXPos = event.pageX;
          startYPos = event.pageY;
        }).bind('mouseup' + this.eventNamespace, function (event) {
          if (options.disabled) {
            return;
          }
          if (startXPos !== event.pageX || startYPos !== event.pageY) {
            clickDragged = true;
          }
        });
      }
      if (this.type === 'checkbox') {
        this.buttonElement.bind('click' + this.eventNamespace, function () {
          if (options.disabled || clickDragged) {
            return false;
          }
        });
      } else if (this.type === 'radio') {
        this.buttonElement.bind('click' + this.eventNamespace, function () {
          if (options.disabled || clickDragged) {
            return false;
          }
          $(this).addClass('ui-state-active');
          that.buttonElement.attr('aria-pressed', 'true');
          var radio = that.element[0];
          radioGroup(radio).not(radio).map(function () {
            return $(this).button('widget')[0];
          }).removeClass('ui-state-active').attr('aria-pressed', 'false');
        });
      } else {
        this.buttonElement.bind('mousedown' + this.eventNamespace, function () {
          if (options.disabled) {
            return false;
          }
          $(this).addClass('ui-state-active');
          lastActive = this;
          that.document.one('mouseup', function () {
            lastActive = null;
          });
        }).bind('mouseup' + this.eventNamespace, function () {
          if (options.disabled) {
            return false;
          }
          $(this).removeClass('ui-state-active');
        }).bind('keydown' + this.eventNamespace, function (event) {
          if (options.disabled) {
            return false;
          }
          if (event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER) {
            $(this).addClass('ui-state-active');
          }
        }).bind('keyup' + this.eventNamespace + ' blur' + this.eventNamespace, function () {
          $(this).removeClass('ui-state-active');
        });
        if (this.buttonElement.is('a')) {
          this.buttonElement.keyup(function (event) {
            if (event.keyCode === $.ui.keyCode.SPACE) {
              // TODO pass through original event correctly (just as 2nd argument doesn't work)
              $(this).click();
            }
          });
        }
      }
      // TODO: pull out $.Widget's handling for the disabled option into
      // $.Widget.prototype._setOptionDisabled so it's easy to proxy and can
      // be overridden by individual plugins
      this._setOption('disabled', options.disabled);
      this._resetButton();
    },
    _determineButtonType: function () {
      var ancestor, labelSelector, checked;
      if (this.element.is('[type=checkbox]')) {
        this.type = 'checkbox';
      } else if (this.element.is('[type=radio]')) {
        this.type = 'radio';
      } else if (this.element.is('input')) {
        this.type = 'input';
      } else {
        this.type = 'button';
      }
      if (this.type === 'checkbox' || this.type === 'radio') {
        // we don't search against the document in case the element
        // is disconnected from the DOM
        ancestor = this.element.parents().last();
        labelSelector = 'label[for=\'' + this.element.attr('id') + '\']';
        this.buttonElement = ancestor.find(labelSelector);
        if (!this.buttonElement.length) {
          ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
          this.buttonElement = ancestor.filter(labelSelector);
          if (!this.buttonElement.length) {
            this.buttonElement = ancestor.find(labelSelector);
          }
        }
        this.element.addClass('ui-helper-hidden-accessible');
        checked = this.element.is(':checked');
        if (checked) {
          this.buttonElement.addClass('ui-state-active');
        }
        this.buttonElement.prop('aria-pressed', checked);
      } else {
        this.buttonElement = this.element;
      }
    },
    widget: function () {
      return this.buttonElement;
    },
    _destroy: function () {
      this.element.removeClass('ui-helper-hidden-accessible');
      this.buttonElement.removeClass(baseClasses + ' ' + stateClasses + ' ' + typeClasses).removeAttr('role').removeAttr('aria-pressed').html(this.buttonElement.find('.ui-button-text').html());
      if (!this.hasTitle) {
        this.buttonElement.removeAttr('title');
      }
    },
    _setOption: function (key, value) {
      this._super(key, value);
      if (key === 'disabled') {
        if (value) {
          this.element.prop('disabled', true);
        } else {
          this.element.prop('disabled', false);
        }
        return;
      }
      this._resetButton();
    },
    refresh: function () {
      //See #8237 & #8828
      var isDisabled = this.element.is('input, button') ? this.element.is(':disabled') : this.element.hasClass('ui-button-disabled');
      if (isDisabled !== this.options.disabled) {
        this._setOption('disabled', isDisabled);
      }
      if (this.type === 'radio') {
        radioGroup(this.element[0]).each(function () {
          if ($(this).is(':checked')) {
            $(this).button('widget').addClass('ui-state-active').attr('aria-pressed', 'true');
          } else {
            $(this).button('widget').removeClass('ui-state-active').attr('aria-pressed', 'false');
          }
        });
      } else if (this.type === 'checkbox') {
        if (this.element.is(':checked')) {
          this.buttonElement.addClass('ui-state-active').attr('aria-pressed', 'true');
        } else {
          this.buttonElement.removeClass('ui-state-active').attr('aria-pressed', 'false');
        }
      }
    },
    _resetButton: function () {
      if (this.type === 'input') {
        if (this.options.label) {
          this.element.val(this.options.label);
        }
        return;
      }
      var buttonElement = this.buttonElement.removeClass(typeClasses), buttonText = $('<span></span>', this.document[0]).addClass('ui-button-text').html(this.options.label).appendTo(buttonElement.empty()).text(), icons = this.options.icons, multipleIcons = icons.primary && icons.secondary, buttonClasses = [];
      if (icons.primary || icons.secondary) {
        if (this.options.text) {
          buttonClasses.push('ui-button-text-icon' + (multipleIcons ? 's' : icons.primary ? '-primary' : '-secondary'));
        }
        if (icons.primary) {
          buttonElement.prepend('<span class=\'ui-button-icon-primary ui-icon ' + icons.primary + '\'></span>');
        }
        if (icons.secondary) {
          buttonElement.append('<span class=\'ui-button-icon-secondary ui-icon ' + icons.secondary + '\'></span>');
        }
        if (!this.options.text) {
          buttonClasses.push(multipleIcons ? 'ui-button-icons-only' : 'ui-button-icon-only');
          if (!this.hasTitle) {
            buttonElement.attr('title', $.trim(buttonText));
          }
        }
      } else {
        buttonClasses.push('ui-button-text-only');
      }
      buttonElement.addClass(buttonClasses.join(' '));
    }
  });
  $.widget('ui.buttonset', {
    version: '1.10.3',
    options: { items: 'button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)' },
    _create: function () {
      this.element.addClass('ui-buttonset');
    },
    _init: function () {
      this.refresh();
    },
    _setOption: function (key, value) {
      if (key === 'disabled') {
        this.buttons.button('option', key, value);
      }
      this._super(key, value);
    },
    refresh: function () {
      var rtl = this.element.css('direction') === 'rtl';
      this.buttons = this.element.find(this.options.items).filter(':ui-button').button('refresh').end().not(':ui-button').button().end().map(function () {
        return $(this).button('widget')[0];
      }).removeClass('ui-corner-all ui-corner-left ui-corner-right').filter(':first').addClass(rtl ? 'ui-corner-right' : 'ui-corner-left').end().filter(':last').addClass(rtl ? 'ui-corner-left' : 'ui-corner-right').end().end();
    },
    _destroy: function () {
      this.element.removeClass('ui-buttonset');
      this.buttons.map(function () {
        return $(this).button('widget')[0];
      }).removeClass('ui-corner-left ui-corner-right').end().button('destroy');
    }
  });
}(jQuery));
(function ($, undefined) {
  $.extend($.ui, { datepicker: { version: '1.10.3' } });
  var PROP_NAME = 'datepicker', instActive;
  /* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */
  function Datepicker() {
    this._curInst = null;
    // The current instance in use
    this._keyEvent = false;
    // If the last event was a key event
    this._disabledInputs = [];
    // List of date picker inputs that have been disabled
    this._datepickerShowing = false;
    // True if the popup picker is showing , false if not
    this._inDialog = false;
    // True if showing within a "dialog", false if not
    this._mainDivId = 'ui-datepicker-div';
    // The ID of the main datepicker division
    this._inlineClass = 'ui-datepicker-inline';
    // The name of the inline marker class
    this._appendClass = 'ui-datepicker-append';
    // The name of the append marker class
    this._triggerClass = 'ui-datepicker-trigger';
    // The name of the trigger marker class
    this._dialogClass = 'ui-datepicker-dialog';
    // The name of the dialog marker class
    this._disableClass = 'ui-datepicker-disabled';
    // The name of the disabled covering marker class
    this._unselectableClass = 'ui-datepicker-unselectable';
    // The name of the unselectable cell marker class
    this._currentClass = 'ui-datepicker-current-day';
    // The name of the current day marker class
    this._dayOverClass = 'ui-datepicker-days-cell-over';
    // The name of the day hover marker class
    this.regional = [];
    // Available regional settings, indexed by language code
    this.regional[''] = {
      closeText: 'Done',
      prevText: 'Prev',
      nextText: 'Next',
      currentText: 'Today',
      monthNames: [
        'January',
        'February',
        'March',
        'April',
        'May',
        'June',
        'July',
        'August',
        'September',
        'October',
        'November',
        'December'
      ],
      monthNamesShort: [
        'Jan',
        'Feb',
        'Mar',
        'Apr',
        'May',
        'Jun',
        'Jul',
        'Aug',
        'Sep',
        'Oct',
        'Nov',
        'Dec'
      ],
      dayNames: [
        'Sunday',
        'Monday',
        'Tuesday',
        'Wednesday',
        'Thursday',
        'Friday',
        'Saturday'
      ],
      dayNamesShort: [
        'Sun',
        'Mon',
        'Tue',
        'Wed',
        'Thu',
        'Fri',
        'Sat'
      ],
      dayNamesMin: [
        'Su',
        'Mo',
        'Tu',
        'We',
        'Th',
        'Fr',
        'Sa'
      ],
      weekHeader: 'Wk',
      dateFormat: 'mm/dd/yy',
      firstDay: 0,
      isRTL: false,
      showMonthAfterYear: false,
      yearSuffix: ''
    };
    this._defaults = {
      showOn: 'focus',
      showAnim: 'fadeIn',
      showOptions: {},
      defaultDate: null,
      appendText: '',
      buttonText: '...',
      buttonImage: '',
      buttonImageOnly: false,
      hideIfNoPrevNext: false,
      navigationAsDateFormat: false,
      gotoCurrent: false,
      changeMonth: false,
      changeYear: false,
      yearRange: 'c-10:c+10',
      showOtherMonths: false,
      selectOtherMonths: false,
      showWeek: false,
      calculateWeek: this.iso8601Week,
      shortYearCutoff: '+10',
      minDate: null,
      maxDate: null,
      duration: 'fast',
      beforeShowDay: null,
      beforeShow: null,
      onSelect: null,
      onChangeMonthYear: null,
      onClose: null,
      numberOfMonths: 1,
      showCurrentAtPos: 0,
      stepMonths: 1,
      stepBigMonths: 12,
      altField: '',
      altFormat: '',
      constrainInput: true,
      showButtonPanel: false,
      autoSize: false,
      disabled: false
    };
    $.extend(this._defaults, this.regional['']);
    this.dpDiv = bindHover($('<div id=\'' + this._mainDivId + '\' class=\'ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all\'></div>'));
  }
  $.extend(Datepicker.prototype, {
    markerClassName: 'hasDatepicker',
    maxRows: 4,
    _widgetDatepicker: function () {
      return this.dpDiv;
    },
    setDefaults: function (settings) {
      extendRemove(this._defaults, settings || {});
      return this;
    },
    _attachDatepicker: function (target, settings) {
      var nodeName, inline, inst;
      nodeName = target.nodeName.toLowerCase();
      inline = nodeName === 'div' || nodeName === 'span';
      if (!target.id) {
        this.uuid += 1;
        target.id = 'dp' + this.uuid;
      }
      inst = this._newInst($(target), inline);
      inst.settings = $.extend({}, settings || {});
      if (nodeName === 'input') {
        this._connectDatepicker(target, inst);
      } else if (inline) {
        this._inlineDatepicker(target, inst);
      }
    },
    _newInst: function (target, inline) {
      var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, '\\\\$1');
      // escape jQuery meta chars
      return {
        id: id,
        input: target,
        selectedDay: 0,
        selectedMonth: 0,
        selectedYear: 0,
        drawMonth: 0,
        drawYear: 0,
        inline: inline,
        dpDiv: !inline ? this.dpDiv : bindHover($('<div class=\'' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all\'></div>'))
      };
    },
    _connectDatepicker: function (target, inst) {
      var input = $(target);
      inst.append = $([]);
      inst.trigger = $([]);
      if (input.hasClass(this.markerClassName)) {
        return;
      }
      this._attachments(input, inst);
      input.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp);
      this._autoSize(inst);
      $.data(target, PROP_NAME, inst);
      //If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
      if (inst.settings.disabled) {
        this._disableDatepicker(target);
      }
    },
    _attachments: function (input, inst) {
      var showOn, buttonText, buttonImage, appendText = this._get(inst, 'appendText'), isRTL = this._get(inst, 'isRTL');
      if (inst.append) {
        inst.append.remove();
      }
      if (appendText) {
        inst.append = $('<span class=\'' + this._appendClass + '\'>' + appendText + '</span>');
        input[isRTL ? 'before' : 'after'](inst.append);
      }
      input.unbind('focus', this._showDatepicker);
      if (inst.trigger) {
        inst.trigger.remove();
      }
      showOn = this._get(inst, 'showOn');
      if (showOn === 'focus' || showOn === 'both') {
        // pop-up date picker when in the marked field
        input.focus(this._showDatepicker);
      }
      if (showOn === 'button' || showOn === 'both') {
        // pop-up date picker when button clicked
        buttonText = this._get(inst, 'buttonText');
        buttonImage = this._get(inst, 'buttonImage');
        inst.trigger = $(this._get(inst, 'buttonImageOnly') ? $('<img/>').addClass(this._triggerClass).attr({
          src: buttonImage,
          alt: buttonText,
          title: buttonText
        }) : $('<button type=\'button\'></button>').addClass(this._triggerClass).html(!buttonImage ? buttonText : $('<img/>').attr({
          src: buttonImage,
          alt: buttonText,
          title: buttonText
        })));
        input[isRTL ? 'before' : 'after'](inst.trigger);
        inst.trigger.click(function () {
          if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
            $.datepicker._hideDatepicker();
          } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
            $.datepicker._hideDatepicker();
            $.datepicker._showDatepicker(input[0]);
          } else {
            $.datepicker._showDatepicker(input[0]);
          }
          return false;
        });
      }
    },
    _autoSize: function (inst) {
      if (this._get(inst, 'autoSize') && !inst.inline) {
        var findMax, max, maxI, i, date = new Date(2009, 12 - 1, 20),
          // Ensure double digits
          dateFormat = this._get(inst, 'dateFormat');
        if (dateFormat.match(/[DM]/)) {
          findMax = function (names) {
            max = 0;
            maxI = 0;
            for (i = 0; i < names.length; i++) {
              if (names[i].length > max) {
                max = names[i].length;
                maxI = i;
              }
            }
            return maxI;
          };
          date.setMonth(findMax(this._get(inst, dateFormat.match(/MM/) ? 'monthNames' : 'monthNamesShort')));
          date.setDate(findMax(this._get(inst, dateFormat.match(/DD/) ? 'dayNames' : 'dayNamesShort')) + 20 - date.getDay());
        }
        inst.input.attr('size', this._formatDate(inst, date).length);
      }
    },
    _inlineDatepicker: function (target, inst) {
      var divSpan = $(target);
      if (divSpan.hasClass(this.markerClassName)) {
        return;
      }
      divSpan.addClass(this.markerClassName).append(inst.dpDiv);
      $.data(target, PROP_NAME, inst);
      this._setDate(inst, this._getDefaultDate(inst), true);
      this._updateDatepicker(inst);
      this._updateAlternate(inst);
      //If disabled option is true, disable the datepicker before showing it (see ticket #5665)
      if (inst.settings.disabled) {
        this._disableDatepicker(target);
      }
      // Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
      // http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
      inst.dpDiv.css('display', 'block');
    },
    _dialogDatepicker: function (input, date, onSelect, settings, pos) {
      var id, browserWidth, browserHeight, scrollX, scrollY, inst = this._dialogInst;
      // internal instance
      if (!inst) {
        this.uuid += 1;
        id = 'dp' + this.uuid;
        this._dialogInput = $('<input type=\'text\' id=\'' + id + '\' style=\'position: absolute; top: -100px; width: 0px;\'/>');
        this._dialogInput.keydown(this._doKeyDown);
        $('body').append(this._dialogInput);
        inst = this._dialogInst = this._newInst(this._dialogInput, false);
        inst.settings = {};
        $.data(this._dialogInput[0], PROP_NAME, inst);
      }
      extendRemove(inst.settings, settings || {});
      date = date && date.constructor === Date ? this._formatDate(inst, date) : date;
      this._dialogInput.val(date);
      this._pos = pos ? pos.length ? pos : [
        pos.pageX,
        pos.pageY
      ] : null;
      if (!this._pos) {
        browserWidth = document.documentElement.clientWidth;
        browserHeight = document.documentElement.clientHeight;
        scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
        scrollY = document.documentElement.scrollTop || document.body.scrollTop;
        this._pos = [
          browserWidth / 2 - 100 + scrollX,
          browserHeight / 2 - 150 + scrollY
        ];
      }
      // move input on screen for focus, but hidden behind dialog
      this._dialogInput.css('left', this._pos[0] + 20 + 'px').css('top', this._pos[1] + 'px');
      inst.settings.onSelect = onSelect;
      this._inDialog = true;
      this.dpDiv.addClass(this._dialogClass);
      this._showDatepicker(this._dialogInput[0]);
      if ($.blockUI) {
        $.blockUI(this.dpDiv);
      }
      $.data(this._dialogInput[0], PROP_NAME, inst);
      return this;
    },
    _destroyDatepicker: function (target) {
      var nodeName, $target = $(target), inst = $.data(target, PROP_NAME);
      if (!$target.hasClass(this.markerClassName)) {
        return;
      }
      nodeName = target.nodeName.toLowerCase();
      $.removeData(target, PROP_NAME);
      if (nodeName === 'input') {
        inst.append.remove();
        inst.trigger.remove();
        $target.removeClass(this.markerClassName).unbind('focus', this._showDatepicker).unbind('keydown', this._doKeyDown).unbind('keypress', this._doKeyPress).unbind('keyup', this._doKeyUp);
      } else if (nodeName === 'div' || nodeName === 'span') {
        $target.removeClass(this.markerClassName).empty();
      }
    },
    _enableDatepicker: function (target) {
      var nodeName, inline, $target = $(target), inst = $.data(target, PROP_NAME);
      if (!$target.hasClass(this.markerClassName)) {
        return;
      }
      nodeName = target.nodeName.toLowerCase();
      if (nodeName === 'input') {
        target.disabled = false;
        inst.trigger.filter('button').each(function () {
          this.disabled = false;
        }).end().filter('img').css({
          opacity: '1.0',
          cursor: ''
        });
      } else if (nodeName === 'div' || nodeName === 'span') {
        inline = $target.children('.' + this._inlineClass);
        inline.children().removeClass('ui-state-disabled');
        inline.find('select.ui-datepicker-month, select.ui-datepicker-year').prop('disabled', false);
      }
      this._disabledInputs = $.map(this._disabledInputs, function (value) {
        return value === target ? null : value;
      });  // delete entry
    },
    _disableDatepicker: function (target) {
      var nodeName, inline, $target = $(target), inst = $.data(target, PROP_NAME);
      if (!$target.hasClass(this.markerClassName)) {
        return;
      }
      nodeName = target.nodeName.toLowerCase();
      if (nodeName === 'input') {
        target.disabled = true;
        inst.trigger.filter('button').each(function () {
          this.disabled = true;
        }).end().filter('img').css({
          opacity: '0.5',
          cursor: 'default'
        });
      } else if (nodeName === 'div' || nodeName === 'span') {
        inline = $target.children('.' + this._inlineClass);
        inline.children().addClass('ui-state-disabled');
        inline.find('select.ui-datepicker-month, select.ui-datepicker-year').prop('disabled', true);
      }
      this._disabledInputs = $.map(this._disabledInputs, function (value) {
        return value === target ? null : value;
      });
      // delete entry
      this._disabledInputs[this._disabledInputs.length] = target;
    },
    _isDisabledDatepicker: function (target) {
      if (!target) {
        return false;
      }
      for (var i = 0; i < this._disabledInputs.length; i++) {
        if (this._disabledInputs[i] === target) {
          return true;
        }
      }
      return false;
    },
    _getInst: function (target) {
      try {
        return $.data(target, PROP_NAME);
      } catch (err) {
        throw 'Missing instance data for this datepicker';
      }
    },
    _optionDatepicker: function (target, name, value) {
      var settings, date, minDate, maxDate, inst = this._getInst(target);
      if (arguments.length === 2 && typeof name === 'string') {
        return name === 'defaults' ? $.extend({}, $.datepicker._defaults) : inst ? name === 'all' ? $.extend({}, inst.settings) : this._get(inst, name) : null;
      }
      settings = name || {};
      if (typeof name === 'string') {
        settings = {};
        settings[name] = value;
      }
      if (inst) {
        if (this._curInst === inst) {
          this._hideDatepicker();
        }
        date = this._getDateDatepicker(target, true);
        minDate = this._getMinMaxDate(inst, 'min');
        maxDate = this._getMinMaxDate(inst, 'max');
        extendRemove(inst.settings, settings);
        // reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
        if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
          inst.settings.minDate = this._formatDate(inst, minDate);
        }
        if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
          inst.settings.maxDate = this._formatDate(inst, maxDate);
        }
        if ('disabled' in settings) {
          if (settings.disabled) {
            this._disableDatepicker(target);
          } else {
            this._enableDatepicker(target);
          }
        }
        this._attachments($(target), inst);
        this._autoSize(inst);
        this._setDate(inst, date);
        this._updateAlternate(inst);
        this._updateDatepicker(inst);
      }
    },
    _changeDatepicker: function (target, name, value) {
      this._optionDatepicker(target, name, value);
    },
    _refreshDatepicker: function (target) {
      var inst = this._getInst(target);
      if (inst) {
        this._updateDatepicker(inst);
      }
    },
    _setDateDatepicker: function (target, date) {
      var inst = this._getInst(target);
      if (inst) {
        this._setDate(inst, date);
        this._updateDatepicker(inst);
        this._updateAlternate(inst);
      }
    },
    _getDateDatepicker: function (target, noDefault) {
      var inst = this._getInst(target);
      if (inst && !inst.inline) {
        this._setDateFromField(inst, noDefault);
      }
      return inst ? this._getDate(inst) : null;
    },
    _doKeyDown: function (event) {
      var onSelect, dateStr, sel, inst = $.datepicker._getInst(event.target), handled = true, isRTL = inst.dpDiv.is('.ui-datepicker-rtl');
      inst._keyEvent = true;
      if ($.datepicker._datepickerShowing) {
        switch (event.keyCode) {
        case 9:
          $.datepicker._hideDatepicker();
          handled = false;
          break;
        // hide on tab out
        case 13:
          sel = $('td.' + $.datepicker._dayOverClass + ':not(.' + $.datepicker._currentClass + ')', inst.dpDiv);
          if (sel[0]) {
            $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
          }
          onSelect = $.datepicker._get(inst, 'onSelect');
          if (onSelect) {
            dateStr = $.datepicker._formatDate(inst);
            // trigger custom callback
            onSelect.apply(inst.input ? inst.input[0] : null, [
              dateStr,
              inst
            ]);
          } else {
            $.datepicker._hideDatepicker();
          }
          return false;
        // don't submit the form
        case 27:
          $.datepicker._hideDatepicker();
          break;
        // hide on escape
        case 33:
          $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, 'stepBigMonths') : -$.datepicker._get(inst, 'stepMonths'), 'M');
          break;
        // previous month/year on page up/+ ctrl
        case 34:
          $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, 'stepBigMonths') : +$.datepicker._get(inst, 'stepMonths'), 'M');
          break;
        // next month/year on page down/+ ctrl
        case 35:
          if (event.ctrlKey || event.metaKey) {
            $.datepicker._clearDate(event.target);
          }
          handled = event.ctrlKey || event.metaKey;
          break;
        // clear on ctrl or command +end
        case 36:
          if (event.ctrlKey || event.metaKey) {
            $.datepicker._gotoToday(event.target);
          }
          handled = event.ctrlKey || event.metaKey;
          break;
        // current on ctrl or command +home
        case 37:
          if (event.ctrlKey || event.metaKey) {
            $.datepicker._adjustDate(event.target, isRTL ? +1 : -1, 'D');
          }
          handled = event.ctrlKey || event.metaKey;
          // -1 day on ctrl or command +left
          if (event.originalEvent.altKey) {
            $.datepicker._adjustDate(event.target, event.ctrlKey ? -$.datepicker._get(inst, 'stepBigMonths') : -$.datepicker._get(inst, 'stepMonths'), 'M');
          }
          // next month/year on alt +left on Mac
          break;
        case 38:
          if (event.ctrlKey || event.metaKey) {
            $.datepicker._adjustDate(event.target, -7, 'D');
          }
          handled = event.ctrlKey || event.metaKey;
          break;
        // -1 week on ctrl or command +up
        case 39:
          if (event.ctrlKey || event.metaKey) {
            $.datepicker._adjustDate(event.target, isRTL ? -1 : +1, 'D');
          }
          handled = event.ctrlKey || event.metaKey;
          // +1 day on ctrl or command +right
          if (event.originalEvent.altKey) {
            $.datepicker._adjustDate(event.target, event.ctrlKey ? +$.datepicker._get(inst, 'stepBigMonths') : +$.datepicker._get(inst, 'stepMonths'), 'M');
          }
          // next month/year on alt +right
          break;
        case 40:
          if (event.ctrlKey || event.metaKey) {
            $.datepicker._adjustDate(event.target, +7, 'D');
          }
          handled = event.ctrlKey || event.metaKey;
          break;
        // +1 week on ctrl or command +down
        default:
          handled = false;
        }
      } else if (event.keyCode === 36 && event.ctrlKey) {
        // display the date picker on ctrl+home
        $.datepicker._showDatepicker(this);
      } else {
        handled = false;
      }
      if (handled) {
        event.preventDefault();
        event.stopPropagation();
      }
    },
    _doKeyPress: function (event) {
      var chars, chr, inst = $.datepicker._getInst(event.target);
      if ($.datepicker._get(inst, 'constrainInput')) {
        chars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat'));
        chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
        return event.ctrlKey || event.metaKey || (chr < ' ' || !chars || chars.indexOf(chr) > -1);
      }
    },
    _doKeyUp: function (event) {
      var date, inst = $.datepicker._getInst(event.target);
      if (inst.input.val() !== inst.lastVal) {
        try {
          date = $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'), inst.input ? inst.input.val() : null, $.datepicker._getFormatConfig(inst));
          if (date) {
            // only if valid
            $.datepicker._setDateFromField(inst);
            $.datepicker._updateAlternate(inst);
            $.datepicker._updateDatepicker(inst);
          }
        } catch (err) {
        }
      }
      return true;
    },
    _showDatepicker: function (input) {
      input = input.target || input;
      if (input.nodeName.toLowerCase() !== 'input') {
        // find from button/image trigger
        input = $('input', input.parentNode)[0];
      }
      if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) {
        // already here
        return;
      }
      var inst, beforeShow, beforeShowSettings, isFixed, offset, showAnim, duration;
      inst = $.datepicker._getInst(input);
      if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
        $.datepicker._curInst.dpDiv.stop(true, true);
        if (inst && $.datepicker._datepickerShowing) {
          $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
        }
      }
      beforeShow = $.datepicker._get(inst, 'beforeShow');
      beforeShowSettings = beforeShow ? beforeShow.apply(input, [
        input,
        inst
      ]) : {};
      if (beforeShowSettings === false) {
        return;
      }
      extendRemove(inst.settings, beforeShowSettings);
      inst.lastVal = null;
      $.datepicker._lastInput = input;
      $.datepicker._setDateFromField(inst);
      if ($.datepicker._inDialog) {
        // hide cursor
        input.value = '';
      }
      if (!$.datepicker._pos) {
        // position below input
        $.datepicker._pos = $.datepicker._findPos(input);
        $.datepicker._pos[1] += input.offsetHeight;  // add the height
      }
      isFixed = false;
      $(input).parents().each(function () {
        isFixed |= $(this).css('position') === 'fixed';
        return !isFixed;
      });
      offset = {
        left: $.datepicker._pos[0],
        top: $.datepicker._pos[1]
      };
      $.datepicker._pos = null;
      //to avoid flashes on Firefox
      inst.dpDiv.empty();
      // determine sizing offscreen
      inst.dpDiv.css({
        position: 'absolute',
        display: 'block',
        top: '-1000px'
      });
      $.datepicker._updateDatepicker(inst);
      // fix width for dynamic number of date pickers
      // and adjust position before showing
      offset = $.datepicker._checkOffset(inst, offset, isFixed);
      inst.dpDiv.css({
        position: $.datepicker._inDialog && $.blockUI ? 'static' : isFixed ? 'fixed' : 'absolute',
        display: 'none',
        left: offset.left + 'px',
        top: offset.top + 'px'
      });
      if (!inst.inline) {
        showAnim = $.datepicker._get(inst, 'showAnim');
        duration = $.datepicker._get(inst, 'duration');
        inst.dpDiv.zIndex($(input).zIndex() + 1);
        $.datepicker._datepickerShowing = true;
        if ($.effects && $.effects.effect[showAnim]) {
          inst.dpDiv.show(showAnim, $.datepicker._get(inst, 'showOptions'), duration);
        } else {
          inst.dpDiv[showAnim || 'show'](showAnim ? duration : null);
        }
        if ($.datepicker._shouldFocusInput(inst)) {
          inst.input.focus();
        }
        $.datepicker._curInst = inst;
      }
    },
    _updateDatepicker: function (inst) {
      this.maxRows = 4;
      //Reset the max number of rows being displayed (see #7043)
      instActive = inst;
      // for delegate hover events
      inst.dpDiv.empty().append(this._generateHTML(inst));
      this._attachHandlers(inst);
      inst.dpDiv.find('.' + this._dayOverClass + ' a').mouseover();
      var origyearshtml, numMonths = this._getNumberOfMonths(inst), cols = numMonths[1], width = 17;
      inst.dpDiv.removeClass('ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4').width('');
      if (cols > 1) {
        inst.dpDiv.addClass('ui-datepicker-multi-' + cols).css('width', width * cols + 'em');
      }
      inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? 'add' : 'remove') + 'Class']('ui-datepicker-multi');
      inst.dpDiv[(this._get(inst, 'isRTL') ? 'add' : 'remove') + 'Class']('ui-datepicker-rtl');
      if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
        inst.input.focus();
      }
      // deffered render of the years select (to avoid flashes on Firefox)
      if (inst.yearshtml) {
        origyearshtml = inst.yearshtml;
        setTimeout(function () {
          //assure that inst.yearshtml didn't change.
          if (origyearshtml === inst.yearshtml && inst.yearshtml) {
            inst.dpDiv.find('select.ui-datepicker-year:first').replaceWith(inst.yearshtml);
          }
          origyearshtml = inst.yearshtml = null;
        }, 0);
      }
    },
    _shouldFocusInput: function (inst) {
      return inst.input && inst.input.is(':visible') && !inst.input.is(':disabled') && !inst.input.is(':focus');
    },
    _checkOffset: function (inst, offset, isFixed) {
      var dpWidth = inst.dpDiv.outerWidth(), dpHeight = inst.dpDiv.outerHeight(), inputWidth = inst.input ? inst.input.outerWidth() : 0, inputHeight = inst.input ? inst.input.outerHeight() : 0, viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()), viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
      offset.left -= this._get(inst, 'isRTL') ? dpWidth - inputWidth : 0;
      offset.left -= isFixed && offset.left === inst.input.offset().left ? $(document).scrollLeft() : 0;
      offset.top -= isFixed && offset.top === inst.input.offset().top + inputHeight ? $(document).scrollTop() : 0;
      // now check if datepicker is showing outside window viewport - move to a better place if so.
      offset.left -= Math.min(offset.left, offset.left + dpWidth > viewWidth && viewWidth > dpWidth ? Math.abs(offset.left + dpWidth - viewWidth) : 0);
      offset.top -= Math.min(offset.top, offset.top + dpHeight > viewHeight && viewHeight > dpHeight ? Math.abs(dpHeight + inputHeight) : 0);
      return offset;
    },
    _findPos: function (obj) {
      var position, inst = this._getInst(obj), isRTL = this._get(inst, 'isRTL');
      while (obj && (obj.type === 'hidden' || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
        obj = obj[isRTL ? 'previousSibling' : 'nextSibling'];
      }
      position = $(obj).offset();
      return [
        position.left,
        position.top
      ];
    },
    _hideDatepicker: function (input) {
      var showAnim, duration, postProcess, onClose, inst = this._curInst;
      if (!inst || input && inst !== $.data(input, PROP_NAME)) {
        return;
      }
      if (this._datepickerShowing) {
        showAnim = this._get(inst, 'showAnim');
        duration = this._get(inst, 'duration');
        postProcess = function () {
          $.datepicker._tidyDialog(inst);
        };
        // DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
        if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
          inst.dpDiv.hide(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
        } else {
          inst.dpDiv[showAnim === 'slideDown' ? 'slideUp' : showAnim === 'fadeIn' ? 'fadeOut' : 'hide'](showAnim ? duration : null, postProcess);
        }
        if (!showAnim) {
          postProcess();
        }
        this._datepickerShowing = false;
        onClose = this._get(inst, 'onClose');
        if (onClose) {
          onClose.apply(inst.input ? inst.input[0] : null, [
            inst.input ? inst.input.val() : '',
            inst
          ]);
        }
        this._lastInput = null;
        if (this._inDialog) {
          this._dialogInput.css({
            position: 'absolute',
            left: '0',
            top: '-100px'
          });
          if ($.blockUI) {
            $.unblockUI();
            $('body').append(this.dpDiv);
          }
        }
        this._inDialog = false;
      }
    },
    _tidyDialog: function (inst) {
      inst.dpDiv.removeClass(this._dialogClass).unbind('.ui-datepicker-calendar');
    },
    _checkExternalClick: function (event) {
      if (!$.datepicker._curInst) {
        return;
      }
      var $target = $(event.target), inst = $.datepicker._getInst($target[0]);
      if ($target[0].id !== $.datepicker._mainDivId && $target.parents('#' + $.datepicker._mainDivId).length === 0 && !$target.hasClass($.datepicker.markerClassName) && !$target.closest('.' + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) || $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst) {
        $.datepicker._hideDatepicker();
      }
    },
    _adjustDate: function (id, offset, period) {
      var target = $(id), inst = this._getInst(target[0]);
      if (this._isDisabledDatepicker(target[0])) {
        return;
      }
      this._adjustInstDate(inst, offset + (period === 'M' ? this._get(inst, 'showCurrentAtPos') : 0), period);
      this._updateDatepicker(inst);
    },
    _gotoToday: function (id) {
      var date, target = $(id), inst = this._getInst(target[0]);
      if (this._get(inst, 'gotoCurrent') && inst.currentDay) {
        inst.selectedDay = inst.currentDay;
        inst.drawMonth = inst.selectedMonth = inst.currentMonth;
        inst.drawYear = inst.selectedYear = inst.currentYear;
      } else {
        date = new Date();
        inst.selectedDay = date.getDate();
        inst.drawMonth = inst.selectedMonth = date.getMonth();
        inst.drawYear = inst.selectedYear = date.getFullYear();
      }
      this._notifyChange(inst);
      this._adjustDate(target);
    },
    _selectMonthYear: function (id, select, period) {
      var target = $(id), inst = this._getInst(target[0]);
      inst['selected' + (period === 'M' ? 'Month' : 'Year')] = inst['draw' + (period === 'M' ? 'Month' : 'Year')] = parseInt(select.options[select.selectedIndex].value, 10);
      this._notifyChange(inst);
      this._adjustDate(target);
    },
    _selectDay: function (id, month, year, td) {
      var inst, target = $(id);
      if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
        return;
      }
      inst = this._getInst(target[0]);
      inst.selectedDay = inst.currentDay = $('a', td).html();
      inst.selectedMonth = inst.currentMonth = month;
      inst.selectedYear = inst.currentYear = year;
      this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear));
    },
    _clearDate: function (id) {
      var target = $(id);
      this._selectDate(target, '');
    },
    _selectDate: function (id, dateStr) {
      var onSelect, target = $(id), inst = this._getInst(target[0]);
      dateStr = dateStr != null ? dateStr : this._formatDate(inst);
      if (inst.input) {
        inst.input.val(dateStr);
      }
      this._updateAlternate(inst);
      onSelect = this._get(inst, 'onSelect');
      if (onSelect) {
        onSelect.apply(inst.input ? inst.input[0] : null, [
          dateStr,
          inst
        ]);  // trigger custom callback
      } else if (inst.input) {
        inst.input.trigger('change');  // fire the change event
      }
      if (inst.inline) {
        this._updateDatepicker(inst);
      } else {
        this._hideDatepicker();
        this._lastInput = inst.input[0];
        if (typeof inst.input[0] !== 'object') {
          inst.input.focus();  // restore focus
        }
        this._lastInput = null;
      }
    },
    _updateAlternate: function (inst) {
      var altFormat, date, dateStr, altField = this._get(inst, 'altField');
      if (altField) {
        // update alternate field too
        altFormat = this._get(inst, 'altFormat') || this._get(inst, 'dateFormat');
        date = this._getDate(inst);
        dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
        $(altField).each(function () {
          $(this).val(dateStr);
        });
      }
    },
    noWeekends: function (date) {
      var day = date.getDay();
      return [
        day > 0 && day < 6,
        ''
      ];
    },
    iso8601Week: function (date) {
      var time, checkDate = new Date(date.getTime());
      // Find Thursday of this week starting on Monday
      checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
      time = checkDate.getTime();
      checkDate.setMonth(0);
      // Compare with Jan 1
      checkDate.setDate(1);
      return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
    },
    parseDate: function (format, value, settings) {
      if (format == null || value == null) {
        throw 'Invalid arguments';
      }
      value = typeof value === 'object' ? value.toString() : value + '';
      if (value === '') {
        return null;
      }
      var iFormat, dim, extra, iValue = 0, shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff, shortYearCutoff = typeof shortYearCutoffTemp !== 'string' ? shortYearCutoffTemp : new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10), dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames, year = -1, month = -1, day = -1, doy = -1, literal = false, date,
        // Check whether a format character is doubled
        lookAhead = function (match) {
          var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
          if (matches) {
            iFormat++;
          }
          return matches;
        },
        // Extract a number from the string value
        getNumber = function (match) {
          var isDoubled = lookAhead(match), size = match === '@' ? 14 : match === '!' ? 20 : match === 'y' && isDoubled ? 4 : match === 'o' ? 3 : 2, digits = new RegExp('^\\d{1,' + size + '}'), num = value.substring(iValue).match(digits);
          if (!num) {
            throw 'Missing number at position ' + iValue;
          }
          iValue += num[0].length;
          return parseInt(num[0], 10);
        },
        // Extract a name from the string value and convert to an index
        getName = function (match, shortNames, longNames) {
          var index = -1, names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
              return [[
                  k,
                  v
                ]];
            }).sort(function (a, b) {
              return -(a[1].length - b[1].length);
            });
          $.each(names, function (i, pair) {
            var name = pair[1];
            if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
              index = pair[0];
              iValue += name.length;
              return false;
            }
          });
          if (index !== -1) {
            return index + 1;
          } else {
            throw 'Unknown name at position ' + iValue;
          }
        },
        // Confirm that a literal character matches the string value
        checkLiteral = function () {
          if (value.charAt(iValue) !== format.charAt(iFormat)) {
            throw 'Unexpected literal at position ' + iValue;
          }
          iValue++;
        };
      for (iFormat = 0; iFormat < format.length; iFormat++) {
        if (literal) {
          if (format.charAt(iFormat) === '\'' && !lookAhead('\'')) {
            literal = false;
          } else {
            checkLiteral();
          }
        } else {
          switch (format.charAt(iFormat)) {
          case 'd':
            day = getNumber('d');
            break;
          case 'D':
            getName('D', dayNamesShort, dayNames);
            break;
          case 'o':
            doy = getNumber('o');
            break;
          case 'm':
            month = getNumber('m');
            break;
          case 'M':
            month = getName('M', monthNamesShort, monthNames);
            break;
          case 'y':
            year = getNumber('y');
            break;
          case '@':
            date = new Date(getNumber('@'));
            year = date.getFullYear();
            month = date.getMonth() + 1;
            day = date.getDate();
            break;
          case '!':
            date = new Date((getNumber('!') - this._ticksTo1970) / 10000);
            year = date.getFullYear();
            month = date.getMonth() + 1;
            day = date.getDate();
            break;
          case '\'':
            if (lookAhead('\'')) {
              checkLiteral();
            } else {
              literal = true;
            }
            break;
          default:
            checkLiteral();
          }
        }
      }
      if (iValue < value.length) {
        extra = value.substr(iValue);
        if (!/^\s+/.test(extra)) {
          throw 'Extra/unparsed characters found in date: ' + extra;
        }
      }
      if (year === -1) {
        year = new Date().getFullYear();
      } else if (year < 100) {
        year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);
      }
      if (doy > -1) {
        month = 1;
        day = doy;
        do {
          dim = this._getDaysInMonth(year, month - 1);
          if (day <= dim) {
            break;
          }
          month++;
          day -= dim;
        } while (true);
      }
      date = this._daylightSavingAdjust(new Date(year, month - 1, day));
      if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
        throw 'Invalid date';  // E.g. 31/02/00
      }
      return date;
    },
    ATOM: 'yy-mm-dd',
    COOKIE: 'D, dd M yy',
    ISO_8601: 'yy-mm-dd',
    RFC_822: 'D, d M y',
    RFC_850: 'DD, dd-M-y',
    RFC_1036: 'D, d M y',
    RFC_1123: 'D, d M yy',
    RFC_2822: 'D, d M yy',
    RSS: 'D, d M y',
    TICKS: '!',
    TIMESTAMP: '@',
    W3C: 'yy-mm-dd',
    _ticksTo1970: ((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000,
    formatDate: function (format, date, settings) {
      if (!date) {
        return '';
      }
      var iFormat, dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort, dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames, monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort, monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
        // Check whether a format character is doubled
        lookAhead = function (match) {
          var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
          if (matches) {
            iFormat++;
          }
          return matches;
        },
        // Format a number, with leading zero if necessary
        formatNumber = function (match, value, len) {
          var num = '' + value;
          if (lookAhead(match)) {
            while (num.length < len) {
              num = '0' + num;
            }
          }
          return num;
        },
        // Format a name, short or long as requested
        formatName = function (match, value, shortNames, longNames) {
          return lookAhead(match) ? longNames[value] : shortNames[value];
        }, output = '', literal = false;
      if (date) {
        for (iFormat = 0; iFormat < format.length; iFormat++) {
          if (literal) {
            if (format.charAt(iFormat) === '\'' && !lookAhead('\'')) {
              literal = false;
            } else {
              output += format.charAt(iFormat);
            }
          } else {
            switch (format.charAt(iFormat)) {
            case 'd':
              output += formatNumber('d', date.getDate(), 2);
              break;
            case 'D':
              output += formatName('D', date.getDay(), dayNamesShort, dayNames);
              break;
            case 'o':
              output += formatNumber('o', Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
              break;
            case 'm':
              output += formatNumber('m', date.getMonth() + 1, 2);
              break;
            case 'M':
              output += formatName('M', date.getMonth(), monthNamesShort, monthNames);
              break;
            case 'y':
              output += lookAhead('y') ? date.getFullYear() : (date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100;
              break;
            case '@':
              output += date.getTime();
              break;
            case '!':
              output += date.getTime() * 10000 + this._ticksTo1970;
              break;
            case '\'':
              if (lookAhead('\'')) {
                output += '\'';
              } else {
                literal = true;
              }
              break;
            default:
              output += format.charAt(iFormat);
            }
          }
        }
      }
      return output;
    },
    _possibleChars: function (format) {
      var iFormat, chars = '', literal = false,
        // Check whether a format character is doubled
        lookAhead = function (match) {
          var matches = iFormat + 1 < format.length && format.charAt(iFormat + 1) === match;
          if (matches) {
            iFormat++;
          }
          return matches;
        };
      for (iFormat = 0; iFormat < format.length; iFormat++) {
        if (literal) {
          if (format.charAt(iFormat) === '\'' && !lookAhead('\'')) {
            literal = false;
          } else {
            chars += format.charAt(iFormat);
          }
        } else {
          switch (format.charAt(iFormat)) {
          case 'd':
          case 'm':
          case 'y':
          case '@':
            chars += '0123456789';
            break;
          case 'D':
          case 'M':
            return null;
          // Accept anything
          case '\'':
            if (lookAhead('\'')) {
              chars += '\'';
            } else {
              literal = true;
            }
            break;
          default:
            chars += format.charAt(iFormat);
          }
        }
      }
      return chars;
    },
    _get: function (inst, name) {
      return inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name];
    },
    _setDateFromField: function (inst, noDefault) {
      if (inst.input.val() === inst.lastVal) {
        return;
      }
      var dateFormat = this._get(inst, 'dateFormat'), dates = inst.lastVal = inst.input ? inst.input.val() : null, defaultDate = this._getDefaultDate(inst), date = defaultDate, settings = this._getFormatConfig(inst);
      try {
        date = this.parseDate(dateFormat, dates, settings) || defaultDate;
      } catch (event) {
        dates = noDefault ? '' : dates;
      }
      inst.selectedDay = date.getDate();
      inst.drawMonth = inst.selectedMonth = date.getMonth();
      inst.drawYear = inst.selectedYear = date.getFullYear();
      inst.currentDay = dates ? date.getDate() : 0;
      inst.currentMonth = dates ? date.getMonth() : 0;
      inst.currentYear = dates ? date.getFullYear() : 0;
      this._adjustInstDate(inst);
    },
    _getDefaultDate: function (inst) {
      return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, 'defaultDate'), new Date()));
    },
    _determineDate: function (inst, date, defaultDate) {
      var offsetNumeric = function (offset) {
          var date = new Date();
          date.setDate(date.getDate() + offset);
          return date;
        }, offsetString = function (offset) {
          try {
            return $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'), offset, $.datepicker._getFormatConfig(inst));
          } catch (e) {
          }
          var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(), year = date.getFullYear(), month = date.getMonth(), day = date.getDate(), pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g, matches = pattern.exec(offset);
          while (matches) {
            switch (matches[2] || 'd') {
            case 'd':
            case 'D':
              day += parseInt(matches[1], 10);
              break;
            case 'w':
            case 'W':
              day += parseInt(matches[1], 10) * 7;
              break;
            case 'm':
            case 'M':
              month += parseInt(matches[1], 10);
              day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
              break;
            case 'y':
            case 'Y':
              year += parseInt(matches[1], 10);
              day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
              break;
            }
            matches = pattern.exec(offset);
          }
          return new Date(year, month, day);
        }, newDate = date == null || date === '' ? defaultDate : typeof date === 'string' ? offsetString(date) : typeof date === 'number' ? isNaN(date) ? defaultDate : offsetNumeric(date) : new Date(date.getTime());
      newDate = newDate && newDate.toString() === 'Invalid Date' ? defaultDate : newDate;
      if (newDate) {
        newDate.setHours(0);
        newDate.setMinutes(0);
        newDate.setSeconds(0);
        newDate.setMilliseconds(0);
      }
      return this._daylightSavingAdjust(newDate);
    },
    _daylightSavingAdjust: function (date) {
      if (!date) {
        return null;
      }
      date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
      return date;
    },
    _setDate: function (inst, date, noChange) {
      var clear = !date, origMonth = inst.selectedMonth, origYear = inst.selectedYear, newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
      inst.selectedDay = inst.currentDay = newDate.getDate();
      inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
      inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
      if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
        this._notifyChange(inst);
      }
      this._adjustInstDate(inst);
      if (inst.input) {
        inst.input.val(clear ? '' : this._formatDate(inst));
      }
    },
    _getDate: function (inst) {
      var startDate = !inst.currentYear || inst.input && inst.input.val() === '' ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
      return startDate;
    },
    _attachHandlers: function (inst) {
      var stepMonths = this._get(inst, 'stepMonths'), id = '#' + inst.id.replace(/\\\\/g, '\\');
      inst.dpDiv.find('[data-handler]').map(function () {
        var handler = {
            prev: function () {
              $.datepicker._adjustDate(id, -stepMonths, 'M');
            },
            next: function () {
              $.datepicker._adjustDate(id, +stepMonths, 'M');
            },
            hide: function () {
              $.datepicker._hideDatepicker();
            },
            today: function () {
              $.datepicker._gotoToday(id);
            },
            selectDay: function () {
              $.datepicker._selectDay(id, +this.getAttribute('data-month'), +this.getAttribute('data-year'), this);
              return false;
            },
            selectMonth: function () {
              $.datepicker._selectMonthYear(id, this, 'M');
              return false;
            },
            selectYear: function () {
              $.datepicker._selectMonthYear(id, this, 'Y');
              return false;
            }
          };
        $(this).bind(this.getAttribute('data-event'), handler[this.getAttribute('data-handler')]);
      });
    },
    _generateHTML: function (inst) {
      var maxDraw, prevText, prev, nextText, next, currentText, gotoDate, controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin, monthNames, monthNamesShort, beforeShowDay, showOtherMonths, selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate, cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows, printDate, dRow, tbody, daySettings, otherMonth, unselectable, tempDate = new Date(), today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())),
        // clear time
        isRTL = this._get(inst, 'isRTL'), showButtonPanel = this._get(inst, 'showButtonPanel'), hideIfNoPrevNext = this._get(inst, 'hideIfNoPrevNext'), navigationAsDateFormat = this._get(inst, 'navigationAsDateFormat'), numMonths = this._getNumberOfMonths(inst), showCurrentAtPos = this._get(inst, 'showCurrentAtPos'), stepMonths = this._get(inst, 'stepMonths'), isMultiMonth = numMonths[0] !== 1 || numMonths[1] !== 1, currentDate = this._daylightSavingAdjust(!inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay)), minDate = this._getMinMaxDate(inst, 'min'), maxDate = this._getMinMaxDate(inst, 'max'), drawMonth = inst.drawMonth - showCurrentAtPos, drawYear = inst.drawYear;
      if (drawMonth < 0) {
        drawMonth += 12;
        drawYear--;
      }
      if (maxDate) {
        maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - numMonths[0] * numMonths[1] + 1, maxDate.getDate()));
        maxDraw = minDate && maxDraw < minDate ? minDate : maxDraw;
        while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
          drawMonth--;
          if (drawMonth < 0) {
            drawMonth = 11;
            drawYear--;
          }
        }
      }
      inst.drawMonth = drawMonth;
      inst.drawYear = drawYear;
      prevText = this._get(inst, 'prevText');
      prevText = !navigationAsDateFormat ? prevText : this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst));
      prev = this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? '<a class=\'ui-datepicker-prev ui-corner-all\' data-handler=\'prev\' data-event=\'click\'' + ' title=\'' + prevText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'e' : 'w') + '\'>' + prevText + '</span></a>' : hideIfNoPrevNext ? '' : '<a class=\'ui-datepicker-prev ui-corner-all ui-state-disabled\' title=\'' + prevText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'e' : 'w') + '\'>' + prevText + '</span></a>';
      nextText = this._get(inst, 'nextText');
      nextText = !navigationAsDateFormat ? nextText : this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst));
      next = this._canAdjustMonth(inst, +1, drawYear, drawMonth) ? '<a class=\'ui-datepicker-next ui-corner-all\' data-handler=\'next\' data-event=\'click\'' + ' title=\'' + nextText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'w' : 'e') + '\'>' + nextText + '</span></a>' : hideIfNoPrevNext ? '' : '<a class=\'ui-datepicker-next ui-corner-all ui-state-disabled\' title=\'' + nextText + '\'><span class=\'ui-icon ui-icon-circle-triangle-' + (isRTL ? 'w' : 'e') + '\'>' + nextText + '</span></a>';
      currentText = this._get(inst, 'currentText');
      gotoDate = this._get(inst, 'gotoCurrent') && inst.currentDay ? currentDate : today;
      currentText = !navigationAsDateFormat ? currentText : this.formatDate(currentText, gotoDate, this._getFormatConfig(inst));
      controls = !inst.inline ? '<button type=\'button\' class=\'ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all\' data-handler=\'hide\' data-event=\'click\'>' + this._get(inst, 'closeText') + '</button>' : '';
      buttonPanel = showButtonPanel ? '<div class=\'ui-datepicker-buttonpane ui-widget-content\'>' + (isRTL ? controls : '') + (this._isInRange(inst, gotoDate) ? '<button type=\'button\' class=\'ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all\' data-handler=\'today\' data-event=\'click\'' + '>' + currentText + '</button>' : '') + (isRTL ? '' : controls) + '</div>' : '';
      firstDay = parseInt(this._get(inst, 'firstDay'), 10);
      firstDay = isNaN(firstDay) ? 0 : firstDay;
      showWeek = this._get(inst, 'showWeek');
      dayNames = this._get(inst, 'dayNames');
      dayNamesMin = this._get(inst, 'dayNamesMin');
      monthNames = this._get(inst, 'monthNames');
      monthNamesShort = this._get(inst, 'monthNamesShort');
      beforeShowDay = this._get(inst, 'beforeShowDay');
      showOtherMonths = this._get(inst, 'showOtherMonths');
      selectOtherMonths = this._get(inst, 'selectOtherMonths');
      defaultDate = this._getDefaultDate(inst);
      html = '';
      dow;
      for (row = 0; row < numMonths[0]; row++) {
        group = '';
        this.maxRows = 4;
        for (col = 0; col < numMonths[1]; col++) {
          selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
          cornerClass = ' ui-corner-all';
          calender = '';
          if (isMultiMonth) {
            calender += '<div class=\'ui-datepicker-group';
            if (numMonths[1] > 1) {
              switch (col) {
              case 0:
                calender += ' ui-datepicker-group-first';
                cornerClass = ' ui-corner-' + (isRTL ? 'right' : 'left');
                break;
              case numMonths[1] - 1:
                calender += ' ui-datepicker-group-last';
                cornerClass = ' ui-corner-' + (isRTL ? 'left' : 'right');
                break;
              default:
                calender += ' ui-datepicker-group-middle';
                cornerClass = '';
                break;
              }
            }
            calender += '\'>';
          }
          calender += '<div class=\'ui-datepicker-header ui-widget-header ui-helper-clearfix' + cornerClass + '\'>' + (/all|left/.test(cornerClass) && row === 0 ? isRTL ? next : prev : '') + (/all|right/.test(cornerClass) && row === 0 ? isRTL ? prev : next : '') + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + '</div><table class=\'ui-datepicker-calendar\'><thead>' + '<tr>';
          thead = showWeek ? '<th class=\'ui-datepicker-week-col\'>' + this._get(inst, 'weekHeader') + '</th>' : '';
          for (dow = 0; dow < 7; dow++) {
            // days of the week
            day = (dow + firstDay) % 7;
            thead += '<th' + ((dow + firstDay + 6) % 7 >= 5 ? ' class=\'ui-datepicker-week-end\'' : '') + '>' + '<span title=\'' + dayNames[day] + '\'>' + dayNamesMin[day] + '</span></th>';
          }
          calender += thead + '</tr></thead><tbody>';
          daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
          if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
            inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
          }
          leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
          curRows = Math.ceil((leadDays + daysInMonth) / 7);
          // calculate the number of rows to generate
          numRows = isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows;
          //If multiple months, use the higher number of rows (see #7043)
          this.maxRows = numRows;
          printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
          for (dRow = 0; dRow < numRows; dRow++) {
            // create date picker rows
            calender += '<tr>';
            tbody = !showWeek ? '' : '<td class=\'ui-datepicker-week-col\'>' + this._get(inst, 'calculateWeek')(printDate) + '</td>';
            for (dow = 0; dow < 7; dow++) {
              // create date picker days
              daySettings = beforeShowDay ? beforeShowDay.apply(inst.input ? inst.input[0] : null, [printDate]) : [
                true,
                ''
              ];
              otherMonth = printDate.getMonth() !== drawMonth;
              unselectable = otherMonth && !selectOtherMonths || !daySettings[0] || minDate && printDate < minDate || maxDate && printDate > maxDate;
              tbody += '<td class=\'' + ((dow + firstDay + 6) % 7 >= 5 ? ' ui-datepicker-week-end' : '') + (otherMonth ? ' ui-datepicker-other-month' : '') + (printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent || defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ? ' ' + this._dayOverClass : '') + (unselectable ? ' ' + this._unselectableClass + ' ui-state-disabled' : '') + (otherMonth && !showOtherMonths ? '' : ' ' + daySettings[1] + (printDate.getTime() === currentDate.getTime() ? ' ' + this._currentClass : '') + (printDate.getTime() === today.getTime() ? ' ui-datepicker-today' : '')) + '\'' + ((!otherMonth || showOtherMonths) && daySettings[2] ? ' title=\'' + daySettings[2].replace(/'/g, '&#39;') + '\'' : '') + (unselectable ? '' : ' data-handler=\'selectDay\' data-event=\'click\' data-month=\'' + printDate.getMonth() + '\' data-year=\'' + printDate.getFullYear() + '\'') + '>' + (otherMonth && !showOtherMonths ? '&#xa0;' : unselectable ? '<span class=\'ui-state-default\'>' + printDate.getDate() + '</span>' : '<a class=\'ui-state-default' + (printDate.getTime() === today.getTime() ? ' ui-state-highlight' : '') + (printDate.getTime() === currentDate.getTime() ? ' ui-state-active' : '') + (otherMonth ? ' ui-priority-secondary' : '') + '\' href=\'#\'>' + printDate.getDate() + '</a>') + '</td>';
              // display selectable date
              printDate.setDate(printDate.getDate() + 1);
              printDate = this._daylightSavingAdjust(printDate);
            }
            calender += tbody + '</tr>';
          }
          drawMonth++;
          if (drawMonth > 11) {
            drawMonth = 0;
            drawYear++;
          }
          calender += '</tbody></table>' + (isMultiMonth ? '</div>' + (numMonths[0] > 0 && col === numMonths[1] - 1 ? '<div class=\'ui-datepicker-row-break\'></div>' : '') : '');
          group += calender;
        }
        html += group;
      }
      html += buttonPanel;
      inst._keyEvent = false;
      return html;
    },
    _generateMonthYearHeader: function (inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) {
      var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear, changeMonth = this._get(inst, 'changeMonth'), changeYear = this._get(inst, 'changeYear'), showMonthAfterYear = this._get(inst, 'showMonthAfterYear'), html = '<div class=\'ui-datepicker-title\'>', monthHtml = '';
      // month selection
      if (secondary || !changeMonth) {
        monthHtml += '<span class=\'ui-datepicker-month\'>' + monthNames[drawMonth] + '</span>';
      } else {
        inMinYear = minDate && minDate.getFullYear() === drawYear;
        inMaxYear = maxDate && maxDate.getFullYear() === drawYear;
        monthHtml += '<select class=\'ui-datepicker-month\' data-handler=\'selectMonth\' data-event=\'change\'>';
        for (month = 0; month < 12; month++) {
          if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
            monthHtml += '<option value=\'' + month + '\'' + (month === drawMonth ? ' selected=\'selected\'' : '') + '>' + monthNamesShort[month] + '</option>';
          }
        }
        monthHtml += '</select>';
      }
      if (!showMonthAfterYear) {
        html += monthHtml + (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '');
      }
      // year selection
      if (!inst.yearshtml) {
        inst.yearshtml = '';
        if (secondary || !changeYear) {
          html += '<span class=\'ui-datepicker-year\'>' + drawYear + '</span>';
        } else {
          // determine range of years to display
          years = this._get(inst, 'yearRange').split(':');
          thisYear = new Date().getFullYear();
          determineYear = function (value) {
            var year = value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) : value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10);
            return isNaN(year) ? thisYear : year;
          };
          year = determineYear(years[0]);
          endYear = Math.max(year, determineYear(years[1] || ''));
          year = minDate ? Math.max(year, minDate.getFullYear()) : year;
          endYear = maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear;
          inst.yearshtml += '<select class=\'ui-datepicker-year\' data-handler=\'selectYear\' data-event=\'change\'>';
          for (; year <= endYear; year++) {
            inst.yearshtml += '<option value=\'' + year + '\'' + (year === drawYear ? ' selected=\'selected\'' : '') + '>' + year + '</option>';
          }
          inst.yearshtml += '</select>';
          html += inst.yearshtml;
          inst.yearshtml = null;
        }
      }
      html += this._get(inst, 'yearSuffix');
      if (showMonthAfterYear) {
        html += (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '') + monthHtml;
      }
      html += '</div>';
      // Close datepicker_header
      return html;
    },
    _adjustInstDate: function (inst, offset, period) {
      var year = inst.drawYear + (period === 'Y' ? offset : 0), month = inst.drawMonth + (period === 'M' ? offset : 0), day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === 'D' ? offset : 0), date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
      inst.selectedDay = date.getDate();
      inst.drawMonth = inst.selectedMonth = date.getMonth();
      inst.drawYear = inst.selectedYear = date.getFullYear();
      if (period === 'M' || period === 'Y') {
        this._notifyChange(inst);
      }
    },
    _restrictMinMax: function (inst, date) {
      var minDate = this._getMinMaxDate(inst, 'min'), maxDate = this._getMinMaxDate(inst, 'max'), newDate = minDate && date < minDate ? minDate : date;
      return maxDate && newDate > maxDate ? maxDate : newDate;
    },
    _notifyChange: function (inst) {
      var onChange = this._get(inst, 'onChangeMonthYear');
      if (onChange) {
        onChange.apply(inst.input ? inst.input[0] : null, [
          inst.selectedYear,
          inst.selectedMonth + 1,
          inst
        ]);
      }
    },
    _getNumberOfMonths: function (inst) {
      var numMonths = this._get(inst, 'numberOfMonths');
      return numMonths == null ? [
        1,
        1
      ] : typeof numMonths === 'number' ? [
        1,
        numMonths
      ] : numMonths;
    },
    _getMinMaxDate: function (inst, minMax) {
      return this._determineDate(inst, this._get(inst, minMax + 'Date'), null);
    },
    _getDaysInMonth: function (year, month) {
      return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
    },
    _getFirstDayOfMonth: function (year, month) {
      return new Date(year, month, 1).getDay();
    },
    _canAdjustMonth: function (inst, offset, curYear, curMonth) {
      var numMonths = this._getNumberOfMonths(inst), date = this._daylightSavingAdjust(new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
      if (offset < 0) {
        date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
      }
      return this._isInRange(inst, date);
    },
    _isInRange: function (inst, date) {
      var yearSplit, currentYear, minDate = this._getMinMaxDate(inst, 'min'), maxDate = this._getMinMaxDate(inst, 'max'), minYear = null, maxYear = null, years = this._get(inst, 'yearRange');
      if (years) {
        yearSplit = years.split(':');
        currentYear = new Date().getFullYear();
        minYear = parseInt(yearSplit[0], 10);
        maxYear = parseInt(yearSplit[1], 10);
        if (yearSplit[0].match(/[+\-].*/)) {
          minYear += currentYear;
        }
        if (yearSplit[1].match(/[+\-].*/)) {
          maxYear += currentYear;
        }
      }
      return (!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear);
    },
    _getFormatConfig: function (inst) {
      var shortYearCutoff = this._get(inst, 'shortYearCutoff');
      shortYearCutoff = typeof shortYearCutoff !== 'string' ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10);
      return {
        shortYearCutoff: shortYearCutoff,
        dayNamesShort: this._get(inst, 'dayNamesShort'),
        dayNames: this._get(inst, 'dayNames'),
        monthNamesShort: this._get(inst, 'monthNamesShort'),
        monthNames: this._get(inst, 'monthNames')
      };
    },
    _formatDate: function (inst, day, month, year) {
      if (!day) {
        inst.currentDay = inst.selectedDay;
        inst.currentMonth = inst.selectedMonth;
        inst.currentYear = inst.selectedYear;
      }
      var date = day ? typeof day === 'object' ? day : this._daylightSavingAdjust(new Date(year, month, day)) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay));
      return this.formatDate(this._get(inst, 'dateFormat'), date, this._getFormatConfig(inst));
    }
  });
  /*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
  function bindHover(dpDiv) {
    var selector = 'button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a';
    return dpDiv.delegate(selector, 'mouseout', function () {
      $(this).removeClass('ui-state-hover');
      if (this.className.indexOf('ui-datepicker-prev') !== -1) {
        $(this).removeClass('ui-datepicker-prev-hover');
      }
      if (this.className.indexOf('ui-datepicker-next') !== -1) {
        $(this).removeClass('ui-datepicker-next-hover');
      }
    }).delegate(selector, 'mouseover', function () {
      if (!$.datepicker._isDisabledDatepicker(instActive.inline ? dpDiv.parent()[0] : instActive.input[0])) {
        $(this).parents('.ui-datepicker-calendar').find('a').removeClass('ui-state-hover');
        $(this).addClass('ui-state-hover');
        if (this.className.indexOf('ui-datepicker-prev') !== -1) {
          $(this).addClass('ui-datepicker-prev-hover');
        }
        if (this.className.indexOf('ui-datepicker-next') !== -1) {
          $(this).addClass('ui-datepicker-next-hover');
        }
      }
    });
  }
  /* jQuery extend now ignores nulls! */
  function extendRemove(target, props) {
    $.extend(target, props);
    for (var name in props) {
      if (props[name] == null) {
        target[name] = props[name];
      }
    }
    return target;
  }
  /* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
  $.fn.datepicker = function (options) {
    /* Verify an empty collection wasn't passed - Fixes #6976 */
    if (!this.length) {
      return this;
    }
    /* Initialise the date picker. */
    if (!$.datepicker.initialized) {
      $(document).mousedown($.datepicker._checkExternalClick);
      $.datepicker.initialized = true;
    }
    /* Append datepicker main container to body if not exist. */
    if ($('#' + $.datepicker._mainDivId).length === 0) {
      $('body').append($.datepicker.dpDiv);
    }
    var otherArgs = Array.prototype.slice.call(arguments, 1);
    if (typeof options === 'string' && (options === 'isDisabled' || options === 'getDate' || options === 'widget')) {
      return $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this[0]].concat(otherArgs));
    }
    if (options === 'option' && arguments.length === 2 && typeof arguments[1] === 'string') {
      return $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this[0]].concat(otherArgs));
    }
    return this.each(function () {
      typeof options === 'string' ? $.datepicker['_' + options + 'Datepicker'].apply($.datepicker, [this].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options);
    });
  };
  $.datepicker = new Datepicker();
  // singleton instance
  $.datepicker.initialized = false;
  $.datepicker.uuid = new Date().getTime();
  $.datepicker.version = '1.10.3';
}(jQuery));
(function ($, undefined) {
  var sizeRelatedOptions = {
      buttons: true,
      height: true,
      maxHeight: true,
      maxWidth: true,
      minHeight: true,
      minWidth: true,
      width: true
    }, resizableRelatedOptions = {
      maxHeight: true,
      maxWidth: true,
      minHeight: true,
      minWidth: true
    };
  $.widget('ui.dialog', {
    version: '1.10.3',
    options: {
      appendTo: 'body',
      autoOpen: true,
      buttons: [],
      closeOnEscape: true,
      closeText: 'close',
      dialogClass: '',
      draggable: true,
      hide: null,
      height: 'auto',
      maxHeight: null,
      maxWidth: null,
      minHeight: 150,
      minWidth: 150,
      modal: false,
      position: {
        my: 'center',
        at: 'center',
        of: window,
        collision: 'fit',
        using: function (pos) {
          var topOffset = $(this).css(pos).offset().top;
          if (topOffset < 0) {
            $(this).css('top', pos.top - topOffset);
          }
        }
      },
      resizable: true,
      show: null,
      title: null,
      width: 300,
      beforeClose: null,
      close: null,
      drag: null,
      dragStart: null,
      dragStop: null,
      focus: null,
      open: null,
      resize: null,
      resizeStart: null,
      resizeStop: null
    },
    _create: function () {
      this.originalCss = {
        display: this.element[0].style.display,
        width: this.element[0].style.width,
        minHeight: this.element[0].style.minHeight,
        maxHeight: this.element[0].style.maxHeight,
        height: this.element[0].style.height
      };
      this.originalPosition = {
        parent: this.element.parent(),
        index: this.element.parent().children().index(this.element)
      };
      this.originalTitle = this.element.attr('title');
      this.options.title = this.options.title || this.originalTitle;
      this._createWrapper();
      this.element.show().removeAttr('title').addClass('ui-dialog-content ui-widget-content').appendTo(this.uiDialog);
      this._createTitlebar();
      this._createButtonPane();
      if (this.options.draggable && $.fn.draggable) {
        this._makeDraggable();
      }
      if (this.options.resizable && $.fn.resizable) {
        this._makeResizable();
      }
      this._isOpen = false;
    },
    _init: function () {
      if (this.options.autoOpen) {
        this.open();
      }
    },
    _appendTo: function () {
      var element = this.options.appendTo;
      if (element && (element.jquery || element.nodeType)) {
        return $(element);
      }
      return this.document.find(element || 'body').eq(0);
    },
    _destroy: function () {
      var next, originalPosition = this.originalPosition;
      this._destroyOverlay();
      this.element.removeUniqueId().removeClass('ui-dialog-content ui-widget-content').css(this.originalCss).detach();
      this.uiDialog.stop(true, true).remove();
      if (this.originalTitle) {
        this.element.attr('title', this.originalTitle);
      }
      next = originalPosition.parent.children().eq(originalPosition.index);
      // Don't try to place the dialog next to itself (#8613)
      if (next.length && next[0] !== this.element[0]) {
        next.before(this.element);
      } else {
        originalPosition.parent.append(this.element);
      }
    },
    widget: function () {
      return this.uiDialog;
    },
    disable: $.noop,
    enable: $.noop,
    close: function (event) {
      var that = this;
      if (!this._isOpen || this._trigger('beforeClose', event) === false) {
        return;
      }
      this._isOpen = false;
      this._destroyOverlay();
      if (!this.opener.filter(':focusable').focus().length) {
        // Hiding a focused element doesn't trigger blur in WebKit
        // so in case we have nothing to focus on, explicitly blur the active element
        // https://bugs.webkit.org/show_bug.cgi?id=47182
        $(this.document[0].activeElement).blur();
      }
      this._hide(this.uiDialog, this.options.hide, function () {
        that._trigger('close', event);
      });
    },
    isOpen: function () {
      return this._isOpen;
    },
    moveToTop: function () {
      this._moveToTop();
    },
    _moveToTop: function (event, silent) {
      var moved = !!this.uiDialog.nextAll(':visible').insertBefore(this.uiDialog).length;
      if (moved && !silent) {
        this._trigger('focus', event);
      }
      return moved;
    },
    open: function () {
      var that = this;
      if (this._isOpen) {
        if (this._moveToTop()) {
          this._focusTabbable();
        }
        return;
      }
      this._isOpen = true;
      this.opener = $(this.document[0].activeElement);
      this._size();
      this._position();
      this._createOverlay();
      this._moveToTop(null, true);
      this._show(this.uiDialog, this.options.show, function () {
        that._focusTabbable();
        that._trigger('focus');
      });
      this._trigger('open');
    },
    _focusTabbable: function () {
      // Set focus to the first match:
      // 1. First element inside the dialog matching [autofocus]
      // 2. Tabbable element inside the content element
      // 3. Tabbable element inside the buttonpane
      // 4. The close button
      // 5. The dialog itself
      var hasFocus = this.element.find('[autofocus]');
      if (!hasFocus.length) {
        hasFocus = this.element.find(':tabbable');
      }
      if (!hasFocus.length) {
        hasFocus = this.uiDialogButtonPane.find(':tabbable');
      }
      if (!hasFocus.length) {
        hasFocus = this.uiDialogTitlebarClose.filter(':tabbable');
      }
      if (!hasFocus.length) {
        hasFocus = this.uiDialog;
      }
      hasFocus.eq(0).focus();
    },
    _keepFocus: function (event) {
      function checkFocus() {
        var activeElement = this.document[0].activeElement, isActive = this.uiDialog[0] === activeElement || $.contains(this.uiDialog[0], activeElement);
        if (!isActive) {
          this._focusTabbable();
        }
      }
      event.preventDefault();
      checkFocus.call(this);
      // support: IE
      // IE <= 8 doesn't prevent moving focus even with event.preventDefault()
      // so we check again later
      this._delay(checkFocus);
    },
    _createWrapper: function () {
      this.uiDialog = $('<div>').addClass('ui-dialog ui-widget ui-widget-content ui-corner-all ui-front ' + this.options.dialogClass).hide().attr({
        tabIndex: -1,
        role: 'dialog'
      }).appendTo(this._appendTo());
      this._on(this.uiDialog, {
        keydown: function (event) {
          if (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode && event.keyCode === $.ui.keyCode.ESCAPE) {
            event.preventDefault();
            this.close(event);
            return;
          }
          // prevent tabbing out of dialogs
          if (event.keyCode !== $.ui.keyCode.TAB) {
            return;
          }
          var tabbables = this.uiDialog.find(':tabbable'), first = tabbables.filter(':first'), last = tabbables.filter(':last');
          if ((event.target === last[0] || event.target === this.uiDialog[0]) && !event.shiftKey) {
            first.focus(1);
            event.preventDefault();
          } else if ((event.target === first[0] || event.target === this.uiDialog[0]) && event.shiftKey) {
            last.focus(1);
            event.preventDefault();
          }
        },
        mousedown: function (event) {
          if (this._moveToTop(event)) {
            this._focusTabbable();
          }
        }
      });
      // We assume that any existing aria-describedby attribute means
      // that the dialog content is marked up properly
      // otherwise we brute force the content as the description
      if (!this.element.find('[aria-describedby]').length) {
        this.uiDialog.attr({ 'aria-describedby': this.element.uniqueId().attr('id') });
      }
    },
    _createTitlebar: function () {
      var uiDialogTitle;
      this.uiDialogTitlebar = $('<div>').addClass('ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix').prependTo(this.uiDialog);
      this._on(this.uiDialogTitlebar, {
        mousedown: function (event) {
          // Don't prevent click on close button (#8838)
          // Focusing a dialog that is partially scrolled out of view
          // causes the browser to scroll it into view, preventing the click event
          if (!$(event.target).closest('.ui-dialog-titlebar-close')) {
            // Dialog isn't getting focus when dragging (#8063)
            this.uiDialog.focus();
          }
        }
      });
      this.uiDialogTitlebarClose = $('<button></button>').button({
        label: this.options.closeText,
        icons: { primary: 'ui-icon-closethick' },
        text: false
      }).addClass('ui-dialog-titlebar-close').appendTo(this.uiDialogTitlebar);
      this._on(this.uiDialogTitlebarClose, {
        click: function (event) {
          event.preventDefault();
          this.close(event);
        }
      });
      uiDialogTitle = $('<span>').uniqueId().addClass('ui-dialog-title').prependTo(this.uiDialogTitlebar);
      this._title(uiDialogTitle);
      this.uiDialog.attr({ 'aria-labelledby': uiDialogTitle.attr('id') });
    },
    _title: function (title) {
      if (!this.options.title) {
        title.html('&#160;');
      }
      title.text(this.options.title);
    },
    _createButtonPane: function () {
      this.uiDialogButtonPane = $('<div>').addClass('ui-dialog-buttonpane ui-widget-content ui-helper-clearfix');
      this.uiButtonSet = $('<div>').addClass('ui-dialog-buttonset').appendTo(this.uiDialogButtonPane);
      this._createButtons();
    },
    _createButtons: function () {
      var that = this, buttons = this.options.buttons;
      // if we already have a button pane, remove it
      this.uiDialogButtonPane.remove();
      this.uiButtonSet.empty();
      if ($.isEmptyObject(buttons) || $.isArray(buttons) && !buttons.length) {
        this.uiDialog.removeClass('ui-dialog-buttons');
        return;
      }
      $.each(buttons, function (name, props) {
        var click, buttonOptions;
        props = $.isFunction(props) ? {
          click: props,
          text: name
        } : props;
        // Default to a non-submitting button
        props = $.extend({ type: 'button' }, props);
        // Change the context for the click callback to be the main element
        click = props.click;
        props.click = function () {
          click.apply(that.element[0], arguments);
        };
        buttonOptions = {
          icons: props.icons,
          text: props.showText
        };
        delete props.icons;
        delete props.showText;
        $('<button></button>', props).button(buttonOptions).appendTo(that.uiButtonSet);
      });
      this.uiDialog.addClass('ui-dialog-buttons');
      this.uiDialogButtonPane.appendTo(this.uiDialog);
    },
    _makeDraggable: function () {
      var that = this, options = this.options;
      function filteredUi(ui) {
        return {
          position: ui.position,
          offset: ui.offset
        };
      }
      this.uiDialog.draggable({
        cancel: '.ui-dialog-content, .ui-dialog-titlebar-close',
        handle: '.ui-dialog-titlebar',
        containment: 'document',
        start: function (event, ui) {
          $(this).addClass('ui-dialog-dragging');
          that._blockFrames();
          that._trigger('dragStart', event, filteredUi(ui));
        },
        drag: function (event, ui) {
          that._trigger('drag', event, filteredUi(ui));
        },
        stop: function (event, ui) {
          options.position = [
            ui.position.left - that.document.scrollLeft(),
            ui.position.top - that.document.scrollTop()
          ];
          $(this).removeClass('ui-dialog-dragging');
          that._unblockFrames();
          that._trigger('dragStop', event, filteredUi(ui));
        }
      });
    },
    _makeResizable: function () {
      var that = this, options = this.options, handles = options.resizable,
        // .ui-resizable has position: relative defined in the stylesheet
        // but dialogs have to use absolute or fixed positioning
        position = this.uiDialog.css('position'), resizeHandles = typeof handles === 'string' ? handles : 'n,e,s,w,se,sw,ne,nw';
      function filteredUi(ui) {
        return {
          originalPosition: ui.originalPosition,
          originalSize: ui.originalSize,
          position: ui.position,
          size: ui.size
        };
      }
      this.uiDialog.resizable({
        cancel: '.ui-dialog-content',
        containment: 'document',
        alsoResize: this.element,
        maxWidth: options.maxWidth,
        maxHeight: options.maxHeight,
        minWidth: options.minWidth,
        minHeight: this._minHeight(),
        handles: resizeHandles,
        start: function (event, ui) {
          $(this).addClass('ui-dialog-resizing');
          that._blockFrames();
          that._trigger('resizeStart', event, filteredUi(ui));
        },
        resize: function (event, ui) {
          that._trigger('resize', event, filteredUi(ui));
        },
        stop: function (event, ui) {
          options.height = $(this).height();
          options.width = $(this).width();
          $(this).removeClass('ui-dialog-resizing');
          that._unblockFrames();
          that._trigger('resizeStop', event, filteredUi(ui));
        }
      }).css('position', position);
    },
    _minHeight: function () {
      var options = this.options;
      return options.height === 'auto' ? options.minHeight : Math.min(options.minHeight, options.height);
    },
    _position: function () {
      // Need to show the dialog to get the actual offset in the position plugin
      var isVisible = this.uiDialog.is(':visible');
      if (!isVisible) {
        this.uiDialog.show();
      }
      this.uiDialog.position(this.options.position);
      if (!isVisible) {
        this.uiDialog.hide();
      }
    },
    _setOptions: function (options) {
      var that = this, resize = false, resizableOptions = {};
      $.each(options, function (key, value) {
        that._setOption(key, value);
        if (key in sizeRelatedOptions) {
          resize = true;
        }
        if (key in resizableRelatedOptions) {
          resizableOptions[key] = value;
        }
      });
      if (resize) {
        this._size();
        this._position();
      }
      if (this.uiDialog.is(':data(ui-resizable)')) {
        this.uiDialog.resizable('option', resizableOptions);
      }
    },
    _setOption: function (key, value) {
      /*jshint maxcomplexity:15*/
      var isDraggable, isResizable, uiDialog = this.uiDialog;
      if (key === 'dialogClass') {
        uiDialog.removeClass(this.options.dialogClass).addClass(value);
      }
      if (key === 'disabled') {
        return;
      }
      this._super(key, value);
      if (key === 'appendTo') {
        this.uiDialog.appendTo(this._appendTo());
      }
      if (key === 'buttons') {
        this._createButtons();
      }
      if (key === 'closeText') {
        this.uiDialogTitlebarClose.button({ label: '' + value });
      }
      if (key === 'draggable') {
        isDraggable = uiDialog.is(':data(ui-draggable)');
        if (isDraggable && !value) {
          uiDialog.draggable('destroy');
        }
        if (!isDraggable && value) {
          this._makeDraggable();
        }
      }
      if (key === 'position') {
        this._position();
      }
      if (key === 'resizable') {
        // currently resizable, becoming non-resizable
        isResizable = uiDialog.is(':data(ui-resizable)');
        if (isResizable && !value) {
          uiDialog.resizable('destroy');
        }
        // currently resizable, changing handles
        if (isResizable && typeof value === 'string') {
          uiDialog.resizable('option', 'handles', value);
        }
        // currently non-resizable, becoming resizable
        if (!isResizable && value !== false) {
          this._makeResizable();
        }
      }
      if (key === 'title') {
        this._title(this.uiDialogTitlebar.find('.ui-dialog-title'));
      }
    },
    _size: function () {
      // If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
      // divs will both have width and height set, so we need to reset them
      var nonContentHeight, minContentHeight, maxContentHeight, options = this.options;
      // Reset content sizing
      this.element.show().css({
        width: 'auto',
        minHeight: 0,
        maxHeight: 'none',
        height: 0
      });
      if (options.minWidth > options.width) {
        options.width = options.minWidth;
      }
      // reset wrapper sizing
      // determine the height of all the non-content elements
      nonContentHeight = this.uiDialog.css({
        height: 'auto',
        width: options.width
      }).outerHeight();
      minContentHeight = Math.max(0, options.minHeight - nonContentHeight);
      maxContentHeight = typeof options.maxHeight === 'number' ? Math.max(0, options.maxHeight - nonContentHeight) : 'none';
      if (options.height === 'auto') {
        this.element.css({
          minHeight: minContentHeight,
          maxHeight: maxContentHeight,
          height: 'auto'
        });
      } else {
        this.element.height(Math.max(0, options.height - nonContentHeight));
      }
      if (this.uiDialog.is(':data(ui-resizable)')) {
        this.uiDialog.resizable('option', 'minHeight', this._minHeight());
      }
    },
    _blockFrames: function () {
      this.iframeBlocks = this.document.find('iframe').map(function () {
        var iframe = $(this);
        return $('<div>').css({
          position: 'absolute',
          width: iframe.outerWidth(),
          height: iframe.outerHeight()
        }).appendTo(iframe.parent()).offset(iframe.offset())[0];
      });
    },
    _unblockFrames: function () {
      if (this.iframeBlocks) {
        this.iframeBlocks.remove();
        delete this.iframeBlocks;
      }
    },
    _allowInteraction: function (event) {
      if ($(event.target).closest('.ui-dialog').length) {
        return true;
      }
      // TODO: Remove hack when datepicker implements
      // the .ui-front logic (#8989)
      return !!$(event.target).closest('.ui-datepicker').length;
    },
    _createOverlay: function () {
      if (!this.options.modal) {
        return;
      }
      var that = this, widgetFullName = this.widgetFullName;
      if (!$.ui.dialog.overlayInstances) {
        // Prevent use of anchors and inputs.
        // We use a delay in case the overlay is created from an
        // event that we're going to be cancelling. (#2804)
        this._delay(function () {
          // Handle .dialog().dialog("close") (#4065)
          if ($.ui.dialog.overlayInstances) {
            this.document.bind('focusin.dialog', function (event) {
              if (!that._allowInteraction(event)) {
                event.preventDefault();
                $('.ui-dialog:visible:last .ui-dialog-content').data(widgetFullName)._focusTabbable();
              }
            });
          }
        });
      }
      this.overlay = $('<div>').addClass('ui-widget-overlay ui-front').appendTo(this._appendTo());
      this._on(this.overlay, { mousedown: '_keepFocus' });
      $.ui.dialog.overlayInstances++;
    },
    _destroyOverlay: function () {
      if (!this.options.modal) {
        return;
      }
      if (this.overlay) {
        $.ui.dialog.overlayInstances--;
        if (!$.ui.dialog.overlayInstances) {
          this.document.unbind('focusin.dialog');
        }
        this.overlay.remove();
        this.overlay = null;
      }
    }
  });
  $.ui.dialog.overlayInstances = 0;
  // DEPRECATED
  if ($.uiBackCompat !== false) {
    // position option with array notation
    // just override with old implementation
    $.widget('ui.dialog', $.ui.dialog, {
      _position: function () {
        var position = this.options.position, myAt = [], offset = [
            0,
            0
          ], isVisible;
        if (position) {
          if (typeof position === 'string' || typeof position === 'object' && '0' in position) {
            myAt = position.split ? position.split(' ') : [
              position[0],
              position[1]
            ];
            if (myAt.length === 1) {
              myAt[1] = myAt[0];
            }
            $.each([
              'left',
              'top'
            ], function (i, offsetPosition) {
              if (+myAt[i] === myAt[i]) {
                offset[i] = myAt[i];
                myAt[i] = offsetPosition;
              }
            });
            position = {
              my: myAt[0] + (offset[0] < 0 ? offset[0] : '+' + offset[0]) + ' ' + myAt[1] + (offset[1] < 0 ? offset[1] : '+' + offset[1]),
              at: myAt.join(' ')
            };
          }
          position = $.extend({}, $.ui.dialog.prototype.options.position, position);
        } else {
          position = $.ui.dialog.prototype.options.position;
        }
        // need to show the dialog to get the actual offset in the position plugin
        isVisible = this.uiDialog.is(':visible');
        if (!isVisible) {
          this.uiDialog.show();
        }
        this.uiDialog.position(position);
        if (!isVisible) {
          this.uiDialog.hide();
        }
      }
    });
  }
}(jQuery));
(function ($, undefined) {
  var rvertical = /up|down|vertical/, rpositivemotion = /up|left|vertical|horizontal/;
  $.effects.effect.blind = function (o, done) {
    // Create element
    var el = $(this), props = [
        'position',
        'top',
        'bottom',
        'left',
        'right',
        'height',
        'width'
      ], mode = $.effects.setMode(el, o.mode || 'hide'), direction = o.direction || 'up', vertical = rvertical.test(direction), ref = vertical ? 'height' : 'width', ref2 = vertical ? 'top' : 'left', motion = rpositivemotion.test(direction), animation = {}, show = mode === 'show', wrapper, distance, margin;
    // if already wrapped, the wrapper's properties are my property. #6245
    if (el.parent().is('.ui-effects-wrapper')) {
      $.effects.save(el.parent(), props);
    } else {
      $.effects.save(el, props);
    }
    el.show();
    wrapper = $.effects.createWrapper(el).css({ overflow: 'hidden' });
    distance = wrapper[ref]();
    margin = parseFloat(wrapper.css(ref2)) || 0;
    animation[ref] = show ? distance : 0;
    if (!motion) {
      el.css(vertical ? 'bottom' : 'right', 0).css(vertical ? 'top' : 'left', 'auto').css({ position: 'absolute' });
      animation[ref2] = show ? margin : distance + margin;
    }
    // start at 0 if we are showing
    if (show) {
      wrapper.css(ref, 0);
      if (!motion) {
        wrapper.css(ref2, margin + distance);
      }
    }
    // Animate
    wrapper.animate(animation, {
      duration: o.duration,
      easing: o.easing,
      queue: false,
      complete: function () {
        if (mode === 'hide') {
          el.hide();
        }
        $.effects.restore(el, props);
        $.effects.removeWrapper(el);
        done();
      }
    });
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.bounce = function (o, done) {
    var el = $(this), props = [
        'position',
        'top',
        'bottom',
        'left',
        'right',
        'height',
        'width'
      ],
      // defaults:
      mode = $.effects.setMode(el, o.mode || 'effect'), hide = mode === 'hide', show = mode === 'show', direction = o.direction || 'up', distance = o.distance, times = o.times || 5,
      // number of internal animations
      anims = times * 2 + (show || hide ? 1 : 0), speed = o.duration / anims, easing = o.easing,
      // utility:
      ref = direction === 'up' || direction === 'down' ? 'top' : 'left', motion = direction === 'up' || direction === 'left', i, upAnim, downAnim,
      // we will need to re-assemble the queue to stack our animations in place
      queue = el.queue(), queuelen = queue.length;
    // Avoid touching opacity to prevent clearType and PNG issues in IE
    if (show || hide) {
      props.push('opacity');
    }
    $.effects.save(el, props);
    el.show();
    $.effects.createWrapper(el);
    // Create Wrapper
    // default distance for the BIGGEST bounce is the outer Distance / 3
    if (!distance) {
      distance = el[ref === 'top' ? 'outerHeight' : 'outerWidth']() / 3;
    }
    if (show) {
      downAnim = { opacity: 1 };
      downAnim[ref] = 0;
      // if we are showing, force opacity 0 and set the initial position
      // then do the "first" animation
      el.css('opacity', 0).css(ref, motion ? -distance * 2 : distance * 2).animate(downAnim, speed, easing);
    }
    // start at the smallest distance if we are hiding
    if (hide) {
      distance = distance / Math.pow(2, times - 1);
    }
    downAnim = {};
    downAnim[ref] = 0;
    // Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
    for (i = 0; i < times; i++) {
      upAnim = {};
      upAnim[ref] = (motion ? '-=' : '+=') + distance;
      el.animate(upAnim, speed, easing).animate(downAnim, speed, easing);
      distance = hide ? distance * 2 : distance / 2;
    }
    // Last Bounce when Hiding
    if (hide) {
      upAnim = { opacity: 0 };
      upAnim[ref] = (motion ? '-=' : '+=') + distance;
      el.animate(upAnim, speed, easing);
    }
    el.queue(function () {
      if (hide) {
        el.hide();
      }
      $.effects.restore(el, props);
      $.effects.removeWrapper(el);
      done();
    });
    // inject all the animations we just queued to be first in line (after "inprogress")
    if (queuelen > 1) {
      queue.splice.apply(queue, [
        1,
        0
      ].concat(queue.splice(queuelen, anims + 1)));
    }
    el.dequeue();
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.clip = function (o, done) {
    // Create element
    var el = $(this), props = [
        'position',
        'top',
        'bottom',
        'left',
        'right',
        'height',
        'width'
      ], mode = $.effects.setMode(el, o.mode || 'hide'), show = mode === 'show', direction = o.direction || 'vertical', vert = direction === 'vertical', size = vert ? 'height' : 'width', position = vert ? 'top' : 'left', animation = {}, wrapper, animate, distance;
    // Save & Show
    $.effects.save(el, props);
    el.show();
    // Create Wrapper
    wrapper = $.effects.createWrapper(el).css({ overflow: 'hidden' });
    animate = el[0].tagName === 'IMG' ? wrapper : el;
    distance = animate[size]();
    // Shift
    if (show) {
      animate.css(size, 0);
      animate.css(position, distance / 2);
    }
    // Create Animation Object:
    animation[size] = show ? distance : 0;
    animation[position] = show ? 0 : distance / 2;
    // Animate
    animate.animate(animation, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: function () {
        if (!show) {
          el.hide();
        }
        $.effects.restore(el, props);
        $.effects.removeWrapper(el);
        done();
      }
    });
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.drop = function (o, done) {
    var el = $(this), props = [
        'position',
        'top',
        'bottom',
        'left',
        'right',
        'opacity',
        'height',
        'width'
      ], mode = $.effects.setMode(el, o.mode || 'hide'), show = mode === 'show', direction = o.direction || 'left', ref = direction === 'up' || direction === 'down' ? 'top' : 'left', motion = direction === 'up' || direction === 'left' ? 'pos' : 'neg', animation = { opacity: show ? 1 : 0 }, distance;
    // Adjust
    $.effects.save(el, props);
    el.show();
    $.effects.createWrapper(el);
    distance = o.distance || el[ref === 'top' ? 'outerHeight' : 'outerWidth'](true) / 2;
    if (show) {
      el.css('opacity', 0).css(ref, motion === 'pos' ? -distance : distance);
    }
    // Animation
    animation[ref] = (show ? motion === 'pos' ? '+=' : '-=' : motion === 'pos' ? '-=' : '+=') + distance;
    // Animate
    el.animate(animation, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: function () {
        if (mode === 'hide') {
          el.hide();
        }
        $.effects.restore(el, props);
        $.effects.removeWrapper(el);
        done();
      }
    });
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.explode = function (o, done) {
    var rows = o.pieces ? Math.round(Math.sqrt(o.pieces)) : 3, cells = rows, el = $(this), mode = $.effects.setMode(el, o.mode || 'hide'), show = mode === 'show',
      // show and then visibility:hidden the element before calculating offset
      offset = el.show().css('visibility', 'hidden').offset(),
      // width and height of a piece
      width = Math.ceil(el.outerWidth() / cells), height = Math.ceil(el.outerHeight() / rows), pieces = [],
      // loop
      i, j, left, top, mx, my;
    // children animate complete:
    function childComplete() {
      pieces.push(this);
      if (pieces.length === rows * cells) {
        animComplete();
      }
    }
    // clone the element for each row and cell.
    for (i = 0; i < rows; i++) {
      // ===>
      top = offset.top + i * height;
      my = i - (rows - 1) / 2;
      for (j = 0; j < cells; j++) {
        // |||
        left = offset.left + j * width;
        mx = j - (cells - 1) / 2;
        // Create a clone of the now hidden main element that will be absolute positioned
        // within a wrapper div off the -left and -top equal to size of our pieces
        el.clone().appendTo('body').wrap('<div></div>').css({
          position: 'absolute',
          visibility: 'visible',
          left: -j * width,
          top: -i * height
        }).parent().addClass('ui-effects-explode').css({
          position: 'absolute',
          overflow: 'hidden',
          width: width,
          height: height,
          left: left + (show ? mx * width : 0),
          top: top + (show ? my * height : 0),
          opacity: show ? 0 : 1
        }).animate({
          left: left + (show ? 0 : mx * width),
          top: top + (show ? 0 : my * height),
          opacity: show ? 1 : 0
        }, o.duration || 500, o.easing, childComplete);
      }
    }
    function animComplete() {
      el.css({ visibility: 'visible' });
      $(pieces).remove();
      if (!show) {
        el.hide();
      }
      done();
    }
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.fade = function (o, done) {
    var el = $(this), mode = $.effects.setMode(el, o.mode || 'toggle');
    el.animate({ opacity: mode }, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: done
    });
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.fold = function (o, done) {
    // Create element
    var el = $(this), props = [
        'position',
        'top',
        'bottom',
        'left',
        'right',
        'height',
        'width'
      ], mode = $.effects.setMode(el, o.mode || 'hide'), show = mode === 'show', hide = mode === 'hide', size = o.size || 15, percent = /([0-9]+)%/.exec(size), horizFirst = !!o.horizFirst, widthFirst = show !== horizFirst, ref = widthFirst ? [
        'width',
        'height'
      ] : [
        'height',
        'width'
      ], duration = o.duration / 2, wrapper, distance, animation1 = {}, animation2 = {};
    $.effects.save(el, props);
    el.show();
    // Create Wrapper
    wrapper = $.effects.createWrapper(el).css({ overflow: 'hidden' });
    distance = widthFirst ? [
      wrapper.width(),
      wrapper.height()
    ] : [
      wrapper.height(),
      wrapper.width()
    ];
    if (percent) {
      size = parseInt(percent[1], 10) / 100 * distance[hide ? 0 : 1];
    }
    if (show) {
      wrapper.css(horizFirst ? {
        height: 0,
        width: size
      } : {
        height: size,
        width: 0
      });
    }
    // Animation
    animation1[ref[0]] = show ? distance[0] : size;
    animation2[ref[1]] = show ? distance[1] : 0;
    // Animate
    wrapper.animate(animation1, duration, o.easing).animate(animation2, duration, o.easing, function () {
      if (hide) {
        el.hide();
      }
      $.effects.restore(el, props);
      $.effects.removeWrapper(el);
      done();
    });
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.highlight = function (o, done) {
    var elem = $(this), props = [
        'backgroundImage',
        'backgroundColor',
        'opacity'
      ], mode = $.effects.setMode(elem, o.mode || 'show'), animation = { backgroundColor: elem.css('backgroundColor') };
    if (mode === 'hide') {
      animation.opacity = 0;
    }
    $.effects.save(elem, props);
    elem.show().css({
      backgroundImage: 'none',
      backgroundColor: o.color || '#ffff99'
    }).animate(animation, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: function () {
        if (mode === 'hide') {
          elem.hide();
        }
        $.effects.restore(elem, props);
        done();
      }
    });
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.pulsate = function (o, done) {
    var elem = $(this), mode = $.effects.setMode(elem, o.mode || 'show'), show = mode === 'show', hide = mode === 'hide', showhide = show || mode === 'hide',
      // showing or hiding leaves of the "last" animation
      anims = (o.times || 5) * 2 + (showhide ? 1 : 0), duration = o.duration / anims, animateTo = 0, queue = elem.queue(), queuelen = queue.length, i;
    if (show || !elem.is(':visible')) {
      elem.css('opacity', 0).show();
      animateTo = 1;
    }
    // anims - 1 opacity "toggles"
    for (i = 1; i < anims; i++) {
      elem.animate({ opacity: animateTo }, duration, o.easing);
      animateTo = 1 - animateTo;
    }
    elem.animate({ opacity: animateTo }, duration, o.easing);
    elem.queue(function () {
      if (hide) {
        elem.hide();
      }
      done();
    });
    // We just queued up "anims" animations, we need to put them next in the queue
    if (queuelen > 1) {
      queue.splice.apply(queue, [
        1,
        0
      ].concat(queue.splice(queuelen, anims + 1)));
    }
    elem.dequeue();
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.puff = function (o, done) {
    var elem = $(this), mode = $.effects.setMode(elem, o.mode || 'hide'), hide = mode === 'hide', percent = parseInt(o.percent, 10) || 150, factor = percent / 100, original = {
        height: elem.height(),
        width: elem.width(),
        outerHeight: elem.outerHeight(),
        outerWidth: elem.outerWidth()
      };
    $.extend(o, {
      effect: 'scale',
      queue: false,
      fade: true,
      mode: mode,
      complete: done,
      percent: hide ? percent : 100,
      from: hide ? original : {
        height: original.height * factor,
        width: original.width * factor,
        outerHeight: original.outerHeight * factor,
        outerWidth: original.outerWidth * factor
      }
    });
    elem.effect(o);
  };
  $.effects.effect.scale = function (o, done) {
    // Create element
    var el = $(this), options = $.extend(true, {}, o), mode = $.effects.setMode(el, o.mode || 'effect'), percent = parseInt(o.percent, 10) || (parseInt(o.percent, 10) === 0 ? 0 : mode === 'hide' ? 0 : 100), direction = o.direction || 'both', origin = o.origin, original = {
        height: el.height(),
        width: el.width(),
        outerHeight: el.outerHeight(),
        outerWidth: el.outerWidth()
      }, factor = {
        y: direction !== 'horizontal' ? percent / 100 : 1,
        x: direction !== 'vertical' ? percent / 100 : 1
      };
    // We are going to pass this effect to the size effect:
    options.effect = 'size';
    options.queue = false;
    options.complete = done;
    // Set default origin and restore for show/hide
    if (mode !== 'effect') {
      options.origin = origin || [
        'middle',
        'center'
      ];
      options.restore = true;
    }
    options.from = o.from || (mode === 'show' ? {
      height: 0,
      width: 0,
      outerHeight: 0,
      outerWidth: 0
    } : original);
    options.to = {
      height: original.height * factor.y,
      width: original.width * factor.x,
      outerHeight: original.outerHeight * factor.y,
      outerWidth: original.outerWidth * factor.x
    };
    // Fade option to support puff
    if (options.fade) {
      if (mode === 'show') {
        options.from.opacity = 0;
        options.to.opacity = 1;
      }
      if (mode === 'hide') {
        options.from.opacity = 1;
        options.to.opacity = 0;
      }
    }
    // Animate
    el.effect(options);
  };
  $.effects.effect.size = function (o, done) {
    // Create element
    var original, baseline, factor, el = $(this), props0 = [
        'position',
        'top',
        'bottom',
        'left',
        'right',
        'width',
        'height',
        'overflow',
        'opacity'
      ],
      // Always restore
      props1 = [
        'position',
        'top',
        'bottom',
        'left',
        'right',
        'overflow',
        'opacity'
      ],
      // Copy for children
      props2 = [
        'width',
        'height',
        'overflow'
      ], cProps = ['fontSize'], vProps = [
        'borderTopWidth',
        'borderBottomWidth',
        'paddingTop',
        'paddingBottom'
      ], hProps = [
        'borderLeftWidth',
        'borderRightWidth',
        'paddingLeft',
        'paddingRight'
      ],
      // Set options
      mode = $.effects.setMode(el, o.mode || 'effect'), restore = o.restore || mode !== 'effect', scale = o.scale || 'both', origin = o.origin || [
        'middle',
        'center'
      ], position = el.css('position'), props = restore ? props0 : props1, zero = {
        height: 0,
        width: 0,
        outerHeight: 0,
        outerWidth: 0
      };
    if (mode === 'show') {
      el.show();
    }
    original = {
      height: el.height(),
      width: el.width(),
      outerHeight: el.outerHeight(),
      outerWidth: el.outerWidth()
    };
    if (o.mode === 'toggle' && mode === 'show') {
      el.from = o.to || zero;
      el.to = o.from || original;
    } else {
      el.from = o.from || (mode === 'show' ? zero : original);
      el.to = o.to || (mode === 'hide' ? zero : original);
    }
    // Set scaling factor
    factor = {
      from: {
        y: el.from.height / original.height,
        x: el.from.width / original.width
      },
      to: {
        y: el.to.height / original.height,
        x: el.to.width / original.width
      }
    };
    // Scale the css box
    if (scale === 'box' || scale === 'both') {
      // Vertical props scaling
      if (factor.from.y !== factor.to.y) {
        props = props.concat(vProps);
        el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);
        el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);
      }
      // Horizontal props scaling
      if (factor.from.x !== factor.to.x) {
        props = props.concat(hProps);
        el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);
        el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);
      }
    }
    // Scale the content
    if (scale === 'content' || scale === 'both') {
      // Vertical props scaling
      if (factor.from.y !== factor.to.y) {
        props = props.concat(cProps).concat(props2);
        el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);
        el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);
      }
    }
    $.effects.save(el, props);
    el.show();
    $.effects.createWrapper(el);
    el.css('overflow', 'hidden').css(el.from);
    // Adjust
    if (origin) {
      // Calculate baseline shifts
      baseline = $.effects.getBaseline(origin, original);
      el.from.top = (original.outerHeight - el.outerHeight()) * baseline.y;
      el.from.left = (original.outerWidth - el.outerWidth()) * baseline.x;
      el.to.top = (original.outerHeight - el.to.outerHeight) * baseline.y;
      el.to.left = (original.outerWidth - el.to.outerWidth) * baseline.x;
    }
    el.css(el.from);
    // set top & left
    // Animate
    if (scale === 'content' || scale === 'both') {
      // Scale the children
      // Add margins/font-size
      vProps = vProps.concat([
        'marginTop',
        'marginBottom'
      ]).concat(cProps);
      hProps = hProps.concat([
        'marginLeft',
        'marginRight'
      ]);
      props2 = props0.concat(vProps).concat(hProps);
      el.find('*[width]').each(function () {
        var child = $(this), c_original = {
            height: child.height(),
            width: child.width(),
            outerHeight: child.outerHeight(),
            outerWidth: child.outerWidth()
          };
        if (restore) {
          $.effects.save(child, props2);
        }
        child.from = {
          height: c_original.height * factor.from.y,
          width: c_original.width * factor.from.x,
          outerHeight: c_original.outerHeight * factor.from.y,
          outerWidth: c_original.outerWidth * factor.from.x
        };
        child.to = {
          height: c_original.height * factor.to.y,
          width: c_original.width * factor.to.x,
          outerHeight: c_original.height * factor.to.y,
          outerWidth: c_original.width * factor.to.x
        };
        // Vertical props scaling
        if (factor.from.y !== factor.to.y) {
          child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);
          child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);
        }
        // Horizontal props scaling
        if (factor.from.x !== factor.to.x) {
          child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);
          child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);
        }
        // Animate children
        child.css(child.from);
        child.animate(child.to, o.duration, o.easing, function () {
          // Restore children
          if (restore) {
            $.effects.restore(child, props2);
          }
        });
      });
    }
    // Animate
    el.animate(el.to, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: function () {
        if (el.to.opacity === 0) {
          el.css('opacity', el.from.opacity);
        }
        if (mode === 'hide') {
          el.hide();
        }
        $.effects.restore(el, props);
        if (!restore) {
          // we need to calculate our new positioning based on the scaling
          if (position === 'static') {
            el.css({
              position: 'relative',
              top: el.to.top,
              left: el.to.left
            });
          } else {
            $.each([
              'top',
              'left'
            ], function (idx, pos) {
              el.css(pos, function (_, str) {
                var val = parseInt(str, 10), toRef = idx ? el.to.left : el.to.top;
                // if original was "auto", recalculate the new value from wrapper
                if (str === 'auto') {
                  return toRef + 'px';
                }
                return val + toRef + 'px';
              });
            });
          }
        }
        $.effects.removeWrapper(el);
        done();
      }
    });
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.shake = function (o, done) {
    var el = $(this), props = [
        'position',
        'top',
        'bottom',
        'left',
        'right',
        'height',
        'width'
      ], mode = $.effects.setMode(el, o.mode || 'effect'), direction = o.direction || 'left', distance = o.distance || 20, times = o.times || 3, anims = times * 2 + 1, speed = Math.round(o.duration / anims), ref = direction === 'up' || direction === 'down' ? 'top' : 'left', positiveMotion = direction === 'up' || direction === 'left', animation = {}, animation1 = {}, animation2 = {}, i,
      // we will need to re-assemble the queue to stack our animations in place
      queue = el.queue(), queuelen = queue.length;
    $.effects.save(el, props);
    el.show();
    $.effects.createWrapper(el);
    // Animation
    animation[ref] = (positiveMotion ? '-=' : '+=') + distance;
    animation1[ref] = (positiveMotion ? '+=' : '-=') + distance * 2;
    animation2[ref] = (positiveMotion ? '-=' : '+=') + distance * 2;
    // Animate
    el.animate(animation, speed, o.easing);
    // Shakes
    for (i = 1; i < times; i++) {
      el.animate(animation1, speed, o.easing).animate(animation2, speed, o.easing);
    }
    el.animate(animation1, speed, o.easing).animate(animation, speed / 2, o.easing).queue(function () {
      if (mode === 'hide') {
        el.hide();
      }
      $.effects.restore(el, props);
      $.effects.removeWrapper(el);
      done();
    });
    // inject all the animations we just queued to be first in line (after "inprogress")
    if (queuelen > 1) {
      queue.splice.apply(queue, [
        1,
        0
      ].concat(queue.splice(queuelen, anims + 1)));
    }
    el.dequeue();
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.slide = function (o, done) {
    // Create element
    var el = $(this), props = [
        'position',
        'top',
        'bottom',
        'left',
        'right',
        'width',
        'height'
      ], mode = $.effects.setMode(el, o.mode || 'show'), show = mode === 'show', direction = o.direction || 'left', ref = direction === 'up' || direction === 'down' ? 'top' : 'left', positiveMotion = direction === 'up' || direction === 'left', distance, animation = {};
    // Adjust
    $.effects.save(el, props);
    el.show();
    distance = o.distance || el[ref === 'top' ? 'outerHeight' : 'outerWidth'](true);
    $.effects.createWrapper(el).css({ overflow: 'hidden' });
    if (show) {
      el.css(ref, positiveMotion ? isNaN(distance) ? '-' + distance : -distance : distance);
    }
    // Animation
    animation[ref] = (show ? positiveMotion ? '+=' : '-=' : positiveMotion ? '-=' : '+=') + distance;
    // Animate
    el.animate(animation, {
      queue: false,
      duration: o.duration,
      easing: o.easing,
      complete: function () {
        if (mode === 'hide') {
          el.hide();
        }
        $.effects.restore(el, props);
        $.effects.removeWrapper(el);
        done();
      }
    });
  };
}(jQuery));
(function ($, undefined) {
  $.effects.effect.transfer = function (o, done) {
    var elem = $(this), target = $(o.to), targetFixed = target.css('position') === 'fixed', body = $('body'), fixTop = targetFixed ? body.scrollTop() : 0, fixLeft = targetFixed ? body.scrollLeft() : 0, endPosition = target.offset(), animation = {
        top: endPosition.top - fixTop,
        left: endPosition.left - fixLeft,
        height: target.innerHeight(),
        width: target.innerWidth()
      }, startPosition = elem.offset(), transfer = $('<div class=\'ui-effects-transfer\'></div>').appendTo(document.body).addClass(o.className).css({
        top: startPosition.top - fixTop,
        left: startPosition.left - fixLeft,
        height: elem.innerHeight(),
        width: elem.innerWidth(),
        position: targetFixed ? 'fixed' : 'absolute'
      }).animate(animation, o.duration, o.easing, function () {
        transfer.remove();
        done();
      });
  };
}(jQuery));
(function ($, undefined) {
  $.widget('ui.menu', {
    version: '1.10.3',
    defaultElement: '<ul>',
    delay: 300,
    options: {
      icons: { submenu: 'ui-icon-carat-1-e' },
      menus: 'ul',
      position: {
        my: 'left top',
        at: 'right top'
      },
      role: 'menu',
      blur: null,
      focus: null,
      select: null
    },
    _create: function () {
      this.activeMenu = this.element;
      // flag used to prevent firing of the click handler
      // as the event bubbles up through nested menus
      this.mouseHandled = false;
      this.element.uniqueId().addClass('ui-menu ui-widget ui-widget-content ui-corner-all').toggleClass('ui-menu-icons', !!this.element.find('.ui-icon').length).attr({
        role: this.options.role,
        tabIndex: 0
      }).bind('click' + this.eventNamespace, $.proxy(function (event) {
        if (this.options.disabled) {
          event.preventDefault();
        }
      }, this));
      if (this.options.disabled) {
        this.element.addClass('ui-state-disabled').attr('aria-disabled', 'true');
      }
      this._on({
        'mousedown .ui-menu-item > a': function (event) {
          event.preventDefault();
        },
        'click .ui-state-disabled > a': function (event) {
          event.preventDefault();
        },
        'click .ui-menu-item:has(a)': function (event) {
          var target = $(event.target).closest('.ui-menu-item');
          if (!this.mouseHandled && target.not('.ui-state-disabled').length) {
            this.mouseHandled = true;
            this.select(event);
            // Open submenu on click
            if (target.has('.ui-menu').length) {
              this.expand(event);
            } else if (!this.element.is(':focus')) {
              // Redirect focus to the menu
              this.element.trigger('focus', [true]);
              // If the active item is on the top level, let it stay active.
              // Otherwise, blur the active item since it is no longer visible.
              if (this.active && this.active.parents('.ui-menu').length === 1) {
                clearTimeout(this.timer);
              }
            }
          }
        },
        'mouseenter .ui-menu-item': function (event) {
          var target = $(event.currentTarget);
          // Remove ui-state-active class from siblings of the newly focused menu item
          // to avoid a jump caused by adjacent elements both having a class with a border
          target.siblings().children('.ui-state-active').removeClass('ui-state-active');
          this.focus(event, target);
        },
        mouseleave: 'collapseAll',
        'mouseleave .ui-menu': 'collapseAll',
        focus: function (event, keepActiveItem) {
          // If there's already an active item, keep it active
          // If not, activate the first item
          var item = this.active || this.element.children('.ui-menu-item').eq(0);
          if (!keepActiveItem) {
            this.focus(event, item);
          }
        },
        blur: function (event) {
          this._delay(function () {
            if (!$.contains(this.element[0], this.document[0].activeElement)) {
              this.collapseAll(event);
            }
          });
        },
        keydown: '_keydown'
      });
      this.refresh();
      // Clicks outside of a menu collapse any open menus
      this._on(this.document, {
        click: function (event) {
          if (!$(event.target).closest('.ui-menu').length) {
            this.collapseAll(event);
          }
          // Reset the mouseHandled flag
          this.mouseHandled = false;
        }
      });
    },
    _destroy: function () {
      // Destroy (sub)menus
      this.element.removeAttr('aria-activedescendant').find('.ui-menu').addBack().removeClass('ui-menu ui-widget ui-widget-content ui-corner-all ui-menu-icons').removeAttr('role').removeAttr('tabIndex').removeAttr('aria-labelledby').removeAttr('aria-expanded').removeAttr('aria-hidden').removeAttr('aria-disabled').removeUniqueId().show();
      // Destroy menu items
      this.element.find('.ui-menu-item').removeClass('ui-menu-item').removeAttr('role').removeAttr('aria-disabled').children('a').removeUniqueId().removeClass('ui-corner-all ui-state-hover').removeAttr('tabIndex').removeAttr('role').removeAttr('aria-haspopup').children().each(function () {
        var elem = $(this);
        if (elem.data('ui-menu-submenu-carat')) {
          elem.remove();
        }
      });
      // Destroy menu dividers
      this.element.find('.ui-menu-divider').removeClass('ui-menu-divider ui-widget-content');
    },
    _keydown: function (event) {
      /*jshint maxcomplexity:20*/
      var match, prev, character, skip, regex, preventDefault = true;
      function escape(value) {
        return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
      }
      switch (event.keyCode) {
      case $.ui.keyCode.PAGE_UP:
        this.previousPage(event);
        break;
      case $.ui.keyCode.PAGE_DOWN:
        this.nextPage(event);
        break;
      case $.ui.keyCode.HOME:
        this._move('first', 'first', event);
        break;
      case $.ui.keyCode.END:
        this._move('last', 'last', event);
        break;
      case $.ui.keyCode.UP:
        this.previous(event);
        break;
      case $.ui.keyCode.DOWN:
        this.next(event);
        break;
      case $.ui.keyCode.LEFT:
        this.collapse(event);
        break;
      case $.ui.keyCode.RIGHT:
        if (this.active && !this.active.is('.ui-state-disabled')) {
          this.expand(event);
        }
        break;
      case $.ui.keyCode.ENTER:
      case $.ui.keyCode.SPACE:
        this._activate(event);
        break;
      case $.ui.keyCode.ESCAPE:
        this.collapse(event);
        break;
      default:
        preventDefault = false;
        prev = this.previousFilter || '';
        character = String.fromCharCode(event.keyCode);
        skip = false;
        clearTimeout(this.filterTimer);
        if (character === prev) {
          skip = true;
        } else {
          character = prev + character;
        }
        regex = new RegExp('^' + escape(character), 'i');
        match = this.activeMenu.children('.ui-menu-item').filter(function () {
          return regex.test($(this).children('a').text());
        });
        match = skip && match.index(this.active.next()) !== -1 ? this.active.nextAll('.ui-menu-item') : match;
        // If no matches on the current filter, reset to the last character pressed
        // to move down the menu to the first item that starts with that character
        if (!match.length) {
          character = String.fromCharCode(event.keyCode);
          regex = new RegExp('^' + escape(character), 'i');
          match = this.activeMenu.children('.ui-menu-item').filter(function () {
            return regex.test($(this).children('a').text());
          });
        }
        if (match.length) {
          this.focus(event, match);
          if (match.length > 1) {
            this.previousFilter = character;
            this.filterTimer = this._delay(function () {
              delete this.previousFilter;
            }, 1000);
          } else {
            delete this.previousFilter;
          }
        } else {
          delete this.previousFilter;
        }
      }
      if (preventDefault) {
        event.preventDefault();
      }
    },
    _activate: function (event) {
      if (!this.active.is('.ui-state-disabled')) {
        if (this.active.children('a[aria-haspopup=\'true\']').length) {
          this.expand(event);
        } else {
          this.select(event);
        }
      }
    },
    refresh: function () {
      var menus, icon = this.options.icons.submenu, submenus = this.element.find(this.options.menus);
      // Initialize nested menus
      submenus.filter(':not(.ui-menu)').addClass('ui-menu ui-widget ui-widget-content ui-corner-all').hide().attr({
        role: this.options.role,
        'aria-hidden': 'true',
        'aria-expanded': 'false'
      }).each(function () {
        var menu = $(this), item = menu.prev('a'), submenuCarat = $('<span>').addClass('ui-menu-icon ui-icon ' + icon).data('ui-menu-submenu-carat', true);
        item.attr('aria-haspopup', 'true').prepend(submenuCarat);
        menu.attr('aria-labelledby', item.attr('id'));
      });
      menus = submenus.add(this.element);
      // Don't refresh list items that are already adapted
      menus.children(':not(.ui-menu-item):has(a)').addClass('ui-menu-item').attr('role', 'presentation').children('a').uniqueId().addClass('ui-corner-all').attr({
        tabIndex: -1,
        role: this._itemRole()
      });
      // Initialize unlinked menu-items containing spaces and/or dashes only as dividers
      menus.children(':not(.ui-menu-item)').each(function () {
        var item = $(this);
        // hyphen, em dash, en dash
        if (!/[^\-\u2014\u2013\s]/.test(item.text())) {
          item.addClass('ui-widget-content ui-menu-divider');
        }
      });
      // Add aria-disabled attribute to any disabled menu item
      menus.children('.ui-state-disabled').attr('aria-disabled', 'true');
      // If the active item has been removed, blur the menu
      if (this.active && !$.contains(this.element[0], this.active[0])) {
        this.blur();
      }
    },
    _itemRole: function () {
      return {
        menu: 'menuitem',
        listbox: 'option'
      }[this.options.role];
    },
    _setOption: function (key, value) {
      if (key === 'icons') {
        this.element.find('.ui-menu-icon').removeClass(this.options.icons.submenu).addClass(value.submenu);
      }
      this._super(key, value);
    },
    focus: function (event, item) {
      var nested, focused;
      this.blur(event, event && event.type === 'focus');
      this._scrollIntoView(item);
      this.active = item.first();
      focused = this.active.children('a').addClass('ui-state-focus');
      // Only update aria-activedescendant if there's a role
      // otherwise we assume focus is managed elsewhere
      if (this.options.role) {
        this.element.attr('aria-activedescendant', focused.attr('id'));
      }
      // Highlight active parent menu item, if any
      this.active.parent().closest('.ui-menu-item').children('a:first').addClass('ui-state-active');
      if (event && event.type === 'keydown') {
        this._close();
      } else {
        this.timer = this._delay(function () {
          this._close();
        }, this.delay);
      }
      nested = item.children('.ui-menu');
      if (nested.length && /^mouse/.test(event.type)) {
        this._startOpening(nested);
      }
      this.activeMenu = item.parent();
      this._trigger('focus', event, { item: item });
    },
    _scrollIntoView: function (item) {
      var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
      if (this._hasScroll()) {
        borderTop = parseFloat($.css(this.activeMenu[0], 'borderTopWidth')) || 0;
        paddingTop = parseFloat($.css(this.activeMenu[0], 'paddingTop')) || 0;
        offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
        scroll = this.activeMenu.scrollTop();
        elementHeight = this.activeMenu.height();
        itemHeight = item.height();
        if (offset < 0) {
          this.activeMenu.scrollTop(scroll + offset);
        } else if (offset + itemHeight > elementHeight) {
          this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);
        }
      }
    },
    blur: function (event, fromFocus) {
      if (!fromFocus) {
        clearTimeout(this.timer);
      }
      if (!this.active) {
        return;
      }
      this.active.children('a').removeClass('ui-state-focus');
      this.active = null;
      this._trigger('blur', event, { item: this.active });
    },
    _startOpening: function (submenu) {
      clearTimeout(this.timer);
      // Don't open if already open fixes a Firefox bug that caused a .5 pixel
      // shift in the submenu position when mousing over the carat icon
      if (submenu.attr('aria-hidden') !== 'true') {
        return;
      }
      this.timer = this._delay(function () {
        this._close();
        this._open(submenu);
      }, this.delay);
    },
    _open: function (submenu) {
      var position = $.extend({ of: this.active }, this.options.position);
      clearTimeout(this.timer);
      this.element.find('.ui-menu').not(submenu.parents('.ui-menu')).hide().attr('aria-hidden', 'true');
      submenu.show().removeAttr('aria-hidden').attr('aria-expanded', 'true').position(position);
    },
    collapseAll: function (event, all) {
      clearTimeout(this.timer);
      this.timer = this._delay(function () {
        // If we were passed an event, look for the submenu that contains the event
        var currentMenu = all ? this.element : $(event && event.target).closest(this.element.find('.ui-menu'));
        // If we found no valid submenu ancestor, use the main menu to close all sub menus anyway
        if (!currentMenu.length) {
          currentMenu = this.element;
        }
        this._close(currentMenu);
        this.blur(event);
        this.activeMenu = currentMenu;
      }, this.delay);
    },
    _close: function (startMenu) {
      if (!startMenu) {
        startMenu = this.active ? this.active.parent() : this.element;
      }
      startMenu.find('.ui-menu').hide().attr('aria-hidden', 'true').attr('aria-expanded', 'false').end().find('a.ui-state-active').removeClass('ui-state-active');
    },
    collapse: function (event) {
      var newItem = this.active && this.active.parent().closest('.ui-menu-item', this.element);
      if (newItem && newItem.length) {
        this._close();
        this.focus(event, newItem);
      }
    },
    expand: function (event) {
      var newItem = this.active && this.active.children('.ui-menu ').children('.ui-menu-item').first();
      if (newItem && newItem.length) {
        this._open(newItem.parent());
        // Delay so Firefox will not hide activedescendant change in expanding submenu from AT
        this._delay(function () {
          this.focus(event, newItem);
        });
      }
    },
    next: function (event) {
      this._move('next', 'first', event);
    },
    previous: function (event) {
      this._move('prev', 'last', event);
    },
    isFirstItem: function () {
      return this.active && !this.active.prevAll('.ui-menu-item').length;
    },
    isLastItem: function () {
      return this.active && !this.active.nextAll('.ui-menu-item').length;
    },
    _move: function (direction, filter, event) {
      var next;
      if (this.active) {
        if (direction === 'first' || direction === 'last') {
          next = this.active[direction === 'first' ? 'prevAll' : 'nextAll']('.ui-menu-item').eq(-1);
        } else {
          next = this.active[direction + 'All']('.ui-menu-item').eq(0);
        }
      }
      if (!next || !next.length || !this.active) {
        next = this.activeMenu.children('.ui-menu-item')[filter]();
      }
      this.focus(event, next);
    },
    nextPage: function (event) {
      var item, base, height;
      if (!this.active) {
        this.next(event);
        return;
      }
      if (this.isLastItem()) {
        return;
      }
      if (this._hasScroll()) {
        base = this.active.offset().top;
        height = this.element.height();
        this.active.nextAll('.ui-menu-item').each(function () {
          item = $(this);
          return item.offset().top - base - height < 0;
        });
        this.focus(event, item);
      } else {
        this.focus(event, this.activeMenu.children('.ui-menu-item')[!this.active ? 'first' : 'last']());
      }
    },
    previousPage: function (event) {
      var item, base, height;
      if (!this.active) {
        this.next(event);
        return;
      }
      if (this.isFirstItem()) {
        return;
      }
      if (this._hasScroll()) {
        base = this.active.offset().top;
        height = this.element.height();
        this.active.prevAll('.ui-menu-item').each(function () {
          item = $(this);
          return item.offset().top - base + height > 0;
        });
        this.focus(event, item);
      } else {
        this.focus(event, this.activeMenu.children('.ui-menu-item').first());
      }
    },
    _hasScroll: function () {
      return this.element.outerHeight() < this.element.prop('scrollHeight');
    },
    select: function (event) {
      // TODO: It should never be possible to not have an active item at this
      // point, but the tests don't trigger mouseenter before click.
      this.active = this.active || $(event.target).closest('.ui-menu-item');
      var ui = { item: this.active };
      if (!this.active.has('.ui-menu').length) {
        this.collapseAll(event, true);
      }
      this._trigger('select', event, ui);
    }
  });
}(jQuery));
(function ($, undefined) {
  $.ui = $.ui || {};
  var cachedScrollbarWidth, max = Math.max, abs = Math.abs, round = Math.round, rhorizontal = /left|center|right/, rvertical = /top|center|bottom/, roffset = /[\+\-]\d+(\.[\d]+)?%?/, rposition = /^\w+/, rpercent = /%$/, _position = $.fn.position;
  function getOffsets(offsets, width, height) {
    return [
      parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1),
      parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1)
    ];
  }
  function parseCss(element, property) {
    return parseInt($.css(element, property), 10) || 0;
  }
  function getDimensions(elem) {
    var raw = elem[0];
    if (raw.nodeType === 9) {
      return {
        width: elem.width(),
        height: elem.height(),
        offset: {
          top: 0,
          left: 0
        }
      };
    }
    if ($.isWindow(raw)) {
      return {
        width: elem.width(),
        height: elem.height(),
        offset: {
          top: elem.scrollTop(),
          left: elem.scrollLeft()
        }
      };
    }
    if (raw.preventDefault) {
      return {
        width: 0,
        height: 0,
        offset: {
          top: raw.pageY,
          left: raw.pageX
        }
      };
    }
    return {
      width: elem.outerWidth(),
      height: elem.outerHeight(),
      offset: elem.offset()
    };
  }
  $.position = {
    scrollbarWidth: function () {
      if (cachedScrollbarWidth !== undefined) {
        return cachedScrollbarWidth;
      }
      var w1, w2, div = $('<div style=\'display:block;width:50px;height:50px;overflow:hidden;\'><div style=\'height:100px;width:auto;\'></div></div>'), innerDiv = div.children()[0];
      $('body').append(div);
      w1 = innerDiv.offsetWidth;
      div.css('overflow', 'scroll');
      w2 = innerDiv.offsetWidth;
      if (w1 === w2) {
        w2 = div[0].clientWidth;
      }
      div.remove();
      return cachedScrollbarWidth = w1 - w2;
    },
    getScrollInfo: function (within) {
      var overflowX = within.isWindow ? '' : within.element.css('overflow-x'), overflowY = within.isWindow ? '' : within.element.css('overflow-y'), hasOverflowX = overflowX === 'scroll' || overflowX === 'auto' && within.width < within.element[0].scrollWidth, hasOverflowY = overflowY === 'scroll' || overflowY === 'auto' && within.height < within.element[0].scrollHeight;
      return {
        width: hasOverflowY ? $.position.scrollbarWidth() : 0,
        height: hasOverflowX ? $.position.scrollbarWidth() : 0
      };
    },
    getWithinInfo: function (element) {
      var withinElement = $(element || window), isWindow = $.isWindow(withinElement[0]);
      return {
        element: withinElement,
        isWindow: isWindow,
        offset: withinElement.offset() || {
          left: 0,
          top: 0
        },
        scrollLeft: withinElement.scrollLeft(),
        scrollTop: withinElement.scrollTop(),
        width: isWindow ? withinElement.width() : withinElement.outerWidth(),
        height: isWindow ? withinElement.height() : withinElement.outerHeight()
      };
    }
  };
  $.fn.position = function (options) {
    if (!options || !options.of) {
      return _position.apply(this, arguments);
    }
    // make a copy, we don't want to modify arguments
    options = $.extend({}, options);
    var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions, target = $(options.of), within = $.position.getWithinInfo(options.within), scrollInfo = $.position.getScrollInfo(within), collision = (options.collision || 'flip').split(' '), offsets = {};
    dimensions = getDimensions(target);
    if (target[0].preventDefault) {
      // force left top to allow flipping
      options.at = 'left top';
    }
    targetWidth = dimensions.width;
    targetHeight = dimensions.height;
    targetOffset = dimensions.offset;
    // clone to reuse original targetOffset later
    basePosition = $.extend({}, targetOffset);
    // force my and at to have valid horizontal and vertical positions
    // if a value is missing or invalid, it will be converted to center
    $.each([
      'my',
      'at'
    ], function () {
      var pos = (options[this] || '').split(' '), horizontalOffset, verticalOffset;
      if (pos.length === 1) {
        pos = rhorizontal.test(pos[0]) ? pos.concat(['center']) : rvertical.test(pos[0]) ? ['center'].concat(pos) : [
          'center',
          'center'
        ];
      }
      pos[0] = rhorizontal.test(pos[0]) ? pos[0] : 'center';
      pos[1] = rvertical.test(pos[1]) ? pos[1] : 'center';
      // calculate offsets
      horizontalOffset = roffset.exec(pos[0]);
      verticalOffset = roffset.exec(pos[1]);
      offsets[this] = [
        horizontalOffset ? horizontalOffset[0] : 0,
        verticalOffset ? verticalOffset[0] : 0
      ];
      // reduce to just the positions without the offsets
      options[this] = [
        rposition.exec(pos[0])[0],
        rposition.exec(pos[1])[0]
      ];
    });
    // normalize collision option
    if (collision.length === 1) {
      collision[1] = collision[0];
    }
    if (options.at[0] === 'right') {
      basePosition.left += targetWidth;
    } else if (options.at[0] === 'center') {
      basePosition.left += targetWidth / 2;
    }
    if (options.at[1] === 'bottom') {
      basePosition.top += targetHeight;
    } else if (options.at[1] === 'center') {
      basePosition.top += targetHeight / 2;
    }
    atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
    basePosition.left += atOffset[0];
    basePosition.top += atOffset[1];
    return this.each(function () {
      var collisionPosition, using, elem = $(this), elemWidth = elem.outerWidth(), elemHeight = elem.outerHeight(), marginLeft = parseCss(this, 'marginLeft'), marginTop = parseCss(this, 'marginTop'), collisionWidth = elemWidth + marginLeft + parseCss(this, 'marginRight') + scrollInfo.width, collisionHeight = elemHeight + marginTop + parseCss(this, 'marginBottom') + scrollInfo.height, position = $.extend({}, basePosition), myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());
      if (options.my[0] === 'right') {
        position.left -= elemWidth;
      } else if (options.my[0] === 'center') {
        position.left -= elemWidth / 2;
      }
      if (options.my[1] === 'bottom') {
        position.top -= elemHeight;
      } else if (options.my[1] === 'center') {
        position.top -= elemHeight / 2;
      }
      position.left += myOffset[0];
      position.top += myOffset[1];
      // if the browser doesn't support fractions, then round for consistent results
      if (!$.support.offsetFractions) {
        position.left = round(position.left);
        position.top = round(position.top);
      }
      collisionPosition = {
        marginLeft: marginLeft,
        marginTop: marginTop
      };
      $.each([
        'left',
        'top'
      ], function (i, dir) {
        if ($.ui.position[collision[i]]) {
          $.ui.position[collision[i]][dir](position, {
            targetWidth: targetWidth,
            targetHeight: targetHeight,
            elemWidth: elemWidth,
            elemHeight: elemHeight,
            collisionPosition: collisionPosition,
            collisionWidth: collisionWidth,
            collisionHeight: collisionHeight,
            offset: [
              atOffset[0] + myOffset[0],
              atOffset[1] + myOffset[1]
            ],
            my: options.my,
            at: options.at,
            within: within,
            elem: elem
          });
        }
      });
      if (options.using) {
        // adds feedback as second argument to using callback, if present
        using = function (props) {
          var left = targetOffset.left - position.left, right = left + targetWidth - elemWidth, top = targetOffset.top - position.top, bottom = top + targetHeight - elemHeight, feedback = {
              target: {
                element: target,
                left: targetOffset.left,
                top: targetOffset.top,
                width: targetWidth,
                height: targetHeight
              },
              element: {
                element: elem,
                left: position.left,
                top: position.top,
                width: elemWidth,
                height: elemHeight
              },
              horizontal: right < 0 ? 'left' : left > 0 ? 'right' : 'center',
              vertical: bottom < 0 ? 'top' : top > 0 ? 'bottom' : 'middle'
            };
          if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
            feedback.horizontal = 'center';
          }
          if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
            feedback.vertical = 'middle';
          }
          if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
            feedback.important = 'horizontal';
          } else {
            feedback.important = 'vertical';
          }
          options.using.call(this, props, feedback);
        };
      }
      elem.offset($.extend(position, { using: using }));
    });
  };
  $.ui.position = {
    fit: {
      left: function (position, data) {
        var within = data.within, withinOffset = within.isWindow ? within.scrollLeft : within.offset.left, outerWidth = within.width, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = withinOffset - collisionPosLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset, newOverRight;
        // element is wider than within
        if (data.collisionWidth > outerWidth) {
          // element is initially over the left side of within
          if (overLeft > 0 && overRight <= 0) {
            newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
            position.left += overLeft - newOverRight;  // element is initially over right side of within
          } else if (overRight > 0 && overLeft <= 0) {
            position.left = withinOffset;  // element is initially over both left and right sides of within
          } else {
            if (overLeft > overRight) {
              position.left = withinOffset + outerWidth - data.collisionWidth;
            } else {
              position.left = withinOffset;
            }
          }  // too far left -> align with left edge
        } else if (overLeft > 0) {
          position.left += overLeft;  // too far right -> align with right edge
        } else if (overRight > 0) {
          position.left -= overRight;  // adjust based on position and margin
        } else {
          position.left = max(position.left - collisionPosLeft, position.left);
        }
      },
      top: function (position, data) {
        var within = data.within, withinOffset = within.isWindow ? within.scrollTop : within.offset.top, outerHeight = data.within.height, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = withinOffset - collisionPosTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset, newOverBottom;
        // element is taller than within
        if (data.collisionHeight > outerHeight) {
          // element is initially over the top of within
          if (overTop > 0 && overBottom <= 0) {
            newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
            position.top += overTop - newOverBottom;  // element is initially over bottom of within
          } else if (overBottom > 0 && overTop <= 0) {
            position.top = withinOffset;  // element is initially over both top and bottom of within
          } else {
            if (overTop > overBottom) {
              position.top = withinOffset + outerHeight - data.collisionHeight;
            } else {
              position.top = withinOffset;
            }
          }  // too far up -> align with top
        } else if (overTop > 0) {
          position.top += overTop;  // too far down -> align with bottom edge
        } else if (overBottom > 0) {
          position.top -= overBottom;  // adjust based on position and margin
        } else {
          position.top = max(position.top - collisionPosTop, position.top);
        }
      }
    },
    flip: {
      left: function (position, data) {
        var within = data.within, withinOffset = within.offset.left + within.scrollLeft, outerWidth = within.width, offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left, collisionPosLeft = position.left - data.collisionPosition.marginLeft, overLeft = collisionPosLeft - offsetLeft, overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft, myOffset = data.my[0] === 'left' ? -data.elemWidth : data.my[0] === 'right' ? data.elemWidth : 0, atOffset = data.at[0] === 'left' ? data.targetWidth : data.at[0] === 'right' ? -data.targetWidth : 0, offset = -2 * data.offset[0], newOverRight, newOverLeft;
        if (overLeft < 0) {
          newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
          if (newOverRight < 0 || newOverRight < abs(overLeft)) {
            position.left += myOffset + atOffset + offset;
          }
        } else if (overRight > 0) {
          newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
          if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
            position.left += myOffset + atOffset + offset;
          }
        }
      },
      top: function (position, data) {
        var within = data.within, withinOffset = within.offset.top + within.scrollTop, outerHeight = within.height, offsetTop = within.isWindow ? within.scrollTop : within.offset.top, collisionPosTop = position.top - data.collisionPosition.marginTop, overTop = collisionPosTop - offsetTop, overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop, top = data.my[1] === 'top', myOffset = top ? -data.elemHeight : data.my[1] === 'bottom' ? data.elemHeight : 0, atOffset = data.at[1] === 'top' ? data.targetHeight : data.at[1] === 'bottom' ? -data.targetHeight : 0, offset = -2 * data.offset[1], newOverTop, newOverBottom;
        if (overTop < 0) {
          newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
          if (position.top + myOffset + atOffset + offset > overTop && (newOverBottom < 0 || newOverBottom < abs(overTop))) {
            position.top += myOffset + atOffset + offset;
          }
        } else if (overBottom > 0) {
          newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
          if (position.top + myOffset + atOffset + offset > overBottom && (newOverTop > 0 || abs(newOverTop) < overBottom)) {
            position.top += myOffset + atOffset + offset;
          }
        }
      }
    },
    flipfit: {
      left: function () {
        $.ui.position.flip.left.apply(this, arguments);
        $.ui.position.fit.left.apply(this, arguments);
      },
      top: function () {
        $.ui.position.flip.top.apply(this, arguments);
        $.ui.position.fit.top.apply(this, arguments);
      }
    }
  };
  // fraction support test
  (function () {
    var testElement, testElementParent, testElementStyle, offsetLeft, i, body = document.getElementsByTagName('body')[0], div = document.createElement('div');
    //Create a "fake body" for testing based on method used in jQuery.support
    testElement = document.createElement(body ? 'div' : 'body');
    testElementStyle = {
      visibility: 'hidden',
      width: 0,
      height: 0,
      border: 0,
      margin: 0,
      background: 'none'
    };
    if (body) {
      $.extend(testElementStyle, {
        position: 'absolute',
        left: '-1000px',
        top: '-1000px'
      });
    }
    for (i in testElementStyle) {
      testElement.style[i] = testElementStyle[i];
    }
    testElement.appendChild(div);
    testElementParent = body || document.documentElement;
    testElementParent.insertBefore(testElement, testElementParent.firstChild);
    div.style.cssText = 'position: absolute; left: 10.7432222px;';
    offsetLeft = $(div).offset().left;
    $.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;
    testElement.innerHTML = '';
    testElementParent.removeChild(testElement);
  }());
}(jQuery));
(function ($, undefined) {
  $.widget('ui.progressbar', {
    version: '1.10.3',
    options: {
      max: 100,
      value: 0,
      change: null,
      complete: null
    },
    min: 0,
    _create: function () {
      // Constrain initial value
      this.oldValue = this.options.value = this._constrainedValue();
      this.element.addClass('ui-progressbar ui-widget ui-widget-content ui-corner-all').attr({
        role: 'progressbar',
        'aria-valuemin': this.min
      });
      this.valueDiv = $('<div class=\'ui-progressbar-value ui-widget-header ui-corner-left\'></div>').appendTo(this.element);
      this._refreshValue();
    },
    _destroy: function () {
      this.element.removeClass('ui-progressbar ui-widget ui-widget-content ui-corner-all').removeAttr('role').removeAttr('aria-valuemin').removeAttr('aria-valuemax').removeAttr('aria-valuenow');
      this.valueDiv.remove();
    },
    value: function (newValue) {
      if (newValue === undefined) {
        return this.options.value;
      }
      this.options.value = this._constrainedValue(newValue);
      this._refreshValue();
    },
    _constrainedValue: function (newValue) {
      if (newValue === undefined) {
        newValue = this.options.value;
      }
      this.indeterminate = newValue === false;
      // sanitize value
      if (typeof newValue !== 'number') {
        newValue = 0;
      }
      return this.indeterminate ? false : Math.min(this.options.max, Math.max(this.min, newValue));
    },
    _setOptions: function (options) {
      // Ensure "value" option is set after other values (like max)
      var value = options.value;
      delete options.value;
      this._super(options);
      this.options.value = this._constrainedValue(value);
      this._refreshValue();
    },
    _setOption: function (key, value) {
      if (key === 'max') {
        // Don't allow a max less than min
        value = Math.max(this.min, value);
      }
      this._super(key, value);
    },
    _percentage: function () {
      return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min);
    },
    _refreshValue: function () {
      var value = this.options.value, percentage = this._percentage();
      this.valueDiv.toggle(this.indeterminate || value > this.min).toggleClass('ui-corner-right', value === this.options.max).width(percentage.toFixed(0) + '%');
      this.element.toggleClass('ui-progressbar-indeterminate', this.indeterminate);
      if (this.indeterminate) {
        this.element.removeAttr('aria-valuenow');
        if (!this.overlayDiv) {
          this.overlayDiv = $('<div class=\'ui-progressbar-overlay\'></div>').appendTo(this.valueDiv);
        }
      } else {
        this.element.attr({
          'aria-valuemax': this.options.max,
          'aria-valuenow': value
        });
        if (this.overlayDiv) {
          this.overlayDiv.remove();
          this.overlayDiv = null;
        }
      }
      if (this.oldValue !== value) {
        this.oldValue = value;
        this._trigger('change');
      }
      if (value === this.options.max) {
        this._trigger('complete');
      }
    }
  });
}(jQuery));
(function ($, undefined) {
  // number of pages in a slider
  // (how many times can you page up/down to go through the whole range)
  var numPages = 5;
  $.widget('ui.slider', $.ui.mouse, {
    version: '1.10.3',
    widgetEventPrefix: 'slide',
    options: {
      animate: false,
      distance: 0,
      max: 100,
      min: 0,
      orientation: 'horizontal',
      range: false,
      step: 1,
      value: 0,
      values: null,
      change: null,
      slide: null,
      start: null,
      stop: null
    },
    _create: function () {
      this._keySliding = false;
      this._mouseSliding = false;
      this._animateOff = true;
      this._handleIndex = null;
      this._detectOrientation();
      this._mouseInit();
      this.element.addClass('ui-slider' + ' ui-slider-' + this.orientation + ' ui-widget' + ' ui-widget-content' + ' ui-corner-all');
      this._refresh();
      this._setOption('disabled', this.options.disabled);
      this._animateOff = false;
    },
    _refresh: function () {
      this._createRange();
      this._createHandles();
      this._setupEvents();
      this._refreshValue();
    },
    _createHandles: function () {
      var i, handleCount, options = this.options, existingHandles = this.element.find('.ui-slider-handle').addClass('ui-state-default ui-corner-all'), handle = '<a class=\'ui-slider-handle ui-state-default ui-corner-all\' href=\'#\'></a>', handles = [];
      handleCount = options.values && options.values.length || 1;
      if (existingHandles.length > handleCount) {
        existingHandles.slice(handleCount).remove();
        existingHandles = existingHandles.slice(0, handleCount);
      }
      for (i = existingHandles.length; i < handleCount; i++) {
        handles.push(handle);
      }
      this.handles = existingHandles.add($(handles.join('')).appendTo(this.element));
      this.handle = this.handles.eq(0);
      this.handles.each(function (i) {
        $(this).data('ui-slider-handle-index', i);
      });
    },
    _createRange: function () {
      var options = this.options, classes = '';
      if (options.range) {
        if (options.range === true) {
          if (!options.values) {
            options.values = [
              this._valueMin(),
              this._valueMin()
            ];
          } else if (options.values.length && options.values.length !== 2) {
            options.values = [
              options.values[0],
              options.values[0]
            ];
          } else if ($.isArray(options.values)) {
            options.values = options.values.slice(0);
          }
        }
        if (!this.range || !this.range.length) {
          this.range = $('<div></div>').appendTo(this.element);
          classes = 'ui-slider-range' + ' ui-widget-header ui-corner-all';
        } else {
          this.range.removeClass('ui-slider-range-min ui-slider-range-max').css({
            'left': '',
            'bottom': ''
          });
        }
        this.range.addClass(classes + (options.range === 'min' || options.range === 'max' ? ' ui-slider-range-' + options.range : ''));
      } else {
        this.range = $([]);
      }
    },
    _setupEvents: function () {
      var elements = this.handles.add(this.range).filter('a');
      this._off(elements);
      this._on(elements, this._handleEvents);
      this._hoverable(elements);
      this._focusable(elements);
    },
    _destroy: function () {
      this.handles.remove();
      this.range.remove();
      this.element.removeClass('ui-slider' + ' ui-slider-horizontal' + ' ui-slider-vertical' + ' ui-widget' + ' ui-widget-content' + ' ui-corner-all');
      this._mouseDestroy();
    },
    _mouseCapture: function (event) {
      var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle, that = this, o = this.options;
      if (o.disabled) {
        return false;
      }
      this.elementSize = {
        width: this.element.outerWidth(),
        height: this.element.outerHeight()
      };
      this.elementOffset = this.element.offset();
      position = {
        x: event.pageX,
        y: event.pageY
      };
      normValue = this._normValueFromMouse(position);
      distance = this._valueMax() - this._valueMin() + 1;
      this.handles.each(function (i) {
        var thisDistance = Math.abs(normValue - that.values(i));
        if (distance > thisDistance || distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min)) {
          distance = thisDistance;
          closestHandle = $(this);
          index = i;
        }
      });
      allowed = this._start(event, index);
      if (allowed === false) {
        return false;
      }
      this._mouseSliding = true;
      this._handleIndex = index;
      closestHandle.addClass('ui-state-active').focus();
      offset = closestHandle.offset();
      mouseOverHandle = !$(event.target).parents().addBack().is('.ui-slider-handle');
      this._clickOffset = mouseOverHandle ? {
        left: 0,
        top: 0
      } : {
        left: event.pageX - offset.left - closestHandle.width() / 2,
        top: event.pageY - offset.top - closestHandle.height() / 2 - (parseInt(closestHandle.css('borderTopWidth'), 10) || 0) - (parseInt(closestHandle.css('borderBottomWidth'), 10) || 0) + (parseInt(closestHandle.css('marginTop'), 10) || 0)
      };
      if (!this.handles.hasClass('ui-state-hover')) {
        this._slide(event, index, normValue);
      }
      this._animateOff = true;
      return true;
    },
    _mouseStart: function () {
      return true;
    },
    _mouseDrag: function (event) {
      var position = {
          x: event.pageX,
          y: event.pageY
        }, normValue = this._normValueFromMouse(position);
      this._slide(event, this._handleIndex, normValue);
      return false;
    },
    _mouseStop: function (event) {
      this.handles.removeClass('ui-state-active');
      this._mouseSliding = false;
      this._stop(event, this._handleIndex);
      this._change(event, this._handleIndex);
      this._handleIndex = null;
      this._clickOffset = null;
      this._animateOff = false;
      return false;
    },
    _detectOrientation: function () {
      this.orientation = this.options.orientation === 'vertical' ? 'vertical' : 'horizontal';
    },
    _normValueFromMouse: function (position) {
      var pixelTotal, pixelMouse, percentMouse, valueTotal, valueMouse;
      if (this.orientation === 'horizontal') {
        pixelTotal = this.elementSize.width;
        pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);
      } else {
        pixelTotal = this.elementSize.height;
        pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);
      }
      percentMouse = pixelMouse / pixelTotal;
      if (percentMouse > 1) {
        percentMouse = 1;
      }
      if (percentMouse < 0) {
        percentMouse = 0;
      }
      if (this.orientation === 'vertical') {
        percentMouse = 1 - percentMouse;
      }
      valueTotal = this._valueMax() - this._valueMin();
      valueMouse = this._valueMin() + percentMouse * valueTotal;
      return this._trimAlignValue(valueMouse);
    },
    _start: function (event, index) {
      var uiHash = {
          handle: this.handles[index],
          value: this.value()
        };
      if (this.options.values && this.options.values.length) {
        uiHash.value = this.values(index);
        uiHash.values = this.values();
      }
      return this._trigger('start', event, uiHash);
    },
    _slide: function (event, index, newVal) {
      var otherVal, newValues, allowed;
      if (this.options.values && this.options.values.length) {
        otherVal = this.values(index ? 0 : 1);
        if (this.options.values.length === 2 && this.options.range === true && (index === 0 && newVal > otherVal || index === 1 && newVal < otherVal)) {
          newVal = otherVal;
        }
        if (newVal !== this.values(index)) {
          newValues = this.values();
          newValues[index] = newVal;
          // A slide can be canceled by returning false from the slide callback
          allowed = this._trigger('slide', event, {
            handle: this.handles[index],
            value: newVal,
            values: newValues
          });
          otherVal = this.values(index ? 0 : 1);
          if (allowed !== false) {
            this.values(index, newVal, true);
          }
        }
      } else {
        if (newVal !== this.value()) {
          // A slide can be canceled by returning false from the slide callback
          allowed = this._trigger('slide', event, {
            handle: this.handles[index],
            value: newVal
          });
          if (allowed !== false) {
            this.value(newVal);
          }
        }
      }
    },
    _stop: function (event, index) {
      var uiHash = {
          handle: this.handles[index],
          value: this.value()
        };
      if (this.options.values && this.options.values.length) {
        uiHash.value = this.values(index);
        uiHash.values = this.values();
      }
      this._trigger('stop', event, uiHash);
    },
    _change: function (event, index) {
      if (!this._keySliding && !this._mouseSliding) {
        var uiHash = {
            handle: this.handles[index],
            value: this.value()
          };
        if (this.options.values && this.options.values.length) {
          uiHash.value = this.values(index);
          uiHash.values = this.values();
        }
        //store the last changed value index for reference when handles overlap
        this._lastChangedValue = index;
        this._trigger('change', event, uiHash);
      }
    },
    value: function (newValue) {
      if (arguments.length) {
        this.options.value = this._trimAlignValue(newValue);
        this._refreshValue();
        this._change(null, 0);
        return;
      }
      return this._value();
    },
    values: function (index, newValue) {
      var vals, newValues, i;
      if (arguments.length > 1) {
        this.options.values[index] = this._trimAlignValue(newValue);
        this._refreshValue();
        this._change(null, index);
        return;
      }
      if (arguments.length) {
        if ($.isArray(arguments[0])) {
          vals = this.options.values;
          newValues = arguments[0];
          for (i = 0; i < vals.length; i += 1) {
            vals[i] = this._trimAlignValue(newValues[i]);
            this._change(null, i);
          }
          this._refreshValue();
        } else {
          if (this.options.values && this.options.values.length) {
            return this._values(index);
          } else {
            return this.value();
          }
        }
      } else {
        return this._values();
      }
    },
    _setOption: function (key, value) {
      var i, valsLength = 0;
      if (key === 'range' && this.options.range === true) {
        if (value === 'min') {
          this.options.value = this._values(0);
          this.options.values = null;
        } else if (value === 'max') {
          this.options.value = this._values(this.options.values.length - 1);
          this.options.values = null;
        }
      }
      if ($.isArray(this.options.values)) {
        valsLength = this.options.values.length;
      }
      $.Widget.prototype._setOption.apply(this, arguments);
      switch (key) {
      case 'orientation':
        this._detectOrientation();
        this.element.removeClass('ui-slider-horizontal ui-slider-vertical').addClass('ui-slider-' + this.orientation);
        this._refreshValue();
        break;
      case 'value':
        this._animateOff = true;
        this._refreshValue();
        this._change(null, 0);
        this._animateOff = false;
        break;
      case 'values':
        this._animateOff = true;
        this._refreshValue();
        for (i = 0; i < valsLength; i += 1) {
          this._change(null, i);
        }
        this._animateOff = false;
        break;
      case 'min':
      case 'max':
        this._animateOff = true;
        this._refreshValue();
        this._animateOff = false;
        break;
      case 'range':
        this._animateOff = true;
        this._refresh();
        this._animateOff = false;
        break;
      }
    },
    _value: function () {
      var val = this.options.value;
      val = this._trimAlignValue(val);
      return val;
    },
    _values: function (index) {
      var val, vals, i;
      if (arguments.length) {
        val = this.options.values[index];
        val = this._trimAlignValue(val);
        return val;
      } else if (this.options.values && this.options.values.length) {
        // .slice() creates a copy of the array
        // this copy gets trimmed by min and max and then returned
        vals = this.options.values.slice();
        for (i = 0; i < vals.length; i += 1) {
          vals[i] = this._trimAlignValue(vals[i]);
        }
        return vals;
      } else {
        return [];
      }
    },
    _trimAlignValue: function (val) {
      if (val <= this._valueMin()) {
        return this._valueMin();
      }
      if (val >= this._valueMax()) {
        return this._valueMax();
      }
      var step = this.options.step > 0 ? this.options.step : 1, valModStep = (val - this._valueMin()) % step, alignValue = val - valModStep;
      if (Math.abs(valModStep) * 2 >= step) {
        alignValue += valModStep > 0 ? step : -step;
      }
      // Since JavaScript has problems with large floats, round
      // the final value to 5 digits after the decimal point (see #4124)
      return parseFloat(alignValue.toFixed(5));
    },
    _valueMin: function () {
      return this.options.min;
    },
    _valueMax: function () {
      return this.options.max;
    },
    _refreshValue: function () {
      var lastValPercent, valPercent, value, valueMin, valueMax, oRange = this.options.range, o = this.options, that = this, animate = !this._animateOff ? o.animate : false, _set = {};
      if (this.options.values && this.options.values.length) {
        this.handles.each(function (i) {
          valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;
          _set[that.orientation === 'horizontal' ? 'left' : 'bottom'] = valPercent + '%';
          $(this).stop(1, 1)[animate ? 'animate' : 'css'](_set, o.animate);
          if (that.options.range === true) {
            if (that.orientation === 'horizontal') {
              if (i === 0) {
                that.range.stop(1, 1)[animate ? 'animate' : 'css']({ left: valPercent + '%' }, o.animate);
              }
              if (i === 1) {
                that.range[animate ? 'animate' : 'css']({ width: valPercent - lastValPercent + '%' }, {
                  queue: false,
                  duration: o.animate
                });
              }
            } else {
              if (i === 0) {
                that.range.stop(1, 1)[animate ? 'animate' : 'css']({ bottom: valPercent + '%' }, o.animate);
              }
              if (i === 1) {
                that.range[animate ? 'animate' : 'css']({ height: valPercent - lastValPercent + '%' }, {
                  queue: false,
                  duration: o.animate
                });
              }
            }
          }
          lastValPercent = valPercent;
        });
      } else {
        value = this.value();
        valueMin = this._valueMin();
        valueMax = this._valueMax();
        valPercent = valueMax !== valueMin ? (value - valueMin) / (valueMax - valueMin) * 100 : 0;
        _set[this.orientation === 'horizontal' ? 'left' : 'bottom'] = valPercent + '%';
        this.handle.stop(1, 1)[animate ? 'animate' : 'css'](_set, o.animate);
        if (oRange === 'min' && this.orientation === 'horizontal') {
          this.range.stop(1, 1)[animate ? 'animate' : 'css']({ width: valPercent + '%' }, o.animate);
        }
        if (oRange === 'max' && this.orientation === 'horizontal') {
          this.range[animate ? 'animate' : 'css']({ width: 100 - valPercent + '%' }, {
            queue: false,
            duration: o.animate
          });
        }
        if (oRange === 'min' && this.orientation === 'vertical') {
          this.range.stop(1, 1)[animate ? 'animate' : 'css']({ height: valPercent + '%' }, o.animate);
        }
        if (oRange === 'max' && this.orientation === 'vertical') {
          this.range[animate ? 'animate' : 'css']({ height: 100 - valPercent + '%' }, {
            queue: false,
            duration: o.animate
          });
        }
      }
    },
    _handleEvents: {
      keydown: function (event) {
        /*jshint maxcomplexity:25*/
        var allowed, curVal, newVal, step, index = $(event.target).data('ui-slider-handle-index');
        switch (event.keyCode) {
        case $.ui.keyCode.HOME:
        case $.ui.keyCode.END:
        case $.ui.keyCode.PAGE_UP:
        case $.ui.keyCode.PAGE_DOWN:
        case $.ui.keyCode.UP:
        case $.ui.keyCode.RIGHT:
        case $.ui.keyCode.DOWN:
        case $.ui.keyCode.LEFT:
          event.preventDefault();
          if (!this._keySliding) {
            this._keySliding = true;
            $(event.target).addClass('ui-state-active');
            allowed = this._start(event, index);
            if (allowed === false) {
              return;
            }
          }
          break;
        }
        step = this.options.step;
        if (this.options.values && this.options.values.length) {
          curVal = newVal = this.values(index);
        } else {
          curVal = newVal = this.value();
        }
        switch (event.keyCode) {
        case $.ui.keyCode.HOME:
          newVal = this._valueMin();
          break;
        case $.ui.keyCode.END:
          newVal = this._valueMax();
          break;
        case $.ui.keyCode.PAGE_UP:
          newVal = this._trimAlignValue(curVal + (this._valueMax() - this._valueMin()) / numPages);
          break;
        case $.ui.keyCode.PAGE_DOWN:
          newVal = this._trimAlignValue(curVal - (this._valueMax() - this._valueMin()) / numPages);
          break;
        case $.ui.keyCode.UP:
        case $.ui.keyCode.RIGHT:
          if (curVal === this._valueMax()) {
            return;
          }
          newVal = this._trimAlignValue(curVal + step);
          break;
        case $.ui.keyCode.DOWN:
        case $.ui.keyCode.LEFT:
          if (curVal === this._valueMin()) {
            return;
          }
          newVal = this._trimAlignValue(curVal - step);
          break;
        }
        this._slide(event, index, newVal);
      },
      click: function (event) {
        event.preventDefault();
      },
      keyup: function (event) {
        var index = $(event.target).data('ui-slider-handle-index');
        if (this._keySliding) {
          this._keySliding = false;
          this._stop(event, index);
          this._change(event, index);
          $(event.target).removeClass('ui-state-active');
        }
      }
    }
  });
}(jQuery));
(function ($) {
  function modifier(fn) {
    return function () {
      var previous = this.element.val();
      fn.apply(this, arguments);
      this._refresh();
      if (previous !== this.element.val()) {
        this._trigger('change');
      }
    };
  }
  $.widget('ui.spinner', {
    version: '1.10.3',
    defaultElement: '<input>',
    widgetEventPrefix: 'spin',
    options: {
      culture: null,
      icons: {
        down: 'ui-icon-triangle-1-s',
        up: 'ui-icon-triangle-1-n'
      },
      incremental: true,
      max: null,
      min: null,
      numberFormat: null,
      page: 10,
      step: 1,
      change: null,
      spin: null,
      start: null,
      stop: null
    },
    _create: function () {
      // handle string values that need to be parsed
      this._setOption('max', this.options.max);
      this._setOption('min', this.options.min);
      this._setOption('step', this.options.step);
      // format the value, but don't constrain
      this._value(this.element.val(), true);
      this._draw();
      this._on(this._events);
      this._refresh();
      // turning off autocomplete prevents the browser from remembering the
      // value when navigating through history, so we re-enable autocomplete
      // if the page is unloaded before the widget is destroyed. #7790
      this._on(this.window, {
        beforeunload: function () {
          this.element.removeAttr('autocomplete');
        }
      });
    },
    _getCreateOptions: function () {
      var options = {}, element = this.element;
      $.each([
        'min',
        'max',
        'step'
      ], function (i, option) {
        var value = element.attr(option);
        if (value !== undefined && value.length) {
          options[option] = value;
        }
      });
      return options;
    },
    _events: {
      keydown: function (event) {
        if (this._start(event) && this._keydown(event)) {
          event.preventDefault();
        }
      },
      keyup: '_stop',
      focus: function () {
        this.previous = this.element.val();
      },
      blur: function (event) {
        if (this.cancelBlur) {
          delete this.cancelBlur;
          return;
        }
        this._stop();
        this._refresh();
        if (this.previous !== this.element.val()) {
          this._trigger('change', event);
        }
      },
      mousewheel: function (event, delta) {
        if (!delta) {
          return;
        }
        if (!this.spinning && !this._start(event)) {
          return false;
        }
        this._spin((delta > 0 ? 1 : -1) * this.options.step, event);
        clearTimeout(this.mousewheelTimer);
        this.mousewheelTimer = this._delay(function () {
          if (this.spinning) {
            this._stop(event);
          }
        }, 100);
        event.preventDefault();
      },
      'mousedown .ui-spinner-button': function (event) {
        var previous;
        // We never want the buttons to have focus; whenever the user is
        // interacting with the spinner, the focus should be on the input.
        // If the input is focused then this.previous is properly set from
        // when the input first received focus. If the input is not focused
        // then we need to set this.previous based on the value before spinning.
        previous = this.element[0] === this.document[0].activeElement ? this.previous : this.element.val();
        function checkFocus() {
          var isActive = this.element[0] === this.document[0].activeElement;
          if (!isActive) {
            this.element.focus();
            this.previous = previous;
            // support: IE
            // IE sets focus asynchronously, so we need to check if focus
            // moved off of the input because the user clicked on the button.
            this._delay(function () {
              this.previous = previous;
            });
          }
        }
        // ensure focus is on (or stays on) the text field
        event.preventDefault();
        checkFocus.call(this);
        // support: IE
        // IE doesn't prevent moving focus even with event.preventDefault()
        // so we set a flag to know when we should ignore the blur event
        // and check (again) if focus moved off of the input.
        this.cancelBlur = true;
        this._delay(function () {
          delete this.cancelBlur;
          checkFocus.call(this);
        });
        if (this._start(event) === false) {
          return;
        }
        this._repeat(null, $(event.currentTarget).hasClass('ui-spinner-up') ? 1 : -1, event);
      },
      'mouseup .ui-spinner-button': '_stop',
      'mouseenter .ui-spinner-button': function (event) {
        // button will add ui-state-active if mouse was down while mouseleave and kept down
        if (!$(event.currentTarget).hasClass('ui-state-active')) {
          return;
        }
        if (this._start(event) === false) {
          return false;
        }
        this._repeat(null, $(event.currentTarget).hasClass('ui-spinner-up') ? 1 : -1, event);
      },
      'mouseleave .ui-spinner-button': '_stop'
    },
    _draw: function () {
      var uiSpinner = this.uiSpinner = this.element.addClass('ui-spinner-input').attr('autocomplete', 'off').wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());
      this.element.attr('role', 'spinbutton');
      // button bindings
      this.buttons = uiSpinner.find('.ui-spinner-button').attr('tabIndex', -1).button().removeClass('ui-corner-all');
      // IE 6 doesn't understand height: 50% for the buttons
      // unless the wrapper has an explicit height
      if (this.buttons.height() > Math.ceil(uiSpinner.height() * 0.5) && uiSpinner.height() > 0) {
        uiSpinner.height(uiSpinner.height());
      }
      // disable spinner if element was already disabled
      if (this.options.disabled) {
        this.disable();
      }
    },
    _keydown: function (event) {
      var options = this.options, keyCode = $.ui.keyCode;
      switch (event.keyCode) {
      case keyCode.UP:
        this._repeat(null, 1, event);
        return true;
      case keyCode.DOWN:
        this._repeat(null, -1, event);
        return true;
      case keyCode.PAGE_UP:
        this._repeat(null, options.page, event);
        return true;
      case keyCode.PAGE_DOWN:
        this._repeat(null, -options.page, event);
        return true;
      }
      return false;
    },
    _uiSpinnerHtml: function () {
      return '<span class=\'ui-spinner ui-widget ui-widget-content ui-corner-all\'></span>';
    },
    _buttonHtml: function () {
      return '' + '<a class=\'ui-spinner-button ui-spinner-up ui-corner-tr\'>' + '<span class=\'ui-icon ' + this.options.icons.up + '\'>&#9650;</span>' + '</a>' + '<a class=\'ui-spinner-button ui-spinner-down ui-corner-br\'>' + '<span class=\'ui-icon ' + this.options.icons.down + '\'>&#9660;</span>' + '</a>';
    },
    _start: function (event) {
      if (!this.spinning && this._trigger('start', event) === false) {
        return false;
      }
      if (!this.counter) {
        this.counter = 1;
      }
      this.spinning = true;
      return true;
    },
    _repeat: function (i, steps, event) {
      i = i || 500;
      clearTimeout(this.timer);
      this.timer = this._delay(function () {
        this._repeat(40, steps, event);
      }, i);
      this._spin(steps * this.options.step, event);
    },
    _spin: function (step, event) {
      var value = this.value() || 0;
      if (!this.counter) {
        this.counter = 1;
      }
      value = this._adjustValue(value + step * this._increment(this.counter));
      if (!this.spinning || this._trigger('spin', event, { value: value }) !== false) {
        this._value(value);
        this.counter++;
      }
    },
    _increment: function (i) {
      var incremental = this.options.incremental;
      if (incremental) {
        return $.isFunction(incremental) ? incremental(i) : Math.floor(i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1);
      }
      return 1;
    },
    _precision: function () {
      var precision = this._precisionOf(this.options.step);
      if (this.options.min !== null) {
        precision = Math.max(precision, this._precisionOf(this.options.min));
      }
      return precision;
    },
    _precisionOf: function (num) {
      var str = num.toString(), decimal = str.indexOf('.');
      return decimal === -1 ? 0 : str.length - decimal - 1;
    },
    _adjustValue: function (value) {
      var base, aboveMin, options = this.options;
      // make sure we're at a valid step
      // - find out where we are relative to the base (min or 0)
      base = options.min !== null ? options.min : 0;
      aboveMin = value - base;
      // - round to the nearest step
      aboveMin = Math.round(aboveMin / options.step) * options.step;
      // - rounding is based on 0, so adjust back to our base
      value = base + aboveMin;
      // fix precision from bad JS floating point math
      value = parseFloat(value.toFixed(this._precision()));
      // clamp the value
      if (options.max !== null && value > options.max) {
        return options.max;
      }
      if (options.min !== null && value < options.min) {
        return options.min;
      }
      return value;
    },
    _stop: function (event) {
      if (!this.spinning) {
        return;
      }
      clearTimeout(this.timer);
      clearTimeout(this.mousewheelTimer);
      this.counter = 0;
      this.spinning = false;
      this._trigger('stop', event);
    },
    _setOption: function (key, value) {
      if (key === 'culture' || key === 'numberFormat') {
        var prevValue = this._parse(this.element.val());
        this.options[key] = value;
        this.element.val(this._format(prevValue));
        return;
      }
      if (key === 'max' || key === 'min' || key === 'step') {
        if (typeof value === 'string') {
          value = this._parse(value);
        }
      }
      if (key === 'icons') {
        this.buttons.first().find('.ui-icon').removeClass(this.options.icons.up).addClass(value.up);
        this.buttons.last().find('.ui-icon').removeClass(this.options.icons.down).addClass(value.down);
      }
      this._super(key, value);
      if (key === 'disabled') {
        if (value) {
          this.element.prop('disabled', true);
          this.buttons.button('disable');
        } else {
          this.element.prop('disabled', false);
          this.buttons.button('enable');
        }
      }
    },
    _setOptions: modifier(function (options) {
      this._super(options);
      this._value(this.element.val());
    }),
    _parse: function (val) {
      if (typeof val === 'string' && val !== '') {
        val = window.Globalize && this.options.numberFormat ? Globalize.parseFloat(val, 10, this.options.culture) : +val;
      }
      return val === '' || isNaN(val) ? null : val;
    },
    _format: function (value) {
      if (value === '') {
        return '';
      }
      return window.Globalize && this.options.numberFormat ? Globalize.format(value, this.options.numberFormat, this.options.culture) : value;
    },
    _refresh: function () {
      this.element.attr({
        'aria-valuemin': this.options.min,
        'aria-valuemax': this.options.max,
        'aria-valuenow': this._parse(this.element.val())
      });
    },
    _value: function (value, allowAny) {
      var parsed;
      if (value !== '') {
        parsed = this._parse(value);
        if (parsed !== null) {
          if (!allowAny) {
            parsed = this._adjustValue(parsed);
          }
          value = this._format(parsed);
        }
      }
      this.element.val(value);
      this._refresh();
    },
    _destroy: function () {
      this.element.removeClass('ui-spinner-input').prop('disabled', false).removeAttr('autocomplete').removeAttr('role').removeAttr('aria-valuemin').removeAttr('aria-valuemax').removeAttr('aria-valuenow');
      this.uiSpinner.replaceWith(this.element);
    },
    stepUp: modifier(function (steps) {
      this._stepUp(steps);
    }),
    _stepUp: function (steps) {
      if (this._start()) {
        this._spin((steps || 1) * this.options.step);
        this._stop();
      }
    },
    stepDown: modifier(function (steps) {
      this._stepDown(steps);
    }),
    _stepDown: function (steps) {
      if (this._start()) {
        this._spin((steps || 1) * -this.options.step);
        this._stop();
      }
    },
    pageUp: modifier(function (pages) {
      this._stepUp((pages || 1) * this.options.page);
    }),
    pageDown: modifier(function (pages) {
      this._stepDown((pages || 1) * this.options.page);
    }),
    value: function (newVal) {
      if (!arguments.length) {
        return this._parse(this.element.val());
      }
      modifier(this._value).call(this, newVal);
    },
    widget: function () {
      return this.uiSpinner;
    }
  });
}(jQuery));
(function ($, undefined) {
  var tabId = 0, rhash = /#.*$/;
  function getNextTabId() {
    return ++tabId;
  }
  function isLocal(anchor) {
    return anchor.hash.length > 1 && decodeURIComponent(anchor.href.replace(rhash, '')) === decodeURIComponent(location.href.replace(rhash, ''));
  }
  $.widget('ui.tabs', {
    version: '1.10.3',
    delay: 300,
    options: {
      active: null,
      collapsible: false,
      event: 'click',
      heightStyle: 'content',
      hide: null,
      show: null,
      activate: null,
      beforeActivate: null,
      beforeLoad: null,
      load: null
    },
    _create: function () {
      var that = this, options = this.options;
      this.running = false;
      this.element.addClass('ui-tabs ui-widget ui-widget-content ui-corner-all').toggleClass('ui-tabs-collapsible', options.collapsible).delegate('.ui-tabs-nav > li', 'mousedown' + this.eventNamespace, function (event) {
        if ($(this).is('.ui-state-disabled')) {
          event.preventDefault();
        }
      }).delegate('.ui-tabs-anchor', 'focus' + this.eventNamespace, function () {
        if ($(this).closest('li').is('.ui-state-disabled')) {
          this.blur();
        }
      });
      this._processTabs();
      options.active = this._initialActive();
      // Take disabling tabs via class attribute from HTML
      // into account and update option properly.
      if ($.isArray(options.disabled)) {
        options.disabled = $.unique(options.disabled.concat($.map(this.tabs.filter('.ui-state-disabled'), function (li) {
          return that.tabs.index(li);
        }))).sort();
      }
      // check for length avoids error when initializing empty list
      if (this.options.active !== false && this.anchors.length) {
        this.active = this._findActive(options.active);
      } else {
        this.active = $();
      }
      this._refresh();
      if (this.active.length) {
        this.load(options.active);
      }
    },
    _initialActive: function () {
      var active = this.options.active, collapsible = this.options.collapsible, locationHash = location.hash.substring(1);
      if (active === null) {
        // check the fragment identifier in the URL
        if (locationHash) {
          this.tabs.each(function (i, tab) {
            if ($(tab).attr('aria-controls') === locationHash) {
              active = i;
              return false;
            }
          });
        }
        // check for a tab marked active via a class
        if (active === null) {
          active = this.tabs.index(this.tabs.filter('.ui-tabs-active'));
        }
        // no active tab, set to false
        if (active === null || active === -1) {
          active = this.tabs.length ? 0 : false;
        }
      }
      // handle numbers: negative, out of range
      if (active !== false) {
        active = this.tabs.index(this.tabs.eq(active));
        if (active === -1) {
          active = collapsible ? false : 0;
        }
      }
      // don't allow collapsible: false and active: false
      if (!collapsible && active === false && this.anchors.length) {
        active = 0;
      }
      return active;
    },
    _getCreateEventData: function () {
      return {
        tab: this.active,
        panel: !this.active.length ? $() : this._getPanelForTab(this.active)
      };
    },
    _tabKeydown: function (event) {
      /*jshint maxcomplexity:15*/
      var focusedTab = $(this.document[0].activeElement).closest('li'), selectedIndex = this.tabs.index(focusedTab), goingForward = true;
      if (this._handlePageNav(event)) {
        return;
      }
      switch (event.keyCode) {
      case $.ui.keyCode.RIGHT:
      case $.ui.keyCode.DOWN:
        selectedIndex++;
        break;
      case $.ui.keyCode.UP:
      case $.ui.keyCode.LEFT:
        goingForward = false;
        selectedIndex--;
        break;
      case $.ui.keyCode.END:
        selectedIndex = this.anchors.length - 1;
        break;
      case $.ui.keyCode.HOME:
        selectedIndex = 0;
        break;
      case $.ui.keyCode.SPACE:
        // Activate only, no collapsing
        event.preventDefault();
        clearTimeout(this.activating);
        this._activate(selectedIndex);
        return;
      case $.ui.keyCode.ENTER:
        // Toggle (cancel delayed activation, allow collapsing)
        event.preventDefault();
        clearTimeout(this.activating);
        // Determine if we should collapse or activate
        this._activate(selectedIndex === this.options.active ? false : selectedIndex);
        return;
      default:
        return;
      }
      // Focus the appropriate tab, based on which key was pressed
      event.preventDefault();
      clearTimeout(this.activating);
      selectedIndex = this._focusNextTab(selectedIndex, goingForward);
      // Navigating with control key will prevent automatic activation
      if (!event.ctrlKey) {
        // Update aria-selected immediately so that AT think the tab is already selected.
        // Otherwise AT may confuse the user by stating that they need to activate the tab,
        // but the tab will already be activated by the time the announcement finishes.
        focusedTab.attr('aria-selected', 'false');
        this.tabs.eq(selectedIndex).attr('aria-selected', 'true');
        this.activating = this._delay(function () {
          this.option('active', selectedIndex);
        }, this.delay);
      }
    },
    _panelKeydown: function (event) {
      if (this._handlePageNav(event)) {
        return;
      }
      // Ctrl+up moves focus to the current tab
      if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {
        event.preventDefault();
        this.active.focus();
      }
    },
    _handlePageNav: function (event) {
      if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {
        this._activate(this._focusNextTab(this.options.active - 1, false));
        return true;
      }
      if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {
        this._activate(this._focusNextTab(this.options.active + 1, true));
        return true;
      }
    },
    _findNextTab: function (index, goingForward) {
      var lastTabIndex = this.tabs.length - 1;
      function constrain() {
        if (index > lastTabIndex) {
          index = 0;
        }
        if (index < 0) {
          index = lastTabIndex;
        }
        return index;
      }
      while ($.inArray(constrain(), this.options.disabled) !== -1) {
        index = goingForward ? index + 1 : index - 1;
      }
      return index;
    },
    _focusNextTab: function (index, goingForward) {
      index = this._findNextTab(index, goingForward);
      this.tabs.eq(index).focus();
      return index;
    },
    _setOption: function (key, value) {
      if (key === 'active') {
        // _activate() will handle invalid values and update this.options
        this._activate(value);
        return;
      }
      if (key === 'disabled') {
        // don't use the widget factory's disabled handling
        this._setupDisabled(value);
        return;
      }
      this._super(key, value);
      if (key === 'collapsible') {
        this.element.toggleClass('ui-tabs-collapsible', value);
        // Setting collapsible: false while collapsed; open first panel
        if (!value && this.options.active === false) {
          this._activate(0);
        }
      }
      if (key === 'event') {
        this._setupEvents(value);
      }
      if (key === 'heightStyle') {
        this._setupHeightStyle(value);
      }
    },
    _tabId: function (tab) {
      return tab.attr('aria-controls') || 'ui-tabs-' + getNextTabId();
    },
    _sanitizeSelector: function (hash) {
      return hash ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, '\\$&') : '';
    },
    refresh: function () {
      var options = this.options, lis = this.tablist.children(':has(a[href])');
      // get disabled tabs from class attribute from HTML
      // this will get converted to a boolean if needed in _refresh()
      options.disabled = $.map(lis.filter('.ui-state-disabled'), function (tab) {
        return lis.index(tab);
      });
      this._processTabs();
      // was collapsed or no tabs
      if (options.active === false || !this.anchors.length) {
        options.active = false;
        this.active = $();  // was active, but active tab is gone
      } else if (this.active.length && !$.contains(this.tablist[0], this.active[0])) {
        // all remaining tabs are disabled
        if (this.tabs.length === options.disabled.length) {
          options.active = false;
          this.active = $();  // activate previous tab
        } else {
          this._activate(this._findNextTab(Math.max(0, options.active - 1), false));
        }  // was active, active tab still exists
      } else {
        // make sure active index is correct
        options.active = this.tabs.index(this.active);
      }
      this._refresh();
    },
    _refresh: function () {
      this._setupDisabled(this.options.disabled);
      this._setupEvents(this.options.event);
      this._setupHeightStyle(this.options.heightStyle);
      this.tabs.not(this.active).attr({
        'aria-selected': 'false',
        tabIndex: -1
      });
      this.panels.not(this._getPanelForTab(this.active)).hide().attr({
        'aria-expanded': 'false',
        'aria-hidden': 'true'
      });
      // Make sure one tab is in the tab order
      if (!this.active.length) {
        this.tabs.eq(0).attr('tabIndex', 0);
      } else {
        this.active.addClass('ui-tabs-active ui-state-active').attr({
          'aria-selected': 'true',
          tabIndex: 0
        });
        this._getPanelForTab(this.active).show().attr({
          'aria-expanded': 'true',
          'aria-hidden': 'false'
        });
      }
    },
    _processTabs: function () {
      var that = this;
      this.tablist = this._getList().addClass('ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all').attr('role', 'tablist');
      this.tabs = this.tablist.find('> li:has(a[href])').addClass('ui-state-default ui-corner-top').attr({
        role: 'tab',
        tabIndex: -1
      });
      this.anchors = this.tabs.map(function () {
        return $('a', this)[0];
      }).addClass('ui-tabs-anchor').attr({
        role: 'presentation',
        tabIndex: -1
      });
      this.panels = $();
      this.anchors.each(function (i, anchor) {
        var selector, panel, panelId, anchorId = $(anchor).uniqueId().attr('id'), tab = $(anchor).closest('li'), originalAriaControls = tab.attr('aria-controls');
        // inline tab
        if (isLocal(anchor)) {
          selector = anchor.hash;
          panel = that.element.find(that._sanitizeSelector(selector));  // remote tab
        } else {
          panelId = that._tabId(tab);
          selector = '#' + panelId;
          panel = that.element.find(selector);
          if (!panel.length) {
            panel = that._createPanel(panelId);
            panel.insertAfter(that.panels[i - 1] || that.tablist);
          }
          panel.attr('aria-live', 'polite');
        }
        if (panel.length) {
          that.panels = that.panels.add(panel);
        }
        if (originalAriaControls) {
          tab.data('ui-tabs-aria-controls', originalAriaControls);
        }
        tab.attr({
          'aria-controls': selector.substring(1),
          'aria-labelledby': anchorId
        });
        panel.attr('aria-labelledby', anchorId);
      });
      this.panels.addClass('ui-tabs-panel ui-widget-content ui-corner-bottom').attr('role', 'tabpanel');
    },
    _getList: function () {
      return this.element.find('ol,ul').eq(0);
    },
    _createPanel: function (id) {
      return $('<div>').attr('id', id).addClass('ui-tabs-panel ui-widget-content ui-corner-bottom').data('ui-tabs-destroy', true);
    },
    _setupDisabled: function (disabled) {
      if ($.isArray(disabled)) {
        if (!disabled.length) {
          disabled = false;
        } else if (disabled.length === this.anchors.length) {
          disabled = true;
        }
      }
      // disable tabs
      for (var i = 0, li; li = this.tabs[i]; i++) {
        if (disabled === true || $.inArray(i, disabled) !== -1) {
          $(li).addClass('ui-state-disabled').attr('aria-disabled', 'true');
        } else {
          $(li).removeClass('ui-state-disabled').removeAttr('aria-disabled');
        }
      }
      this.options.disabled = disabled;
    },
    _setupEvents: function (event) {
      var events = {
          click: function (event) {
            event.preventDefault();
          }
        };
      if (event) {
        $.each(event.split(' '), function (index, eventName) {
          events[eventName] = '_eventHandler';
        });
      }
      this._off(this.anchors.add(this.tabs).add(this.panels));
      this._on(this.anchors, events);
      this._on(this.tabs, { keydown: '_tabKeydown' });
      this._on(this.panels, { keydown: '_panelKeydown' });
      this._focusable(this.tabs);
      this._hoverable(this.tabs);
    },
    _setupHeightStyle: function (heightStyle) {
      var maxHeight, parent = this.element.parent();
      if (heightStyle === 'fill') {
        maxHeight = parent.height();
        maxHeight -= this.element.outerHeight() - this.element.height();
        this.element.siblings(':visible').each(function () {
          var elem = $(this), position = elem.css('position');
          if (position === 'absolute' || position === 'fixed') {
            return;
          }
          maxHeight -= elem.outerHeight(true);
        });
        this.element.children().not(this.panels).each(function () {
          maxHeight -= $(this).outerHeight(true);
        });
        this.panels.each(function () {
          $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
        }).css('overflow', 'auto');
      } else if (heightStyle === 'auto') {
        maxHeight = 0;
        this.panels.each(function () {
          maxHeight = Math.max(maxHeight, $(this).height('').height());
        }).height(maxHeight);
      }
    },
    _eventHandler: function (event) {
      var options = this.options, active = this.active, anchor = $(event.currentTarget), tab = anchor.closest('li'), clickedIsActive = tab[0] === active[0], collapsing = clickedIsActive && options.collapsible, toShow = collapsing ? $() : this._getPanelForTab(tab), toHide = !active.length ? $() : this._getPanelForTab(active), eventData = {
          oldTab: active,
          oldPanel: toHide,
          newTab: collapsing ? $() : tab,
          newPanel: toShow
        };
      event.preventDefault();
      if (tab.hasClass('ui-state-disabled') || tab.hasClass('ui-tabs-loading') || this.running || clickedIsActive && !options.collapsible || this._trigger('beforeActivate', event, eventData) === false) {
        return;
      }
      options.active = collapsing ? false : this.tabs.index(tab);
      this.active = clickedIsActive ? $() : tab;
      if (this.xhr) {
        this.xhr.abort();
      }
      if (!toHide.length && !toShow.length) {
        $.error('jQuery UI Tabs: Mismatching fragment identifier.');
      }
      if (toShow.length) {
        this.load(this.tabs.index(tab), event);
      }
      this._toggle(event, eventData);
    },
    _toggle: function (event, eventData) {
      var that = this, toShow = eventData.newPanel, toHide = eventData.oldPanel;
      this.running = true;
      function complete() {
        that.running = false;
        that._trigger('activate', event, eventData);
      }
      function show() {
        eventData.newTab.closest('li').addClass('ui-tabs-active ui-state-active');
        if (toShow.length && that.options.show) {
          that._show(toShow, that.options.show, complete);
        } else {
          toShow.show();
          complete();
        }
      }
      // start out by hiding, then showing, then completing
      if (toHide.length && this.options.hide) {
        this._hide(toHide, this.options.hide, function () {
          eventData.oldTab.closest('li').removeClass('ui-tabs-active ui-state-active');
          show();
        });
      } else {
        eventData.oldTab.closest('li').removeClass('ui-tabs-active ui-state-active');
        toHide.hide();
        show();
      }
      toHide.attr({
        'aria-expanded': 'false',
        'aria-hidden': 'true'
      });
      eventData.oldTab.attr('aria-selected', 'false');
      // If we're switching tabs, remove the old tab from the tab order.
      // If we're opening from collapsed state, remove the previous tab from the tab order.
      // If we're collapsing, then keep the collapsing tab in the tab order.
      if (toShow.length && toHide.length) {
        eventData.oldTab.attr('tabIndex', -1);
      } else if (toShow.length) {
        this.tabs.filter(function () {
          return $(this).attr('tabIndex') === 0;
        }).attr('tabIndex', -1);
      }
      toShow.attr({
        'aria-expanded': 'true',
        'aria-hidden': 'false'
      });
      eventData.newTab.attr({
        'aria-selected': 'true',
        tabIndex: 0
      });
    },
    _activate: function (index) {
      var anchor, active = this._findActive(index);
      // trying to activate the already active panel
      if (active[0] === this.active[0]) {
        return;
      }
      // trying to collapse, simulate a click on the current active header
      if (!active.length) {
        active = this.active;
      }
      anchor = active.find('.ui-tabs-anchor')[0];
      this._eventHandler({
        target: anchor,
        currentTarget: anchor,
        preventDefault: $.noop
      });
    },
    _findActive: function (index) {
      return index === false ? $() : this.tabs.eq(index);
    },
    _getIndex: function (index) {
      // meta-function to give users option to provide a href string instead of a numerical index.
      if (typeof index === 'string') {
        index = this.anchors.index(this.anchors.filter('[href$=\'' + index + '\']'));
      }
      return index;
    },
    _destroy: function () {
      if (this.xhr) {
        this.xhr.abort();
      }
      this.element.removeClass('ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible');
      this.tablist.removeClass('ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all').removeAttr('role');
      this.anchors.removeClass('ui-tabs-anchor').removeAttr('role').removeAttr('tabIndex').removeUniqueId();
      this.tabs.add(this.panels).each(function () {
        if ($.data(this, 'ui-tabs-destroy')) {
          $(this).remove();
        } else {
          $(this).removeClass('ui-state-default ui-state-active ui-state-disabled ' + 'ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel').removeAttr('tabIndex').removeAttr('aria-live').removeAttr('aria-busy').removeAttr('aria-selected').removeAttr('aria-labelledby').removeAttr('aria-hidden').removeAttr('aria-expanded').removeAttr('role');
        }
      });
      this.tabs.each(function () {
        var li = $(this), prev = li.data('ui-tabs-aria-controls');
        if (prev) {
          li.attr('aria-controls', prev).removeData('ui-tabs-aria-controls');
        } else {
          li.removeAttr('aria-controls');
        }
      });
      this.panels.show();
      if (this.options.heightStyle !== 'content') {
        this.panels.css('height', '');
      }
    },
    enable: function (index) {
      var disabled = this.options.disabled;
      if (disabled === false) {
        return;
      }
      if (index === undefined) {
        disabled = false;
      } else {
        index = this._getIndex(index);
        if ($.isArray(disabled)) {
          disabled = $.map(disabled, function (num) {
            return num !== index ? num : null;
          });
        } else {
          disabled = $.map(this.tabs, function (li, num) {
            return num !== index ? num : null;
          });
        }
      }
      this._setupDisabled(disabled);
    },
    disable: function (index) {
      var disabled = this.options.disabled;
      if (disabled === true) {
        return;
      }
      if (index === undefined) {
        disabled = true;
      } else {
        index = this._getIndex(index);
        if ($.inArray(index, disabled) !== -1) {
          return;
        }
        if ($.isArray(disabled)) {
          disabled = $.merge([index], disabled).sort();
        } else {
          disabled = [index];
        }
      }
      this._setupDisabled(disabled);
    },
    load: function (index, event) {
      index = this._getIndex(index);
      var that = this, tab = this.tabs.eq(index), anchor = tab.find('.ui-tabs-anchor'), panel = this._getPanelForTab(tab), eventData = {
          tab: tab,
          panel: panel
        };
      // not remote
      if (isLocal(anchor[0])) {
        return;
      }
      this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData));
      // support: jQuery <1.8
      // jQuery <1.8 returns false if the request is canceled in beforeSend,
      // but as of 1.8, $.ajax() always returns a jqXHR object.
      if (this.xhr && this.xhr.statusText !== 'canceled') {
        tab.addClass('ui-tabs-loading');
        panel.attr('aria-busy', 'true');
        this.xhr.success(function (response) {
          // support: jQuery <1.8
          // http://bugs.jquery.com/ticket/11778
          setTimeout(function () {
            panel.html(response);
            that._trigger('load', event, eventData);
          }, 1);
        }).complete(function (jqXHR, status) {
          // support: jQuery <1.8
          // http://bugs.jquery.com/ticket/11778
          setTimeout(function () {
            if (status === 'abort') {
              that.panels.stop(false, true);
            }
            tab.removeClass('ui-tabs-loading');
            panel.removeAttr('aria-busy');
            if (jqXHR === that.xhr) {
              delete that.xhr;
            }
          }, 1);
        });
      }
    },
    _ajaxSettings: function (anchor, event, eventData) {
      var that = this;
      return {
        url: anchor.attr('href'),
        beforeSend: function (jqXHR, settings) {
          return that._trigger('beforeLoad', event, $.extend({
            jqXHR: jqXHR,
            ajaxSettings: settings
          }, eventData));
        }
      };
    },
    _getPanelForTab: function (tab) {
      var id = $(tab).attr('aria-controls');
      return this.element.find(this._sanitizeSelector('#' + id));
    }
  });
}(jQuery));
(function ($) {
  var increments = 0;
  function addDescribedBy(elem, id) {
    var describedby = (elem.attr('aria-describedby') || '').split(/\s+/);
    describedby.push(id);
    elem.data('ui-tooltip-id', id).attr('aria-describedby', $.trim(describedby.join(' ')));
  }
  function removeDescribedBy(elem) {
    var id = elem.data('ui-tooltip-id'), describedby = (elem.attr('aria-describedby') || '').split(/\s+/), index = $.inArray(id, describedby);
    if (index !== -1) {
      describedby.splice(index, 1);
    }
    elem.removeData('ui-tooltip-id');
    describedby = $.trim(describedby.join(' '));
    if (describedby) {
      elem.attr('aria-describedby', describedby);
    } else {
      elem.removeAttr('aria-describedby');
    }
  }
  $.widget('ui.tooltip', {
    version: '1.10.3',
    options: {
      content: function () {
        // support: IE<9, Opera in jQuery <1.7
        // .text() can't accept undefined, so coerce to a string
        var title = $(this).attr('title') || '';
        // Escape title, since we're going from an attribute to raw HTML
        return $('<a>').text(title).html();
      },
      hide: true,
      items: '[title]:not([disabled])',
      position: {
        my: 'left top+15',
        at: 'left bottom',
        collision: 'flipfit flip'
      },
      show: true,
      tooltipClass: null,
      track: false,
      close: null,
      open: null
    },
    _create: function () {
      this._on({
        mouseover: 'open',
        focusin: 'open'
      });
      // IDs of generated tooltips, needed for destroy
      this.tooltips = {};
      // IDs of parent tooltips where we removed the title attribute
      this.parents = {};
      if (this.options.disabled) {
        this._disable();
      }
    },
    _setOption: function (key, value) {
      var that = this;
      if (key === 'disabled') {
        this[value ? '_disable' : '_enable']();
        this.options[key] = value;
        // disable element style changes
        return;
      }
      this._super(key, value);
      if (key === 'content') {
        $.each(this.tooltips, function (id, element) {
          that._updateContent(element);
        });
      }
    },
    _disable: function () {
      var that = this;
      // close open tooltips
      $.each(this.tooltips, function (id, element) {
        var event = $.Event('blur');
        event.target = event.currentTarget = element[0];
        that.close(event, true);
      });
      // remove title attributes to prevent native tooltips
      this.element.find(this.options.items).addBack().each(function () {
        var element = $(this);
        if (element.is('[title]')) {
          element.data('ui-tooltip-title', element.attr('title')).attr('title', '');
        }
      });
    },
    _enable: function () {
      // restore title attributes
      this.element.find(this.options.items).addBack().each(function () {
        var element = $(this);
        if (element.data('ui-tooltip-title')) {
          element.attr('title', element.data('ui-tooltip-title'));
        }
      });
    },
    open: function (event) {
      var that = this, target = $(event ? event.target : this.element).closest(this.options.items);
      // No element to show a tooltip for or the tooltip is already open
      if (!target.length || target.data('ui-tooltip-id')) {
        return;
      }
      if (target.attr('title')) {
        target.data('ui-tooltip-title', target.attr('title'));
      }
      target.data('ui-tooltip-open', true);
      // kill parent tooltips, custom or native, for hover
      if (event && event.type === 'mouseover') {
        target.parents().each(function () {
          var parent = $(this), blurEvent;
          if (parent.data('ui-tooltip-open')) {
            blurEvent = $.Event('blur');
            blurEvent.target = blurEvent.currentTarget = this;
            that.close(blurEvent, true);
          }
          if (parent.attr('title')) {
            parent.uniqueId();
            that.parents[this.id] = {
              element: this,
              title: parent.attr('title')
            };
            parent.attr('title', '');
          }
        });
      }
      this._updateContent(target, event);
    },
    _updateContent: function (target, event) {
      var content, contentOption = this.options.content, that = this, eventType = event ? event.type : null;
      if (typeof contentOption === 'string') {
        return this._open(event, target, contentOption);
      }
      content = contentOption.call(target[0], function (response) {
        // ignore async response if tooltip was closed already
        if (!target.data('ui-tooltip-open')) {
          return;
        }
        // IE may instantly serve a cached response for ajax requests
        // delay this call to _open so the other call to _open runs first
        that._delay(function () {
          // jQuery creates a special event for focusin when it doesn't
          // exist natively. To improve performance, the native event
          // object is reused and the type is changed. Therefore, we can't
          // rely on the type being correct after the event finished
          // bubbling, so we set it back to the previous value. (#8740)
          if (event) {
            event.type = eventType;
          }
          this._open(event, target, response);
        });
      });
      if (content) {
        this._open(event, target, content);
      }
    },
    _open: function (event, target, content) {
      var tooltip, events, delayedShow, positionOption = $.extend({}, this.options.position);
      if (!content) {
        return;
      }
      // Content can be updated multiple times. If the tooltip already
      // exists, then just update the content and bail.
      tooltip = this._find(target);
      if (tooltip.length) {
        tooltip.find('.ui-tooltip-content').html(content);
        return;
      }
      // if we have a title, clear it to prevent the native tooltip
      // we have to check first to avoid defining a title if none exists
      // (we don't want to cause an element to start matching [title])
      //
      // We use removeAttr only for key events, to allow IE to export the correct
      // accessible attributes. For mouse events, set to empty string to avoid
      // native tooltip showing up (happens only when removing inside mouseover).
      if (target.is('[title]')) {
        if (event && event.type === 'mouseover') {
          target.attr('title', '');
        } else {
          target.removeAttr('title');
        }
      }
      tooltip = this._tooltip(target);
      addDescribedBy(target, tooltip.attr('id'));
      tooltip.find('.ui-tooltip-content').html(content);
      function position(event) {
        positionOption.of = event;
        if (tooltip.is(':hidden')) {
          return;
        }
        tooltip.position(positionOption);
      }
      if (this.options.track && event && /^mouse/.test(event.type)) {
        this._on(this.document, { mousemove: position });
        // trigger once to override element-relative positioning
        position(event);
      } else {
        tooltip.position($.extend({ of: target }, this.options.position));
      }
      tooltip.hide();
      this._show(tooltip, this.options.show);
      // Handle tracking tooltips that are shown with a delay (#8644). As soon
      // as the tooltip is visible, position the tooltip using the most recent
      // event.
      if (this.options.show && this.options.show.delay) {
        delayedShow = this.delayedShow = setInterval(function () {
          if (tooltip.is(':visible')) {
            position(positionOption.of);
            clearInterval(delayedShow);
          }
        }, $.fx.interval);
      }
      this._trigger('open', event, { tooltip: tooltip });
      events = {
        keyup: function (event) {
          if (event.keyCode === $.ui.keyCode.ESCAPE) {
            var fakeEvent = $.Event(event);
            fakeEvent.currentTarget = target[0];
            this.close(fakeEvent, true);
          }
        },
        remove: function () {
          this._removeTooltip(tooltip);
        }
      };
      if (!event || event.type === 'mouseover') {
        events.mouseleave = 'close';
      }
      if (!event || event.type === 'focusin') {
        events.focusout = 'close';
      }
      this._on(true, target, events);
    },
    close: function (event) {
      var that = this, target = $(event ? event.currentTarget : this.element), tooltip = this._find(target);
      // disabling closes the tooltip, so we need to track when we're closing
      // to avoid an infinite loop in case the tooltip becomes disabled on close
      if (this.closing) {
        return;
      }
      // Clear the interval for delayed tracking tooltips
      clearInterval(this.delayedShow);
      // only set title if we had one before (see comment in _open())
      if (target.data('ui-tooltip-title')) {
        target.attr('title', target.data('ui-tooltip-title'));
      }
      removeDescribedBy(target);
      tooltip.stop(true);
      this._hide(tooltip, this.options.hide, function () {
        that._removeTooltip($(this));
      });
      target.removeData('ui-tooltip-open');
      this._off(target, 'mouseleave focusout keyup');
      // Remove 'remove' binding only on delegated targets
      if (target[0] !== this.element[0]) {
        this._off(target, 'remove');
      }
      this._off(this.document, 'mousemove');
      if (event && event.type === 'mouseleave') {
        $.each(this.parents, function (id, parent) {
          $(parent.element).attr('title', parent.title);
          delete that.parents[id];
        });
      }
      this.closing = true;
      this._trigger('close', event, { tooltip: tooltip });
      this.closing = false;
    },
    _tooltip: function (element) {
      var id = 'ui-tooltip-' + increments++, tooltip = $('<div>').attr({
          id: id,
          role: 'tooltip'
        }).addClass('ui-tooltip ui-widget ui-corner-all ui-widget-content ' + (this.options.tooltipClass || ''));
      $('<div>').addClass('ui-tooltip-content').appendTo(tooltip);
      tooltip.appendTo(this.document[0].body);
      this.tooltips[id] = element;
      return tooltip;
    },
    _find: function (target) {
      var id = target.data('ui-tooltip-id');
      return id ? $('#' + id) : $();
    },
    _removeTooltip: function (tooltip) {
      tooltip.remove();
      delete this.tooltips[tooltip.attr('id')];
    },
    _destroy: function () {
      var that = this;
      // close open tooltips
      $.each(this.tooltips, function (id, element) {
        // Delegate to close method to handle common cleanup
        var event = $.Event('blur');
        event.target = event.currentTarget = element[0];
        that.close(event, true);
        // Remove immediately; destroying an open tooltip doesn't use the
        // hide animation
        $('#' + id).remove();
        // Restore the title
        if (element.data('ui-tooltip-title')) {
          element.attr('title', element.data('ui-tooltip-title'));
          element.removeData('ui-tooltip-title');
        }
      });
    }
  });
}(jQuery));
// Copyright 2009-2012 by contributors, MIT License
// vim: ts=4 sts=4 sw=4 expandtab
// Module systems magic dance
(function (definition) {
  // RequireJS
  if (typeof define == 'function') {
    define(definition);  // YUI3
  } else if (typeof YUI == 'function') {
    YUI.add('es5', definition);  // CommonJS and <script>
  } else {
    definition();
  }
}(function () {
  /**
 * Brings an environment as close to ECMAScript 5 compliance
 * as is possible with the facilities of erstwhile engines.
 *
 * Annotated ES5: http://es5.github.com/ (specific links below)
 * ES5 Spec: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf
 * Required reading: http://javascriptweblog.wordpress.com/2011/12/05/extending-javascript-natives/
 */
  //
  // Function
  // ========
  //
  // ES-5 15.3.4.5
  // http://es5.github.com/#x15.3.4.5
  function Empty() {
  }
  if (!Function.prototype.bind) {
    Function.prototype.bind = function bind(that) {
      // .length is 1
      // 1. Let Target be the this value.
      var target = this;
      // 2. If IsCallable(Target) is false, throw a TypeError exception.
      if (typeof target != 'function') {
        throw new TypeError('Function.prototype.bind called on incompatible ' + target);
      }
      // 3. Let A be a new (possibly empty) internal list of all of the
      //   argument values provided after thisArg (arg1, arg2 etc), in order.
      // XXX slicedArgs will stand in for "A" if used
      var args = _Array_slice_.call(arguments, 1);
      // for normal call
      // 4. Let F be a new native ECMAScript object.
      // 11. Set the [[Prototype]] internal property of F to the standard
      //   built-in Function prototype object as specified in 15.3.3.1.
      // 12. Set the [[Call]] internal property of F as described in
      //   15.3.4.5.1.
      // 13. Set the [[Construct]] internal property of F as described in
      //   15.3.4.5.2.
      // 14. Set the [[HasInstance]] internal property of F as described in
      //   15.3.4.5.3.
      var bound = function () {
        if (this instanceof bound) {
          // 15.3.4.5.2 [[Construct]]
          // When the [[Construct]] internal method of a function object,
          // F that was created using the bind function is called with a
          // list of arguments ExtraArgs, the following steps are taken:
          // 1. Let target be the value of F's [[TargetFunction]]
          //   internal property.
          // 2. If target has no [[Construct]] internal method, a
          //   TypeError exception is thrown.
          // 3. Let boundArgs be the value of F's [[BoundArgs]] internal
          //   property.
          // 4. Let args be a new list containing the same values as the
          //   list boundArgs in the same order followed by the same
          //   values as the list ExtraArgs in the same order.
          // 5. Return the result of calling the [[Construct]] internal
          //   method of target providing args as the arguments.
          var result = target.apply(this, args.concat(_Array_slice_.call(arguments)));
          if (Object(result) === result) {
            return result;
          }
          return this;
        } else {
          // 15.3.4.5.1 [[Call]]
          // When the [[Call]] internal method of a function object, F,
          // which was created using the bind function is called with a
          // this value and a list of arguments ExtraArgs, the following
          // steps are taken:
          // 1. Let boundArgs be the value of F's [[BoundArgs]] internal
          //   property.
          // 2. Let boundThis be the value of F's [[BoundThis]] internal
          //   property.
          // 3. Let target be the value of F's [[TargetFunction]] internal
          //   property.
          // 4. Let args be a new list containing the same values as the
          //   list boundArgs in the same order followed by the same
          //   values as the list ExtraArgs in the same order.
          // 5. Return the result of calling the [[Call]] internal method
          //   of target providing boundThis as the this value and
          //   providing args as the arguments.
          // equiv: target.call(this, ...boundArgs, ...args)
          return target.apply(that, args.concat(_Array_slice_.call(arguments)));
        }
      };
      if (target.prototype) {
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        // Clean up dangling references.
        Empty.prototype = null;
      }
      // XXX bound.length is never writable, so don't even try
      //
      // 15. If the [[Class]] internal property of Target is "Function", then
      //     a. Let L be the length property of Target minus the length of A.
      //     b. Set the length own property of F to either 0 or L, whichever is
      //       larger.
      // 16. Else set the length own property of F to 0.
      // 17. Set the attributes of the length own property of F to the values
      //   specified in 15.3.5.1.
      // TODO
      // 18. Set the [[Extensible]] internal property of F to true.
      // TODO
      // 19. Let thrower be the [[ThrowTypeError]] function Object (13.2.3).
      // 20. Call the [[DefineOwnProperty]] internal method of F with
      //   arguments "caller", PropertyDescriptor {[[Get]]: thrower, [[Set]]:
      //   thrower, [[Enumerable]]: false, [[Configurable]]: false}, and
      //   false.
      // 21. Call the [[DefineOwnProperty]] internal method of F with
      //   arguments "arguments", PropertyDescriptor {[[Get]]: thrower,
      //   [[Set]]: thrower, [[Enumerable]]: false, [[Configurable]]: false},
      //   and false.
      // TODO
      // NOTE Function objects created using Function.prototype.bind do not
      // have a prototype property or the [[Code]], [[FormalParameters]], and
      // [[Scope]] internal properties.
      // XXX can't delete prototype in pure-js.
      // 22. Return F.
      return bound;
    };
  }
  // Shortcut to an often accessed properties, in order to avoid multiple
  // dereference that costs universally.
  // _Please note: Shortcuts are defined after `Function.prototype.bind` as we
  // us it in defining shortcuts.
  var call = Function.prototype.call;
  var prototypeOfArray = Array.prototype;
  var prototypeOfObject = Object.prototype;
  var _Array_slice_ = prototypeOfArray.slice;
  // Having a toString local variable name breaks in Opera so use _toString.
  var _toString = call.bind(prototypeOfObject.toString);
  var owns = call.bind(prototypeOfObject.hasOwnProperty);
  // If JS engine supports accessors creating shortcuts.
  var defineGetter;
  var defineSetter;
  var lookupGetter;
  var lookupSetter;
  var supportsAccessors;
  if (supportsAccessors = owns(prototypeOfObject, '__defineGetter__')) {
    defineGetter = call.bind(prototypeOfObject.__defineGetter__);
    defineSetter = call.bind(prototypeOfObject.__defineSetter__);
    lookupGetter = call.bind(prototypeOfObject.__lookupGetter__);
    lookupSetter = call.bind(prototypeOfObject.__lookupSetter__);
  }
  //
  // Array
  // =====
  //
  // ES5 15.4.4.12
  // http://es5.github.com/#x15.4.4.12
  // Default value for second param
  // [bugfix, ielt9, old browsers]
  // IE < 9 bug: [1,2].splice(0).join("") == "" but should be "12"
  if ([
      1,
      2
    ].splice(0).length != 2) {
    var array_splice = Array.prototype.splice;
    if (function () {
        // test IE < 9 to splice bug - see issue #138
        function makeArray(l) {
          var a = [];
          while (l--) {
            a.unshift(l);
          }
          return a;
        }
        var array = [], lengthBefore;
        ;
        array.splice.bind(array, 0, 0).apply(null, makeArray(20));
        array.splice.bind(array, 0, 0).apply(null, makeArray(26));
        lengthBefore = array.length;
        //20
        array.splice(5, 0, 'XXX');
        // add one element
        if (lengthBefore + 1 == array.length) {
          return true;  // has right splice implementation without bugs
        }  // else {
           //    IE8 bug
           // }
      }()) {
      //IE 6/7
      Array.prototype.splice = function (start, deleteCount) {
        if (!arguments.length) {
          return [];
        } else {
          return array_splice.apply(this, [
            start === void 0 ? 0 : start,
            deleteCount === void 0 ? this.length - start : deleteCount
          ].concat(_Array_slice_.call(arguments, 2)));
        }
      };
    } else {
      //IE8
      Array.prototype.splice = function (start, deleteCount) {
        var result, args = _Array_slice_.call(arguments, 2), addElementsCount = args.length;
        ;
        if (!arguments.length) {
          return [];
        }
        if (start === void 0) {
          // default
          start = 0;
        }
        if (deleteCount === void 0) {
          // default
          deleteCount = this.length - start;
        }
        if (addElementsCount > 0) {
          if (deleteCount <= 0) {
            if (start == this.length) {
              // tiny optimisation #1
              this.push.apply(this, args);
              return [];
            }
            if (start == 0) {
              // tiny optimisation #2
              this.unshift.apply(this, args);
              return [];
            }
          }
          // Array.prototype.splice implementation
          result = _Array_slice_.call(this, start, start + deleteCount);
          // delete part
          args.push.apply(args, _Array_slice_.call(this, start + deleteCount, this.length));
          // right part
          args.unshift.apply(args, _Array_slice_.call(this, 0, start));
          // left part
          // delete all items from this array and replace it to 'left part' + _Array_slice_.call(arguments, 2) + 'right part'
          args.unshift(0, this.length);
          array_splice.apply(this, args);
          return result;
        }
        return array_splice.call(this, start, deleteCount);
      };
    }
  }
  // ES5 15.4.4.12
  // http://es5.github.com/#x15.4.4.13
  // Return len+argCount.
  // [bugfix, ielt8]
  // IE < 8 bug: [].unshift(0) == undefined but should be "1"
  if ([].unshift(0) != 1) {
    var array_unshift = Array.prototype.unshift;
    Array.prototype.unshift = function () {
      array_unshift.apply(this, arguments);
      return this.length;
    };
  }
  // ES5 15.4.3.2
  // http://es5.github.com/#x15.4.3.2
  // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/isArray
  if (!Array.isArray) {
    Array.isArray = function isArray(obj) {
      return _toString(obj) == '[object Array]';
    };
  }
  // The IsCallable() check in the Array functions
  // has been replaced with a strict check on the
  // internal class of the object to trap cases where
  // the provided function was actually a regular
  // expression literal, which in V8 and
  // JavaScriptCore is a typeof "function".  Only in
  // V8 are regular expression literals permitted as
  // reduce parameters, so it is desirable in the
  // general case for the shim to match the more
  // strict and common behavior of rejecting regular
  // expressions.
  // ES5 15.4.4.18
  // http://es5.github.com/#x15.4.4.18
  // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/array/forEach
  // Check failure of by-index access of string characters (IE < 9)
  // and failure of `0 in boxedString` (Rhino)
  var boxedString = Object('a'), splitString = boxedString[0] != 'a' || !(0 in boxedString);
  if (!Array.prototype.forEach) {
    Array.prototype.forEach = function forEach(fun) {
      var object = toObject(this), self = splitString && _toString(this) == '[object String]' ? this.split('') : object, thisp = arguments[1], i = -1, length = self.length >>> 0;
      // If no callback function or if callback is not a callable function
      if (_toString(fun) != '[object Function]') {
        throw new TypeError();  // TODO message
      }
      while (++i < length) {
        if (i in self) {
          // Invoke the callback function with call, passing arguments:
          // context, property value, property key, thisArg object
          // context
          fun.call(thisp, self[i], i, object);
        }
      }
    };
  }
  // ES5 15.4.4.19
  // http://es5.github.com/#x15.4.4.19
  // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map
  if (!Array.prototype.map) {
    Array.prototype.map = function map(fun) {
      var object = toObject(this), self = splitString && _toString(this) == '[object String]' ? this.split('') : object, length = self.length >>> 0, result = Array(length), thisp = arguments[1];
      // If no callback function or if callback is not a callable function
      if (_toString(fun) != '[object Function]') {
        throw new TypeError(fun + ' is not a function');
      }
      for (var i = 0; i < length; i++) {
        if (i in self)
          result[i] = fun.call(thisp, self[i], i, object);
      }
      return result;
    };
  }
  // ES5 15.4.4.20
  // http://es5.github.com/#x15.4.4.20
  // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter
  if (!Array.prototype.filter) {
    Array.prototype.filter = function filter(fun) {
      var object = toObject(this), self = splitString && _toString(this) == '[object String]' ? this.split('') : object, length = self.length >>> 0, result = [], value, thisp = arguments[1];
      // If no callback function or if callback is not a callable function
      if (_toString(fun) != '[object Function]') {
        throw new TypeError(fun + ' is not a function');
      }
      for (var i = 0; i < length; i++) {
        if (i in self) {
          value = self[i];
          if (fun.call(thisp, value, i, object)) {
            result.push(value);
          }
        }
      }
      return result;
    };
  }
  // ES5 15.4.4.16
  // http://es5.github.com/#x15.4.4.16
  // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/every
  if (!Array.prototype.every) {
    Array.prototype.every = function every(fun) {
      var object = toObject(this), self = splitString && _toString(this) == '[object String]' ? this.split('') : object, length = self.length >>> 0, thisp = arguments[1];
      // If no callback function or if callback is not a callable function
      if (_toString(fun) != '[object Function]') {
        throw new TypeError(fun + ' is not a function');
      }
      for (var i = 0; i < length; i++) {
        if (i in self && !fun.call(thisp, self[i], i, object)) {
          return false;
        }
      }
      return true;
    };
  }
  // ES5 15.4.4.17
  // http://es5.github.com/#x15.4.4.17
  // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/some
  if (!Array.prototype.some) {
    Array.prototype.some = function some(fun) {
      var object = toObject(this), self = splitString && _toString(this) == '[object String]' ? this.split('') : object, length = self.length >>> 0, thisp = arguments[1];
      // If no callback function or if callback is not a callable function
      if (_toString(fun) != '[object Function]') {
        throw new TypeError(fun + ' is not a function');
      }
      for (var i = 0; i < length; i++) {
        if (i in self && fun.call(thisp, self[i], i, object)) {
          return true;
        }
      }
      return false;
    };
  }
  // ES5 15.4.4.21
  // http://es5.github.com/#x15.4.4.21
  // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduce
  if (!Array.prototype.reduce) {
    Array.prototype.reduce = function reduce(fun) {
      var object = toObject(this), self = splitString && _toString(this) == '[object String]' ? this.split('') : object, length = self.length >>> 0;
      // If no callback function or if callback is not a callable function
      if (_toString(fun) != '[object Function]') {
        throw new TypeError(fun + ' is not a function');
      }
      // no value to return if no initial value and an empty array
      if (!length && arguments.length == 1) {
        throw new TypeError('reduce of empty array with no initial value');
      }
      var i = 0;
      var result;
      if (arguments.length >= 2) {
        result = arguments[1];
      } else {
        do {
          if (i in self) {
            result = self[i++];
            break;
          }
          // if array contains no values, no initial value to return
          if (++i >= length) {
            throw new TypeError('reduce of empty array with no initial value');
          }
        } while (true);
      }
      for (; i < length; i++) {
        if (i in self) {
          result = fun.call(void 0, result, self[i], i, object);
        }
      }
      return result;
    };
  }
  // ES5 15.4.4.22
  // http://es5.github.com/#x15.4.4.22
  // https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/reduceRight
  if (!Array.prototype.reduceRight) {
    Array.prototype.reduceRight = function reduceRight(fun) {
      var object = toObject(this), self = splitString && _toString(this) == '[object String]' ? this.split('') : object, length = self.length >>> 0;
      // If no callback function or if callback is not a callable function
      if (_toString(fun) != '[object Function]') {
        throw new TypeError(fun + ' is not a function');
      }
      // no value to return if no initial value, empty array
      if (!length && arguments.length == 1) {
        throw new TypeError('reduceRight of empty array with no initial value');
      }
      var result, i = length - 1;
      if (arguments.length >= 2) {
        result = arguments[1];
      } else {
        do {
          if (i in self) {
            result = self[i--];
            break;
          }
          // if array contains no values, no initial value to return
          if (--i < 0) {
            throw new TypeError('reduceRight of empty array with no initial value');
          }
        } while (true);
      }
      if (i < 0) {
        return result;
      }
      do {
        if (i in this) {
          result = fun.call(void 0, result, self[i], i, object);
        }
      } while (i--);
      return result;
    };
  }
  // ES5 15.4.4.14
  // http://es5.github.com/#x15.4.4.14
  // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/indexOf
  if (!Array.prototype.indexOf || [
      0,
      1
    ].indexOf(1, 2) != -1) {
    Array.prototype.indexOf = function indexOf(sought) {
      var self = splitString && _toString(this) == '[object String]' ? this.split('') : toObject(this), length = self.length >>> 0;
      if (!length) {
        return -1;
      }
      var i = 0;
      if (arguments.length > 1) {
        i = toInteger(arguments[1]);
      }
      // handle negative indices
      i = i >= 0 ? i : Math.max(0, length + i);
      for (; i < length; i++) {
        if (i in self && self[i] === sought) {
          return i;
        }
      }
      return -1;
    };
  }
  // ES5 15.4.4.15
  // http://es5.github.com/#x15.4.4.15
  // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/lastIndexOf
  if (!Array.prototype.lastIndexOf || [
      0,
      1
    ].lastIndexOf(0, -3) != -1) {
    Array.prototype.lastIndexOf = function lastIndexOf(sought) {
      var self = splitString && _toString(this) == '[object String]' ? this.split('') : toObject(this), length = self.length >>> 0;
      if (!length) {
        return -1;
      }
      var i = length - 1;
      if (arguments.length > 1) {
        i = Math.min(i, toInteger(arguments[1]));
      }
      // handle negative indices
      i = i >= 0 ? i : length - Math.abs(i);
      for (; i >= 0; i--) {
        if (i in self && sought === self[i]) {
          return i;
        }
      }
      return -1;
    };
  }
  //
  // Object
  // ======
  //
  // ES5 15.2.3.14
  // http://es5.github.com/#x15.2.3.14
  if (!Object.keys) {
    // http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
    var hasDontEnumBug = true, dontEnums = [
        'toString',
        'toLocaleString',
        'valueOf',
        'hasOwnProperty',
        'isPrototypeOf',
        'propertyIsEnumerable',
        'constructor'
      ], dontEnumsLength = dontEnums.length;
    for (var key in { 'toString': null }) {
      hasDontEnumBug = false;
    }
    Object.keys = function keys(object) {
      if (typeof object != 'object' && typeof object != 'function' || object === null) {
        throw new TypeError('Object.keys called on a non-object');
      }
      var keys = [];
      for (var name in object) {
        if (owns(object, name)) {
          keys.push(name);
        }
      }
      if (hasDontEnumBug) {
        for (var i = 0, ii = dontEnumsLength; i < ii; i++) {
          var dontEnum = dontEnums[i];
          if (owns(object, dontEnum)) {
            keys.push(dontEnum);
          }
        }
      }
      return keys;
    };
  }
  //
  // Date
  // ====
  //
  // ES5 15.9.5.43
  // http://es5.github.com/#x15.9.5.43
  // This function returns a String value represent the instance in time
  // represented by this Date object. The format of the String is the Date Time
  // string format defined in 15.9.1.15. All fields are present in the String.
  // The time zone is always UTC, denoted by the suffix Z. If the time value of
  // this object is not a finite Number a RangeError exception is thrown.
  var negativeDate = -62198755200000, negativeYearString = '-000001';
  if (!Date.prototype.toISOString || new Date(negativeDate).toISOString().indexOf(negativeYearString) === -1) {
    Date.prototype.toISOString = function toISOString() {
      var result, length, value, year, month;
      if (!isFinite(this)) {
        throw new RangeError('Date.prototype.toISOString called on non-finite value.');
      }
      year = this.getUTCFullYear();
      month = this.getUTCMonth();
      // see https://github.com/kriskowal/es5-shim/issues/111
      year += Math.floor(month / 12);
      month = (month % 12 + 12) % 12;
      // the date time string format is specified in 15.9.1.15.
      result = [
        month + 1,
        this.getUTCDate(),
        this.getUTCHours(),
        this.getUTCMinutes(),
        this.getUTCSeconds()
      ];
      year = (year < 0 ? '-' : year > 9999 ? '+' : '') + ('00000' + Math.abs(year)).slice(0 <= year && year <= 9999 ? -4 : -6);
      length = result.length;
      while (length--) {
        value = result[length];
        // pad months, days, hours, minutes, and seconds to have two
        // digits.
        if (value < 10) {
          result[length] = '0' + value;
        }
      }
      // pad milliseconds to have three digits.
      return year + '-' + result.slice(0, 2).join('-') + 'T' + result.slice(2).join(':') + '.' + ('000' + this.getUTCMilliseconds()).slice(-3) + 'Z';
    };
  }
  // ES5 15.9.5.44
  // http://es5.github.com/#x15.9.5.44
  // This function provides a String representation of a Date object for use by
  // JSON.stringify (15.12.3).
  var dateToJSONIsSupported = false;
  try {
    dateToJSONIsSupported = Date.prototype.toJSON && new Date(NaN).toJSON() === null && new Date(negativeDate).toJSON().indexOf(negativeYearString) !== -1 && Date.prototype.toJSON.call({
      toISOString: function () {
        return true;
      }
    });
  } catch (e) {
  }
  if (!dateToJSONIsSupported) {
    Date.prototype.toJSON = function toJSON(key) {
      // When the toJSON method is called with argument key, the following
      // steps are taken:
      // 1.  Let O be the result of calling ToObject, giving it the this
      // value as its argument.
      // 2. Let tv be toPrimitive(O, hint Number).
      var o = Object(this), tv = toPrimitive(o), toISO;
      // 3. If tv is a Number and is not finite, return null.
      if (typeof tv === 'number' && !isFinite(tv)) {
        return null;
      }
      // 4. Let toISO be the result of calling the [[Get]] internal method of
      // O with argument "toISOString".
      toISO = o.toISOString;
      // 5. If IsCallable(toISO) is false, throw a TypeError exception.
      if (typeof toISO != 'function') {
        throw new TypeError('toISOString property is not callable');
      }
      // 6. Return the result of calling the [[Call]] internal method of
      //  toISO with O as the this value and an empty argument list.
      return toISO.call(o);  // NOTE 1 The argument is ignored.
                             // NOTE 2 The toJSON function is intentionally generic; it does not
                             // require that its this value be a Date object. Therefore, it can be
                             // transferred to other kinds of objects for use as a method. However,
                             // it does require that any such object have a toISOString method. An
                             // object is free to use the argument key to filter its
                             // stringification.
    };
  }
  // ES5 15.9.4.2
  // http://es5.github.com/#x15.9.4.2
  // based on work shared by Daniel Friesen (dantman)
  // http://gist.github.com/303249
  if (!Date.parse || 'Date.parse is buggy') {
    // XXX global assignment won't work in embeddings that use
    // an alternate object for the context.
    Date = function (NativeDate) {
      // Date.length === 7
      function Date(Y, M, D, h, m, s, ms) {
        var length = arguments.length;
        if (this instanceof NativeDate) {
          var date = length == 1 && String(Y) === Y ? new NativeDate(Date.parse(Y)) : length >= 7 ? new NativeDate(Y, M, D, h, m, s, ms) : length >= 6 ? new NativeDate(Y, M, D, h, m, s) : length >= 5 ? new NativeDate(Y, M, D, h, m) : length >= 4 ? new NativeDate(Y, M, D, h) : length >= 3 ? new NativeDate(Y, M, D) : length >= 2 ? new NativeDate(Y, M) : length >= 1 ? new NativeDate(Y) : new NativeDate();
          // Prevent mixups with unfixed Date object
          date.constructor = Date;
          return date;
        }
        return NativeDate.apply(this, arguments);
      }
      ;
      // 15.9.1.15 Date Time String Format.
      var isoDateExpression = new RegExp('^' + '(\\d{4}|[+-]\\d{6})' + '(?:-(\\d{2})' + '(?:-(\\d{2})' + '(?:' + 'T(\\d{2})' + ':(\\d{2})' + '(?:' + ':(\\d{2})' + '(?:(\\.\\d{1,}))?' + ')?' + '(' + 'Z|' + '(?:' + '([-+])' + '(\\d{2})' + ':(\\d{2})' + ')' + ')?)?)?)?' + '$');
      var months = [
          0,
          31,
          59,
          90,
          120,
          151,
          181,
          212,
          243,
          273,
          304,
          334,
          365
        ];
      function dayFromMonth(year, month) {
        var t = month > 1 ? 1 : 0;
        return months[month] + Math.floor((year - 1969 + t) / 4) - Math.floor((year - 1901 + t) / 100) + Math.floor((year - 1601 + t) / 400) + 365 * (year - 1970);
      }
      // Copy any custom methods a 3rd party library may have added
      for (var key in NativeDate) {
        Date[key] = NativeDate[key];
      }
      // Copy "native" methods explicitly; they may be non-enumerable
      Date.now = NativeDate.now;
      Date.UTC = NativeDate.UTC;
      Date.prototype = NativeDate.prototype;
      Date.prototype.constructor = Date;
      // Upgrade Date.parse to handle simplified ISO 8601 strings
      Date.parse = function parse(string) {
        var match = isoDateExpression.exec(string);
        if (match) {
          // parse months, days, hours, minutes, seconds, and milliseconds
          // provide default values if necessary
          // parse the UTC offset component
          var year = Number(match[1]), month = Number(match[2] || 1) - 1, day = Number(match[3] || 1) - 1, hour = Number(match[4] || 0), minute = Number(match[5] || 0), second = Number(match[6] || 0), millisecond = Math.floor(Number(match[7] || 0) * 1000),
            // When time zone is missed, local offset should be used
            // (ES 5.1 bug)
            // see https://bugs.ecmascript.org/show_bug.cgi?id=112
            offset = !match[4] || match[8] ? 0 : Number(new NativeDate(1970, 0)), signOffset = match[9] === '-' ? 1 : -1, hourOffset = Number(match[10] || 0), minuteOffset = Number(match[11] || 0), result;
          if (hour < (minute > 0 || second > 0 || millisecond > 0 ? 24 : 25) && minute < 60 && second < 60 && millisecond < 1000 && month > -1 && month < 12 && hourOffset < 24 && minuteOffset < 60 && day > -1 && day < dayFromMonth(year, month + 1) - dayFromMonth(year, month)) {
            result = ((dayFromMonth(year, month) + day) * 24 + hour + hourOffset * signOffset) * 60;
            result = ((result + minute + minuteOffset * signOffset) * 60 + second) * 1000 + millisecond + offset;
            if (-8640000000000000 <= result && result <= 8640000000000000) {
              return result;
            }
          }
          return NaN;
        }
        return NativeDate.parse.apply(this, arguments);
      };
      return Date;
    }(Date);
  }
  // ES5 15.9.4.4
  // http://es5.github.com/#x15.9.4.4
  if (!Date.now) {
    Date.now = function now() {
      return new Date().getTime();
    };
  }
  //
  // Number
  // ======
  //
  // ES5.1 15.7.4.5
  // http://es5.github.com/#x15.7.4.5
  if (!Number.prototype.toFixed || 0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) === '0' || 1.255.toFixed(2) !== '1.25' || 1000000000000000100..toFixed(0) !== '1000000000000000128') {
    // Hide these variables and functions
    (function () {
      var base, size, data, i;
      base = 10000000;
      size = 6;
      data = [
        0,
        0,
        0,
        0,
        0,
        0
      ];
      function multiply(n, c) {
        var i = -1;
        while (++i < size) {
          c += n * data[i];
          data[i] = c % base;
          c = Math.floor(c / base);
        }
      }
      function divide(n) {
        var i = size, c = 0;
        while (--i >= 0) {
          c += data[i];
          data[i] = Math.floor(c / n);
          c = c % n * base;
        }
      }
      function toString() {
        var i = size;
        var s = '';
        while (--i >= 0) {
          if (s !== '' || i === 0 || data[i] !== 0) {
            var t = String(data[i]);
            if (s === '') {
              s = t;
            } else {
              s += '0000000'.slice(0, 7 - t.length) + t;
            }
          }
        }
        return s;
      }
      function pow(x, n, acc) {
        return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
      }
      function log(x) {
        var n = 0;
        while (x >= 4096) {
          n += 12;
          x /= 4096;
        }
        while (x >= 2) {
          n += 1;
          x /= 2;
        }
        return n;
      }
      Number.prototype.toFixed = function (fractionDigits) {
        var f, x, s, m, e, z, j, k;
        // Test for NaN and round fractionDigits down
        f = Number(fractionDigits);
        f = f !== f ? 0 : Math.floor(f);
        if (f < 0 || f > 20) {
          throw new RangeError('Number.toFixed called with invalid number of decimals');
        }
        x = Number(this);
        // Test for NaN
        if (x !== x) {
          return 'NaN';
        }
        // If it is too big or small, return the string value of the number
        if (x <= -1e+21 || x >= 1e+21) {
          return String(x);
        }
        s = '';
        if (x < 0) {
          s = '-';
          x = -x;
        }
        m = '0';
        if (x > 1e-21) {
          // 1e-21 < x < 1e21
          // -70 < log2(x) < 70
          e = log(x * pow(2, 69, 1)) - 69;
          z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
          z *= 4503599627370496;
          // Math.pow(2, 52);
          e = 52 - e;
          // -18 < e < 122
          // x = z / 2 ^ e
          if (e > 0) {
            multiply(0, z);
            j = f;
            while (j >= 7) {
              multiply(10000000, 0);
              j -= 7;
            }
            multiply(pow(10, j, 1), 0);
            j = e - 1;
            while (j >= 23) {
              divide(1 << 23);
              j -= 23;
            }
            divide(1 << j);
            multiply(1, 1);
            divide(2);
            m = toString();
          } else {
            multiply(0, z);
            multiply(1 << -e, 0);
            m = toString() + '0.00000000000000000000'.slice(2, 2 + f);
          }
        }
        if (f > 0) {
          k = m.length;
          if (k <= f) {
            m = s + '0.0000000000000000000'.slice(0, f - k + 2) + m;
          } else {
            m = s + m.slice(0, k - f) + '.' + m.slice(k - f);
          }
        } else {
          m = s + m;
        }
        return m;
      };
    }());
  }
  //
  // String
  // ======
  //
  // ES5 15.5.4.14
  // http://es5.github.com/#x15.5.4.14
  // [bugfix, IE lt 9, firefox 4, Konqueror, Opera, obscure browsers]
  // Many browsers do not split properly with regular expressions or they
  // do not perform the split correctly under obscure conditions.
  // See http://blog.stevenlevithan.com/archives/cross-browser-split
  // I've tested in many browsers and this seems to cover the deviant ones:
  //    'ab'.split(/(?:ab)*/) should be ["", ""], not [""]
  //    '.'.split(/(.?)(.?)/) should be ["", ".", "", ""], not ["", ""]
  //    'tesst'.split(/(s)*/) should be ["t", undefined, "e", "s", "t"], not
  //       [undefined, "t", undefined, "e", ...]
  //    ''.split(/.?/) should be [], not [""]
  //    '.'.split(/()()/) should be ["."], not ["", "", "."]
  var string_split = String.prototype.split;
  if ('ab'.split(/(?:ab)*/).length !== 2 || '.'.split(/(.?)(.?)/).length !== 4 || 'tesst'.split(/(s)*/)[1] === 't' || ''.split(/.?/).length === 0 || '.'.split(/()()/).length > 1) {
    (function () {
      var compliantExecNpcg = /()??/.exec('')[1] === void 0;
      // NPCG: nonparticipating capturing group
      String.prototype.split = function (separator, limit) {
        var string = this;
        if (separator === void 0 && limit === 0)
          return [];
        // If `separator` is not a regex, use native split
        if (Object.prototype.toString.call(separator) !== '[object RegExp]') {
          return string_split.apply(this, arguments);
        }
        var output = [], flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.extended ? 'x' : '') + (separator.sticky ? 'y' : ''),
          // Firefox 3+
          lastLastIndex = 0,
          // Make `global` and avoid `lastIndex` issues by working with a copy
          separator = new RegExp(separator.source, flags + 'g'), separator2, match, lastIndex, lastLength;
        string += '';
        // Type-convert
        if (!compliantExecNpcg) {
          // Doesn't need flags gy, but they don't hurt
          separator2 = new RegExp('^' + separator.source + '$(?!\\s)', flags);
        }
        /* Values for `limit`, per the spec:
             * If undefined: 4294967295 // Math.pow(2, 32) - 1
             * If 0, Infinity, or NaN: 0
             * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
             * If negative number: 4294967296 - Math.floor(Math.abs(limit))
             * If other: Type-convert, then use the above rules
             */
        limit = limit === void 0 ? -1 >>> 0 : limit >>> 0;
        // ToUint32(limit)
        while (match = separator.exec(string)) {
          // `separator.lastIndex` is not reliable cross-browser
          lastIndex = match.index + match[0].length;
          if (lastIndex > lastLastIndex) {
            output.push(string.slice(lastLastIndex, match.index));
            // Fix browsers whose `exec` methods don't consistently return `undefined` for
            // nonparticipating capturing groups
            if (!compliantExecNpcg && match.length > 1) {
              match[0].replace(separator2, function () {
                for (var i = 1; i < arguments.length - 2; i++) {
                  if (arguments[i] === void 0) {
                    match[i] = void 0;
                  }
                }
              });
            }
            if (match.length > 1 && match.index < string.length) {
              Array.prototype.push.apply(output, match.slice(1));
            }
            lastLength = match[0].length;
            lastLastIndex = lastIndex;
            if (output.length >= limit) {
              break;
            }
          }
          if (separator.lastIndex === match.index) {
            separator.lastIndex++;  // Avoid an infinite loop
          }
        }
        if (lastLastIndex === string.length) {
          if (lastLength || !separator.test('')) {
            output.push('');
          }
        } else {
          output.push(string.slice(lastLastIndex));
        }
        return output.length > limit ? output.slice(0, limit) : output;
      };
    }());  // [bugfix, chrome]
           // If separator is undefined, then the result array contains just one String,
           // which is the this value (converted to a String). If limit is not undefined,
           // then the output array is truncated so that it contains no more than limit
           // elements.
           // "0".split(undefined, 0) -> []
  } else if ('0'.split(void 0, 0).length) {
    String.prototype.split = function (separator, limit) {
      if (separator === void 0 && limit === 0)
        return [];
      return string_split.apply(this, arguments);
    };
  }
  // ECMA-262, 3rd B.2.3
  // Note an ECMAScript standart, although ECMAScript 3rd Edition has a
  // non-normative section suggesting uniform semantics and it should be
  // normalized across all browsers
  // [bugfix, IE lt 9] IE < 9 substr() with negative value not working in IE
  if (''.substr && '0b'.substr(-1) !== 'b') {
    var string_substr = String.prototype.substr;
    /**
     *  Get the substring of a string
     *  @param  {integer}  start   where to start the substring
     *  @param  {integer}  length  how many characters to return
     *  @return {string}
     */
    String.prototype.substr = function (start, length) {
      return string_substr.call(this, start < 0 ? (start = this.length + start) < 0 ? 0 : start : start, length);
    };
  }
  // ES5 15.5.4.20
  // http://es5.github.com/#x15.5.4.20
  var ws = '\t\n\x0B\f\r \xa0\u1680\u180e\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000\u2028' + '\u2029\ufeff';
  if (!String.prototype.trim || ws.trim()) {
    // http://blog.stevenlevithan.com/archives/faster-trim-javascript
    // http://perfectionkills.com/whitespace-deviations/
    ws = '[' + ws + ']';
    var trimBeginRegexp = new RegExp('^' + ws + ws + '*'), trimEndRegexp = new RegExp(ws + ws + '*$');
    String.prototype.trim = function trim() {
      if (this === void 0 || this === null) {
        throw new TypeError('can\'t convert ' + this + ' to object');
      }
      return String(this).replace(trimBeginRegexp, '').replace(trimEndRegexp, '');
    };
  }
  //
  // Util
  // ======
  //
  // ES5 9.4
  // http://es5.github.com/#x9.4
  // http://jsperf.com/to-integer
  function toInteger(n) {
    n = +n;
    if (n !== n) {
      // isNaN
      n = 0;
    } else if (n !== 0 && n !== 1 / 0 && n !== -(1 / 0)) {
      n = (n > 0 || -1) * Math.floor(Math.abs(n));
    }
    return n;
  }
  function isPrimitive(input) {
    var type = typeof input;
    return input === null || type === 'undefined' || type === 'boolean' || type === 'number' || type === 'string';
  }
  function toPrimitive(input) {
    var val, valueOf, toString;
    if (isPrimitive(input)) {
      return input;
    }
    valueOf = input.valueOf;
    if (typeof valueOf === 'function') {
      val = valueOf.call(input);
      if (isPrimitive(val)) {
        return val;
      }
    }
    toString = input.toString;
    if (typeof toString === 'function') {
      val = toString.call(input);
      if (isPrimitive(val)) {
        return val;
      }
    }
    throw new TypeError();
  }
  // ES5 9.9
  // http://es5.github.com/#x9.9
  var toObject = function (o) {
    if (o == null) {
      // this matches both null and undefined
      throw new TypeError('can\'t convert ' + o + ' to object');
    }
    return Object(o);
  };
}));
/*! JSON v3.2.6 | http://bestiejs.github.io/json3 | Copyright 2012-2013, Kit Cambridge | http://kit.mit-license.org */
;
(function () {
  var n = null;
  (function (G) {
    function m(a) {
      if (m[a] !== s)
        return m[a];
      var c;
      if ('bug-string-char-index' == a)
        c = 'a' != 'a'[0];
      else if ('json' == a)
        c = m('json-stringify') && m('json-parse');
      else {
        var e;
        if ('json-stringify' == a) {
          c = o.stringify;
          var b = 'function' == typeof c && l;
          if (b) {
            (e = function () {
              return 1;
            }).toJSON = e;
            try {
              b = '0' === c(0) && '0' === c(new Number()) && '""' == c(new String()) && c(p) === s && c(s) === s && c() === s && '1' === c(e) && '[1]' == c([e]) && '[null]' == c([s]) && 'null' == c(n) && '[null,null,null]' == c([
                s,
                p,
                n
              ]) && '{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}' == c({
                a: [
                  e,
                  !0,
                  !1,
                  n,
                  '\0\b\n\f\r\t'
                ]
              }) && '1' === c(n, e) && '[\n 1,\n 2\n]' == c([
                1,
                2
              ], n, 1) && '"-271821-04-20T00:00:00.000Z"' == c(new Date(-8640000000000000)) && '"+275760-09-13T00:00:00.000Z"' == c(new Date(8640000000000000)) && '"-000001-01-01T00:00:00.000Z"' == c(new Date(-62198755200000)) && '"1969-12-31T23:59:59.999Z"' == c(new Date(-1));
            } catch (f) {
              b = !1;
            }
          }
          c = b;
        }
        if ('json-parse' == a) {
          c = o.parse;
          if ('function' == typeof c)
            try {
              if (0 === c('0') && !c(!1)) {
                e = c('{"a":[1,true,false,null,"\\u0000\\b\\n\\f\\r\\t"]}');
                var j = 5 == e.a.length && 1 === e.a[0];
                if (j) {
                  try {
                    j = !c('"\t"');
                  } catch (d) {
                  }
                  if (j)
                    try {
                      j = 1 !== c('01');
                    } catch (h) {
                    }
                  if (j)
                    try {
                      j = 1 !== c('1.');
                    } catch (k) {
                    }
                }
              }
            } catch (N) {
              j = !1;
            }
          c = j;
        }
      }
      return m[a] = !!c;
    }
    var p = {}.toString, q, x, s, H = typeof define === 'function' && define.amd, y = 'object' == typeof JSON && JSON, o = 'object' == typeof exports && exports && !exports.nodeType && exports;
    o && y ? (o.stringify = y.stringify, o.parse = y.parse) : o = G.JSON = y || {};
    var l = new Date(-3509827334573292);
    try {
      l = -109252 == l.getUTCFullYear() && 0 === l.getUTCMonth() && 1 === l.getUTCDate() && 10 == l.getUTCHours() && 37 == l.getUTCMinutes() && 6 == l.getUTCSeconds() && 708 == l.getUTCMilliseconds();
    } catch (O) {
    }
    if (!m('json')) {
      var t = m('bug-string-char-index');
      if (!l)
        var u = Math.floor, I = [
            0,
            31,
            59,
            90,
            120,
            151,
            181,
            212,
            243,
            273,
            304,
            334
          ], z = function (a, c) {
            return I[c] + 365 * (a - 1970) + u((a - 1969 + (c = +(c > 1))) / 4) - u((a - 1901 + c) / 100) + u((a - 1601 + c) / 400);
          };
      if (!(q = {}.hasOwnProperty))
        q = function (a) {
          var c = {}, e;
          if ((c.__proto__ = n, c.__proto__ = { toString: 1 }, c).toString != p)
            q = function (a) {
              var c = this.__proto__, a = a in (this.__proto__ = n, this);
              this.__proto__ = c;
              return a;
            };
          else {
            e = c.constructor;
            q = function (a) {
              var c = (this.constructor || e).prototype;
              return a in this && !(a in c && this[a] === c[a]);
            };
          }
          c = n;
          return q.call(this, a);
        };
      var J = {
          'boolean': 1,
          number: 1,
          string: 1,
          undefined: 1
        };
      x = function (a, c) {
        var e = 0, b, f, j;
        (b = function () {
          this.valueOf = 0;
        }).prototype.valueOf = 0;
        f = new b();
        for (j in f)
          q.call(f, j) && e++;
        b = f = n;
        if (e)
          x = e == 2 ? function (a, c) {
            var e = {}, b = p.call(a) == '[object Function]', f;
            for (f in a)
              !(b && f == 'prototype') && !q.call(e, f) && (e[f] = 1) && q.call(a, f) && c(f);
          } : function (a, c) {
            var e = p.call(a) == '[object Function]', b, f;
            for (b in a)
              !(e && b == 'prototype') && q.call(a, b) && !(f = b === 'constructor') && c(b);
            (f || q.call(a, b = 'constructor')) && c(b);
          };
        else {
          f = [
            'valueOf',
            'toString',
            'toLocaleString',
            'propertyIsEnumerable',
            'isPrototypeOf',
            'hasOwnProperty',
            'constructor'
          ];
          x = function (a, c) {
            var e = p.call(a) == '[object Function]', b, g;
            if (g = !e)
              if (g = typeof a.constructor != 'function') {
                g = typeof a.hasOwnProperty;
                g = g == 'object' ? !!a.hasOwnProperty : !J[g];
              }
            g = g ? a.hasOwnProperty : q;
            for (b in a)
              !(e && b == 'prototype') && g.call(a, b) && c(b);
            for (e = f.length; b = f[--e]; g.call(a, b) && c(b));
          };
        }
        return x(a, c);
      };
      if (!m('json-stringify')) {
        var K = {
            92: '\\\\',
            34: '\\"',
            8: '\\b',
            12: '\\f',
            10: '\\n',
            13: '\\r',
            9: '\\t'
          }, v = function (a, c) {
            return ('000000' + (c || 0)).slice(-a);
          }, D = function (a) {
            var c = '"', b = 0, g = a.length, f = g > 10 && t, j;
            for (f && (j = a.split('')); b < g; b++) {
              var d = a.charCodeAt(b);
              switch (d) {
              case 8:
              case 9:
              case 10:
              case 12:
              case 13:
              case 34:
              case 92:
                c = c + K[d];
                break;
              default:
                if (d < 32) {
                  c = c + ('\\u00' + v(2, d.toString(16)));
                  break;
                }
                c = c + (f ? j[b] : t ? a.charAt(b) : a[b]);
              }
            }
            return c + '"';
          }, B = function (a, c, b, g, f, j, d) {
            var h, k, i, l, m, o, r, t, w;
            try {
              h = c[a];
            } catch (y) {
            }
            if (typeof h == 'object' && h) {
              k = p.call(h);
              if (k == '[object Date]' && !q.call(h, 'toJSON'))
                if (h > -1 / 0 && h < 1 / 0) {
                  if (z) {
                    l = u(h / 86400000);
                    for (k = u(l / 365.2425) + 1970 - 1; z(k + 1, 0) <= l; k++);
                    for (i = u((l - z(k, 0)) / 30.42); z(k, i + 1) <= l; i++);
                    l = 1 + l - z(k, i);
                    m = (h % 86400000 + 86400000) % 86400000;
                    o = u(m / 3600000) % 24;
                    r = u(m / 60000) % 60;
                    t = u(m / 1000) % 60;
                    m = m % 1000;
                  } else {
                    k = h.getUTCFullYear();
                    i = h.getUTCMonth();
                    l = h.getUTCDate();
                    o = h.getUTCHours();
                    r = h.getUTCMinutes();
                    t = h.getUTCSeconds();
                    m = h.getUTCMilliseconds();
                  }
                  h = (k <= 0 || k >= 10000 ? (k < 0 ? '-' : '+') + v(6, k < 0 ? -k : k) : v(4, k)) + '-' + v(2, i + 1) + '-' + v(2, l) + 'T' + v(2, o) + ':' + v(2, r) + ':' + v(2, t) + '.' + v(3, m) + 'Z';
                } else
                  h = n;
              else if (typeof h.toJSON == 'function' && (k != '[object Number]' && k != '[object String]' && k != '[object Array]' || q.call(h, 'toJSON')))
                h = h.toJSON(a);
            }
            b && (h = b.call(c, a, h));
            if (h === n)
              return 'null';
            k = p.call(h);
            if (k == '[object Boolean]')
              return '' + h;
            if (k == '[object Number]')
              return h > -1 / 0 && h < 1 / 0 ? '' + h : 'null';
            if (k == '[object String]')
              return D('' + h);
            if (typeof h == 'object') {
              for (a = d.length; a--;)
                if (d[a] === h)
                  throw TypeError();
              d.push(h);
              w = [];
              c = j;
              j = j + f;
              if (k == '[object Array]') {
                i = 0;
                for (a = h.length; i < a; i++) {
                  k = B(i, h, b, g, f, j, d);
                  w.push(k === s ? 'null' : k);
                }
                a = w.length ? f ? '[\n' + j + w.join(',\n' + j) + '\n' + c + ']' : '[' + w.join(',') + ']' : '[]';
              } else {
                x(g || h, function (a) {
                  var c = B(a, h, b, g, f, j, d);
                  c !== s && w.push(D(a) + ':' + (f ? ' ' : '') + c);
                });
                a = w.length ? f ? '{\n' + j + w.join(',\n' + j) + '\n' + c + '}' : '{' + w.join(',') + '}' : '{}';
              }
              d.pop();
              return a;
            }
          };
        o.stringify = function (a, c, b) {
          var g, f, j, d;
          if (typeof c == 'function' || typeof c == 'object' && c)
            if ((d = p.call(c)) == '[object Function]')
              f = c;
            else if (d == '[object Array]') {
              j = {};
              for (var h = 0, k = c.length, i; h < k; i = c[h++], (d = p.call(i), d == '[object String]' || d == '[object Number]') && (j[i] = 1));
            }
          if (b)
            if ((d = p.call(b)) == '[object Number]') {
              if ((b = b - b % 1) > 0) {
                g = '';
                for (b > 10 && (b = 10); g.length < b; g = g + ' ');
              }
            } else
              d == '[object String]' && (g = b.length <= 10 ? b : b.slice(0, 10));
          return B('', (i = {}, i[''] = a, i), f, j, g, '', []);
        };
      }
      if (!m('json-parse')) {
        var L = String.fromCharCode, M = {
            92: '\\',
            34: '"',
            47: '/',
            98: '\b',
            116: '\t',
            110: '\n',
            102: '\f',
            114: '\r'
          }, b, A, i = function () {
            b = A = n;
            throw SyntaxError();
          }, r = function () {
            for (var a = A, c = a.length, e, g, f, j, d; b < c;) {
              d = a.charCodeAt(b);
              switch (d) {
              case 9:
              case 10:
              case 13:
              case 32:
                b++;
                break;
              case 123:
              case 125:
              case 91:
              case 93:
              case 58:
              case 44:
                e = t ? a.charAt(b) : a[b];
                b++;
                return e;
              case 34:
                e = '@';
                for (b++; b < c;) {
                  d = a.charCodeAt(b);
                  if (d < 32)
                    i();
                  else if (d == 92) {
                    d = a.charCodeAt(++b);
                    switch (d) {
                    case 92:
                    case 34:
                    case 47:
                    case 98:
                    case 116:
                    case 110:
                    case 102:
                    case 114:
                      e = e + M[d];
                      b++;
                      break;
                    case 117:
                      g = ++b;
                      for (f = b + 4; b < f; b++) {
                        d = a.charCodeAt(b);
                        d >= 48 && d <= 57 || d >= 97 && d <= 102 || d >= 65 && d <= 70 || i();
                      }
                      e = e + L('0x' + a.slice(g, b));
                      break;
                    default:
                      i();
                    }
                  } else {
                    if (d == 34)
                      break;
                    d = a.charCodeAt(b);
                    for (g = b; d >= 32 && d != 92 && d != 34;)
                      d = a.charCodeAt(++b);
                    e = e + a.slice(g, b);
                  }
                }
                if (a.charCodeAt(b) == 34) {
                  b++;
                  return e;
                }
                i();
              default:
                g = b;
                if (d == 45) {
                  j = true;
                  d = a.charCodeAt(++b);
                }
                if (d >= 48 && d <= 57) {
                  for (d == 48 && (d = a.charCodeAt(b + 1), d >= 48 && d <= 57) && i(); b < c && (d = a.charCodeAt(b), d >= 48 && d <= 57); b++);
                  if (a.charCodeAt(b) == 46) {
                    for (f = ++b; f < c && (d = a.charCodeAt(f), d >= 48 && d <= 57); f++);
                    f == b && i();
                    b = f;
                  }
                  d = a.charCodeAt(b);
                  if (d == 101 || d == 69) {
                    d = a.charCodeAt(++b);
                    (d == 43 || d == 45) && b++;
                    for (f = b; f < c && (d = a.charCodeAt(f), d >= 48 && d <= 57); f++);
                    f == b && i();
                    b = f;
                  }
                  return +a.slice(g, b);
                }
                j && i();
                if (a.slice(b, b + 4) == 'true') {
                  b = b + 4;
                  return true;
                }
                if (a.slice(b, b + 5) == 'false') {
                  b = b + 5;
                  return false;
                }
                if (a.slice(b, b + 4) == 'null') {
                  b = b + 4;
                  return n;
                }
                i();
              }
            }
            return '$';
          }, C = function (a) {
            var c, b;
            a == '$' && i();
            if (typeof a == 'string') {
              if ((t ? a.charAt(0) : a[0]) == '@')
                return a.slice(1);
              if (a == '[') {
                for (c = [];; b || (b = true)) {
                  a = r();
                  if (a == ']')
                    break;
                  if (b)
                    if (a == ',') {
                      a = r();
                      a == ']' && i();
                    } else
                      i();
                  a == ',' && i();
                  c.push(C(a));
                }
                return c;
              }
              if (a == '{') {
                for (c = {};; b || (b = true)) {
                  a = r();
                  if (a == '}')
                    break;
                  if (b)
                    if (a == ',') {
                      a = r();
                      a == '}' && i();
                    } else
                      i();
                  (a == ',' || typeof a != 'string' || (t ? a.charAt(0) : a[0]) != '@' || r() != ':') && i();
                  c[a.slice(1)] = C(r());
                }
                return c;
              }
              i();
            }
            return a;
          }, F = function (a, b, e) {
            e = E(a, b, e);
            e === s ? delete a[b] : a[b] = e;
          }, E = function (a, b, e) {
            var g = a[b], f;
            if (typeof g == 'object' && g)
              if (p.call(g) == '[object Array]')
                for (f = g.length; f--;)
                  F(g, f, e);
              else
                x(g, function (a) {
                  F(g, a, e);
                });
            return e.call(a, b, g);
          };
        o.parse = function (a, c) {
          var e, g;
          b = 0;
          A = '' + a;
          e = C(r());
          r() != '$' && i();
          b = A = n;
          return c && p.call(c) == '[object Function]' ? E((g = {}, g[''] = e, g), '', c) : e;
        };
      }
    }
    H && define(function () {
      return o;
    });
  }(this));
}());
/*!
 * Bootstrap v3.1.1 (http://getbootstrap.com)
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 */
if (typeof jQuery === 'undefined') {
  throw new Error('Bootstrap\'s JavaScript requires jQuery');
}
/* ========================================================================
 * Bootstrap: transition.js v3.1.1
 * http://getbootstrap.com/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // CSS TRANSITION SUPPORT (Shoutout: http://www.modernizr.com/)
  // ============================================================
  function transitionEnd() {
    var el = document.createElement('bootstrap');
    var transEndEventNames = {
        'WebkitTransition': 'webkitTransitionEnd',
        'MozTransition': 'transitionend',
        'OTransition': 'oTransitionEnd otransitionend',
        'transition': 'transitionend'
      };
    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return { end: transEndEventNames[name] };
      }
    }
    return false;
  }
  // http://blog.alexmaccaw.com/css-transitions
  $.fn.emulateTransitionEnd = function (duration) {
    var called = false, $el = this;
    $(this).one($.support.transition.end, function () {
      called = true;
    });
    var callback = function () {
      if (!called)
        $($el).trigger($.support.transition.end);
    };
    setTimeout(callback, duration);
    return this;
  };
  $(function () {
    $.support.transition = transitionEnd();
  });
}(jQuery);
/* ========================================================================
 * Bootstrap: alert.js v3.1.1
 * http://getbootstrap.com/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // ALERT CLASS DEFINITION
  // ======================
  var dismiss = '[data-dismiss="alert"]';
  var Alert = function (el) {
    $(el).on('click', dismiss, this.close);
  };
  Alert.prototype.close = function (e) {
    var $this = $(this);
    var selector = $this.attr('data-target');
    if (!selector) {
      selector = $this.attr('href');
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '');
    }
    var $parent = $(selector);
    if (e)
      e.preventDefault();
    if (!$parent.length) {
      $parent = $this.hasClass('alert') ? $this : $this.parent();
    }
    $parent.trigger(e = $.Event('close.bs.alert'));
    if (e.isDefaultPrevented())
      return;
    $parent.removeClass('in');
    function removeElement() {
      $parent.trigger('closed.bs.alert').remove();
    }
    $.support.transition && $parent.hasClass('fade') ? $parent.one($.support.transition.end, removeElement).emulateTransitionEnd(150) : removeElement();
  };
  // ALERT PLUGIN DEFINITION
  // =======================
  var old = $.fn.alert;
  $.fn.alert = function (option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.alert');
      if (!data)
        $this.data('bs.alert', data = new Alert(this));
      if (typeof option == 'string')
        data[option].call($this);
    });
  };
  $.fn.alert.Constructor = Alert;
  // ALERT NO CONFLICT
  // =================
  $.fn.alert.noConflict = function () {
    $.fn.alert = old;
    return this;
  };
  // ALERT DATA-API
  // ==============
  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close);
}(jQuery);
/* ========================================================================
 * Bootstrap: button.js v3.1.1
 * http://getbootstrap.com/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // BUTTON PUBLIC CLASS DEFINITION
  // ==============================
  var Button = function (element, options) {
    this.$element = $(element);
    this.options = $.extend({}, Button.DEFAULTS, options);
    this.isLoading = false;
  };
  Button.DEFAULTS = { loadingText: 'loading...' };
  Button.prototype.setState = function (state) {
    var d = 'disabled';
    var $el = this.$element;
    var val = $el.is('input') ? 'val' : 'html';
    var data = $el.data();
    state = state + 'Text';
    if (!data.resetText)
      $el.data('resetText', $el[val]());
    $el[val](data[state] || this.options[state]);
    // push to event loop to allow forms to submit
    setTimeout($.proxy(function () {
      if (state == 'loadingText') {
        this.isLoading = true;
        $el.addClass(d).attr(d, d);
      } else if (this.isLoading) {
        this.isLoading = false;
        $el.removeClass(d).removeAttr(d);
      }
    }, this), 0);
  };
  Button.prototype.toggle = function () {
    var changed = true;
    var $parent = this.$element.closest('[data-toggle="buttons"]');
    if ($parent.length) {
      var $input = this.$element.find('input');
      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked') && this.$element.hasClass('active'))
          changed = false;
        else
          $parent.find('.active').removeClass('active');
      }
      if (changed)
        $input.prop('checked', !this.$element.hasClass('active')).trigger('change');
    }
    if (changed)
      this.$element.toggleClass('active');
  };
  // BUTTON PLUGIN DEFINITION
  // ========================
  var old = $.fn.button;
  $.fn.button = function (option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.button');
      var options = typeof option == 'object' && option;
      if (!data)
        $this.data('bs.button', data = new Button(this, options));
      if (option == 'toggle')
        data.toggle();
      else if (option)
        data.setState(option);
    });
  };
  $.fn.button.Constructor = Button;
  // BUTTON NO CONFLICT
  // ==================
  $.fn.button.noConflict = function () {
    $.fn.button = old;
    return this;
  };
  // BUTTON DATA-API
  // ===============
  $(document).on('click.bs.button.data-api', '[data-toggle^=button]', function (e) {
    var $btn = $(e.target);
    if (!$btn.hasClass('btn'))
      $btn = $btn.closest('.btn');
    $btn.button('toggle');
    e.preventDefault();
  });
}(jQuery);
/* ========================================================================
 * Bootstrap: carousel.js v3.1.1
 * http://getbootstrap.com/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // CAROUSEL CLASS DEFINITION
  // =========================
  var Carousel = function (element, options) {
    this.$element = $(element);
    this.$indicators = this.$element.find('.carousel-indicators');
    this.options = options;
    this.paused = this.sliding = this.interval = this.$active = this.$items = null;
    this.options.pause == 'hover' && this.$element.on('mouseenter', $.proxy(this.pause, this)).on('mouseleave', $.proxy(this.cycle, this));
  };
  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true
  };
  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false);
    this.interval && clearInterval(this.interval);
    this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));
    return this;
  };
  Carousel.prototype.getActiveIndex = function () {
    this.$active = this.$element.find('.item.active');
    this.$items = this.$active.parent().children();
    return this.$items.index(this.$active);
  };
  Carousel.prototype.to = function (pos) {
    var that = this;
    var activeIndex = this.getActiveIndex();
    if (pos > this.$items.length - 1 || pos < 0)
      return;
    if (this.sliding)
      return this.$element.one('slid.bs.carousel', function () {
        that.to(pos);
      });
    if (activeIndex == pos)
      return this.pause().cycle();
    return this.slide(pos > activeIndex ? 'next' : 'prev', $(this.$items[pos]));
  };
  Carousel.prototype.pause = function (e) {
    e || (this.paused = true);
    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end);
      this.cycle(true);
    }
    this.interval = clearInterval(this.interval);
    return this;
  };
  Carousel.prototype.next = function () {
    if (this.sliding)
      return;
    return this.slide('next');
  };
  Carousel.prototype.prev = function () {
    if (this.sliding)
      return;
    return this.slide('prev');
  };
  Carousel.prototype.slide = function (type, next) {
    var $active = this.$element.find('.item.active');
    var $next = next || $active[type]();
    var isCycling = this.interval;
    var direction = type == 'next' ? 'left' : 'right';
    var fallback = type == 'next' ? 'first' : 'last';
    var that = this;
    if (!$next.length) {
      if (!this.options.wrap)
        return;
      $next = this.$element.find('.item')[fallback]();
    }
    if ($next.hasClass('active'))
      return this.sliding = false;
    var e = $.Event('slide.bs.carousel', {
        relatedTarget: $next[0],
        direction: direction
      });
    this.$element.trigger(e);
    if (e.isDefaultPrevented())
      return;
    this.sliding = true;
    isCycling && this.pause();
    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active');
      this.$element.one('slid.bs.carousel', function () {
        var $nextIndicator = $(that.$indicators.children()[that.getActiveIndex()]);
        $nextIndicator && $nextIndicator.addClass('active');
      });
    }
    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type);
      $next[0].offsetWidth;
      // force reflow
      $active.addClass(direction);
      $next.addClass(direction);
      $active.one($.support.transition.end, function () {
        $next.removeClass([
          type,
          direction
        ].join(' ')).addClass('active');
        $active.removeClass([
          'active',
          direction
        ].join(' '));
        that.sliding = false;
        setTimeout(function () {
          that.$element.trigger('slid.bs.carousel');
        }, 0);
      }).emulateTransitionEnd($active.css('transition-duration').slice(0, -1) * 1000);
    } else {
      $active.removeClass('active');
      $next.addClass('active');
      this.sliding = false;
      this.$element.trigger('slid.bs.carousel');
    }
    isCycling && this.cycle();
    return this;
  };
  // CAROUSEL PLUGIN DEFINITION
  // ==========================
  var old = $.fn.carousel;
  $.fn.carousel = function (option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.carousel');
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option);
      var action = typeof option == 'string' ? option : options.slide;
      if (!data)
        $this.data('bs.carousel', data = new Carousel(this, options));
      if (typeof option == 'number')
        data.to(option);
      else if (action)
        data[action]();
      else if (options.interval)
        data.pause().cycle();
    });
  };
  $.fn.carousel.Constructor = Carousel;
  // CAROUSEL NO CONFLICT
  // ====================
  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old;
    return this;
  };
  // CAROUSEL DATA-API
  // =================
  $(document).on('click.bs.carousel.data-api', '[data-slide], [data-slide-to]', function (e) {
    var $this = $(this), href;
    var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, ''));
    //strip for ie7
    var options = $.extend({}, $target.data(), $this.data());
    var slideIndex = $this.attr('data-slide-to');
    if (slideIndex)
      options.interval = false;
    $target.carousel(options);
    if (slideIndex = $this.attr('data-slide-to')) {
      $target.data('bs.carousel').to(slideIndex);
    }
    e.preventDefault();
  });
  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this);
      $carousel.carousel($carousel.data());
    });
  });
}(jQuery);
/* ========================================================================
 * Bootstrap: collapse.js v3.1.1
 * http://getbootstrap.com/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================
  var Collapse = function (element, options) {
    this.$element = $(element);
    this.options = $.extend({}, Collapse.DEFAULTS, options);
    this.transitioning = null;
    if (this.options.parent)
      this.$parent = $(this.options.parent);
    if (this.options.toggle)
      this.toggle();
  };
  Collapse.DEFAULTS = { toggle: true };
  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width');
    return hasWidth ? 'width' : 'height';
  };
  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in'))
      return;
    var startEvent = $.Event('show.bs.collapse');
    this.$element.trigger(startEvent);
    if (startEvent.isDefaultPrevented())
      return;
    var actives = this.$parent && this.$parent.find('> .panel > .in');
    if (actives && actives.length) {
      var hasData = actives.data('bs.collapse');
      if (hasData && hasData.transitioning)
        return;
      actives.collapse('hide');
      hasData || actives.data('bs.collapse', null);
    }
    var dimension = this.dimension();
    this.$element.removeClass('collapse').addClass('collapsing')[dimension](0);
    this.transitioning = 1;
    var complete = function () {
      this.$element.removeClass('collapsing').addClass('collapse in')[dimension]('auto');
      this.transitioning = 0;
      this.$element.trigger('shown.bs.collapse');
    };
    if (!$.support.transition)
      return complete.call(this);
    var scrollSize = $.camelCase([
        'scroll',
        dimension
      ].join('-'));
    this.$element.one($.support.transition.end, $.proxy(complete, this)).emulateTransitionEnd(350)[dimension](this.$element[0][scrollSize]);
  };
  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in'))
      return;
    var startEvent = $.Event('hide.bs.collapse');
    this.$element.trigger(startEvent);
    if (startEvent.isDefaultPrevented())
      return;
    var dimension = this.dimension();
    this.$element[dimension](this.$element[dimension]())[0].offsetHeight;
    this.$element.addClass('collapsing').removeClass('collapse').removeClass('in');
    this.transitioning = 1;
    var complete = function () {
      this.transitioning = 0;
      this.$element.trigger('hidden.bs.collapse').removeClass('collapsing').addClass('collapse');
    };
    if (!$.support.transition)
      return complete.call(this);
    this.$element[dimension](0).one($.support.transition.end, $.proxy(complete, this)).emulateTransitionEnd(350);
  };
  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']();
  };
  // COLLAPSE PLUGIN DEFINITION
  // ==========================
  var old = $.fn.collapse;
  $.fn.collapse = function (option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.collapse');
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option);
      if (!data && options.toggle && option == 'show')
        option = !option;
      if (!data)
        $this.data('bs.collapse', data = new Collapse(this, options));
      if (typeof option == 'string')
        data[option]();
    });
  };
  $.fn.collapse.Constructor = Collapse;
  // COLLAPSE NO CONFLICT
  // ====================
  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old;
    return this;
  };
  // COLLAPSE DATA-API
  // =================
  $(document).on('click.bs.collapse.data-api', '[data-toggle=collapse]', function (e) {
    var $this = $(this), href;
    var target = $this.attr('data-target') || e.preventDefault() || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '');
    //strip for ie7
    var $target = $(target);
    var data = $target.data('bs.collapse');
    var option = data ? 'toggle' : $this.data();
    var parent = $this.attr('data-parent');
    var $parent = parent && $(parent);
    if (!data || !data.transitioning) {
      if ($parent)
        $parent.find('[data-toggle=collapse][data-parent="' + parent + '"]').not($this).addClass('collapsed');
      $this[$target.hasClass('in') ? 'addClass' : 'removeClass']('collapsed');
    }
    $target.collapse(option);
  });
}(jQuery);
/* ========================================================================
 * Bootstrap: dropdown.js v3.1.1
 * http://getbootstrap.com/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // DROPDOWN CLASS DEFINITION
  // =========================
  var backdrop = '.dropdown-backdrop';
  var toggle = '[data-toggle=dropdown]';
  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle);
  };
  Dropdown.prototype.toggle = function (e) {
    var $this = $(this);
    if ($this.is('.disabled, :disabled'))
      return;
    var $parent = getParent($this);
    var isActive = $parent.hasClass('open');
    clearMenus();
    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $('<div class="dropdown-backdrop"/>').insertAfter($(this)).on('click', clearMenus);
      }
      var relatedTarget = { relatedTarget: this };
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget));
      if (e.isDefaultPrevented())
        return;
      $parent.toggleClass('open').trigger('shown.bs.dropdown', relatedTarget);
      $this.focus();
    }
    return false;
  };
  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27)/.test(e.keyCode))
      return;
    var $this = $(this);
    e.preventDefault();
    e.stopPropagation();
    if ($this.is('.disabled, :disabled'))
      return;
    var $parent = getParent($this);
    var isActive = $parent.hasClass('open');
    if (!isActive || isActive && e.keyCode == 27) {
      if (e.which == 27)
        $parent.find(toggle).focus();
      return $this.click();
    }
    var desc = ' li:not(.divider):visible a';
    var $items = $parent.find('[role=menu]' + desc + ', [role=listbox]' + desc);
    if (!$items.length)
      return;
    var index = $items.index($items.filter(':focus'));
    if (e.keyCode == 38 && index > 0)
      index--;
    // up
    if (e.keyCode == 40 && index < $items.length - 1)
      index++;
    // down
    if (!~index)
      index = 0;
    $items.eq(index).focus();
  };
  function clearMenus(e) {
    $(backdrop).remove();
    $(toggle).each(function () {
      var $parent = getParent($(this));
      var relatedTarget = { relatedTarget: this };
      if (!$parent.hasClass('open'))
        return;
      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget));
      if (e.isDefaultPrevented())
        return;
      $parent.removeClass('open').trigger('hidden.bs.dropdown', relatedTarget);
    });
  }
  function getParent($this) {
    var selector = $this.attr('data-target');
    if (!selector) {
      selector = $this.attr('href');
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '');
    }
    var $parent = selector && $(selector);
    return $parent && $parent.length ? $parent : $this.parent();
  }
  // DROPDOWN PLUGIN DEFINITION
  // ==========================
  var old = $.fn.dropdown;
  $.fn.dropdown = function (option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.dropdown');
      if (!data)
        $this.data('bs.dropdown', data = new Dropdown(this));
      if (typeof option == 'string')
        data[option].call($this);
    });
  };
  $.fn.dropdown.Constructor = Dropdown;
  // DROPDOWN NO CONFLICT
  // ====================
  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old;
    return this;
  };
  // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================
  $(document).on('click.bs.dropdown.data-api', clearMenus).on('click.bs.dropdown.data-api', '.dropdown form', function (e) {
    e.stopPropagation();
  }).on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle).on('keydown.bs.dropdown.data-api', toggle + ', [role=menu], [role=listbox]', Dropdown.prototype.keydown);
}(jQuery);
/* ========================================================================
 * Bootstrap: modal.js v3.1.1
 * http://getbootstrap.com/javascript/#modals
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // MODAL CLASS DEFINITION
  // ======================
  var Modal = function (element, options) {
    this.options = options;
    this.$element = $(element);
    this.$backdrop = this.isShown = null;
    if (this.options.remote) {
      this.$element.find('.modal-content').load(this.options.remote, $.proxy(function () {
        this.$element.trigger('loaded.bs.modal');
      }, this));
    }
  };
  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  };
  Modal.prototype.toggle = function (_relatedTarget) {
    return this[!this.isShown ? 'show' : 'hide'](_relatedTarget);
  };
  Modal.prototype.show = function (_relatedTarget) {
    var that = this;
    var e = $.Event('show.bs.modal', { relatedTarget: _relatedTarget });
    this.$element.trigger(e);
    if (this.isShown || e.isDefaultPrevented())
      return;
    this.isShown = true;
    this.escape();
    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this));
    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade');
      if (!that.$element.parent().length) {
        that.$element.appendTo(document.body);
      }
      that.$element.show().scrollTop(0);
      if (transition) {
        that.$element[0].offsetWidth;
      }
      that.$element.addClass('in').attr('aria-hidden', false);
      that.enforceFocus();
      var e = $.Event('shown.bs.modal', { relatedTarget: _relatedTarget });
      transition ? that.$element.find('.modal-dialog').one($.support.transition.end, function () {
        that.$element.focus().trigger(e);
      }).emulateTransitionEnd(300) : that.$element.focus().trigger(e);
    });
  };
  Modal.prototype.hide = function (e) {
    if (e)
      e.preventDefault();
    e = $.Event('hide.bs.modal');
    this.$element.trigger(e);
    if (!this.isShown || e.isDefaultPrevented())
      return;
    this.isShown = false;
    this.escape();
    $(document).off('focusin.bs.modal');
    this.$element.removeClass('in').attr('aria-hidden', true).off('click.dismiss.bs.modal');
    $.support.transition && this.$element.hasClass('fade') ? this.$element.one($.support.transition.end, $.proxy(this.hideModal, this)).emulateTransitionEnd(300) : this.hideModal();
  };
  Modal.prototype.enforceFocus = function () {
    $(document).off('focusin.bs.modal').on('focusin.bs.modal', $.proxy(function (e) {
      if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
        this.$element.focus();
      }
    }, this));
  };
  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keyup.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide();
      }, this));
    } else if (!this.isShown) {
      this.$element.off('keyup.dismiss.bs.modal');
    }
  };
  Modal.prototype.hideModal = function () {
    var that = this;
    this.$element.hide();
    this.backdrop(function () {
      that.removeBackdrop();
      that.$element.trigger('hidden.bs.modal');
    });
  };
  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove();
    this.$backdrop = null;
  };
  Modal.prototype.backdrop = function (callback) {
    var animate = this.$element.hasClass('fade') ? 'fade' : '';
    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate;
      this.$backdrop = $('<div class="modal-backdrop ' + animate + '" />').appendTo(document.body);
      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (e.target !== e.currentTarget)
          return;
        this.options.backdrop == 'static' ? this.$element[0].focus.call(this.$element[0]) : this.hide.call(this);
      }, this));
      if (doAnimate)
        this.$backdrop[0].offsetWidth;
      // force reflow
      this.$backdrop.addClass('in');
      if (!callback)
        return;
      doAnimate ? this.$backdrop.one($.support.transition.end, callback).emulateTransitionEnd(150) : callback();
    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in');
      $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one($.support.transition.end, callback).emulateTransitionEnd(150) : callback();
    } else if (callback) {
      callback();
    }
  };
  // MODAL PLUGIN DEFINITION
  // =======================
  var old = $.fn.modal;
  $.fn.modal = function (option, _relatedTarget) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.modal');
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option);
      if (!data)
        $this.data('bs.modal', data = new Modal(this, options));
      if (typeof option == 'string')
        data[option](_relatedTarget);
      else if (options.show)
        data.show(_relatedTarget);
    });
  };
  $.fn.modal.Constructor = Modal;
  // MODAL NO CONFLICT
  // =================
  $.fn.modal.noConflict = function () {
    $.fn.modal = old;
    return this;
  };
  // MODAL DATA-API
  // ==============
  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this = $(this);
    var href = $this.attr('href');
    var $target = $($this.attr('data-target') || href && href.replace(/.*(?=#[^\s]+$)/, ''));
    //strip for ie7
    var option = $target.data('bs.modal') ? 'toggle' : $.extend({ remote: !/#/.test(href) && href }, $target.data(), $this.data());
    if ($this.is('a'))
      e.preventDefault();
    $target.modal(option, this).one('hide', function () {
      $this.is(':visible') && $this.focus();
    });
  });
  $(document).on('show.bs.modal', '.modal', function () {
    $(document.body).addClass('modal-open');
  }).on('hidden.bs.modal', '.modal', function () {
    $(document.body).removeClass('modal-open');
  });
}(jQuery);
/* ========================================================================
 * Bootstrap: tooltip.js v3.1.1
 * http://getbootstrap.com/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================
  var Tooltip = function (element, options) {
    this.type = this.options = this.enabled = this.timeout = this.hoverState = this.$element = null;
    this.init('tooltip', element, options);
  };
  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false
  };
  Tooltip.prototype.init = function (type, element, options) {
    this.enabled = true;
    this.type = type;
    this.$element = $(element);
    this.options = this.getOptions(options);
    var triggers = this.options.trigger.split(' ');
    for (var i = triggers.length; i--;) {
      var trigger = triggers[i];
      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this));
      } else if (trigger != 'manual') {
        var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin';
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout';
        this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this));
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this));
      }
    }
    this.options.selector ? this._options = $.extend({}, this.options, {
      trigger: 'manual',
      selector: ''
    }) : this.fixTitle();
  };
  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS;
  };
  Tooltip.prototype.getOptions = function (options) {
    options = $.extend({}, this.getDefaults(), this.$element.data(), options);
    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      };
    }
    return options;
  };
  Tooltip.prototype.getDelegateOptions = function () {
    var options = {};
    var defaults = this.getDefaults();
    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value)
        options[key] = value;
    });
    return options;
  };
  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ? obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type);
    clearTimeout(self.timeout);
    self.hoverState = 'in';
    if (!self.options.delay || !self.options.delay.show)
      return self.show();
    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in')
        self.show();
    }, self.options.delay.show);
  };
  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ? obj : $(obj.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type);
    clearTimeout(self.timeout);
    self.hoverState = 'out';
    if (!self.options.delay || !self.options.delay.hide)
      return self.hide();
    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out')
        self.hide();
    }, self.options.delay.hide);
  };
  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.' + this.type);
    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e);
      if (e.isDefaultPrevented())
        return;
      var that = this;
      var $tip = this.tip();
      this.setContent();
      if (this.options.animation)
        $tip.addClass('fade');
      var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;
      var autoToken = /\s?auto?\s?/i;
      var autoPlace = autoToken.test(placement);
      if (autoPlace)
        placement = placement.replace(autoToken, '') || 'top';
      $tip.detach().css({
        top: 0,
        left: 0,
        display: 'block'
      }).addClass(placement);
      this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
      var pos = this.getPosition();
      var actualWidth = $tip[0].offsetWidth;
      var actualHeight = $tip[0].offsetHeight;
      if (autoPlace) {
        var $parent = this.$element.parent();
        var orgPlacement = placement;
        var docScroll = document.documentElement.scrollTop || document.body.scrollTop;
        var parentWidth = this.options.container == 'body' ? window.innerWidth : $parent.outerWidth();
        var parentHeight = this.options.container == 'body' ? window.innerHeight : $parent.outerHeight();
        var parentLeft = this.options.container == 'body' ? 0 : $parent.offset().left;
        placement = placement == 'bottom' && pos.top + pos.height + actualHeight - docScroll > parentHeight ? 'top' : placement == 'top' && pos.top - docScroll - actualHeight < 0 ? 'bottom' : placement == 'right' && pos.right + actualWidth > parentWidth ? 'left' : placement == 'left' && pos.left - actualWidth < parentLeft ? 'right' : placement;
        $tip.removeClass(orgPlacement).addClass(placement);
      }
      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
      this.applyPlacement(calculatedOffset, placement);
      this.hoverState = null;
      var complete = function () {
        that.$element.trigger('shown.bs.' + that.type);
      };
      $.support.transition && this.$tip.hasClass('fade') ? $tip.one($.support.transition.end, complete).emulateTransitionEnd(150) : complete();
    }
  };
  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var replace;
    var $tip = this.tip();
    var width = $tip[0].offsetWidth;
    var height = $tip[0].offsetHeight;
    // manually read margins because getBoundingClientRect includes difference
    var marginTop = parseInt($tip.css('margin-top'), 10);
    var marginLeft = parseInt($tip.css('margin-left'), 10);
    // we must check for NaN for ie 8/9
    if (isNaN(marginTop))
      marginTop = 0;
    if (isNaN(marginLeft))
      marginLeft = 0;
    offset.top = offset.top + marginTop;
    offset.left = offset.left + marginLeft;
    // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0
    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        });
      }
    }, offset), 0);
    $tip.addClass('in');
    // check to see if placing tip in new offset caused the tip to resize itself
    var actualWidth = $tip[0].offsetWidth;
    var actualHeight = $tip[0].offsetHeight;
    if (placement == 'top' && actualHeight != height) {
      replace = true;
      offset.top = offset.top + height - actualHeight;
    }
    if (/bottom|top/.test(placement)) {
      var delta = 0;
      if (offset.left < 0) {
        delta = offset.left * -2;
        offset.left = 0;
        $tip.offset(offset);
        actualWidth = $tip[0].offsetWidth;
        actualHeight = $tip[0].offsetHeight;
      }
      this.replaceArrow(delta - width + actualWidth, actualWidth, 'left');
    } else {
      this.replaceArrow(actualHeight - height, actualHeight, 'top');
    }
    if (replace)
      $tip.offset(offset);
  };
  Tooltip.prototype.replaceArrow = function (delta, dimension, position) {
    this.arrow().css(position, delta ? 50 * (1 - delta / dimension) + '%' : '');
  };
  Tooltip.prototype.setContent = function () {
    var $tip = this.tip();
    var title = this.getTitle();
    $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title);
    $tip.removeClass('fade in top bottom left right');
  };
  Tooltip.prototype.hide = function () {
    var that = this;
    var $tip = this.tip();
    var e = $.Event('hide.bs.' + this.type);
    function complete() {
      if (that.hoverState != 'in')
        $tip.detach();
      that.$element.trigger('hidden.bs.' + that.type);
    }
    this.$element.trigger(e);
    if (e.isDefaultPrevented())
      return;
    $tip.removeClass('in');
    $.support.transition && this.$tip.hasClass('fade') ? $tip.one($.support.transition.end, complete).emulateTransitionEnd(150) : complete();
    this.hoverState = null;
    return this;
  };
  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element;
    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '');
    }
  };
  Tooltip.prototype.hasContent = function () {
    return this.getTitle();
  };
  Tooltip.prototype.getPosition = function () {
    var el = this.$element[0];
    return $.extend({}, typeof el.getBoundingClientRect == 'function' ? el.getBoundingClientRect() : {
      width: el.offsetWidth,
      height: el.offsetHeight
    }, this.$element.offset());
  };
  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? {
      top: pos.top + pos.height,
      left: pos.left + pos.width / 2 - actualWidth / 2
    } : placement == 'top' ? {
      top: pos.top - actualHeight,
      left: pos.left + pos.width / 2 - actualWidth / 2
    } : placement == 'left' ? {
      top: pos.top + pos.height / 2 - actualHeight / 2,
      left: pos.left - actualWidth
    } : {
      top: pos.top + pos.height / 2 - actualHeight / 2,
      left: pos.left + pos.width
    };
  };
  Tooltip.prototype.getTitle = function () {
    var title;
    var $e = this.$element;
    var o = this.options;
    title = $e.attr('data-original-title') || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title);
    return title;
  };
  Tooltip.prototype.tip = function () {
    return this.$tip = this.$tip || $(this.options.template);
  };
  Tooltip.prototype.arrow = function () {
    return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow');
  };
  Tooltip.prototype.validate = function () {
    if (!this.$element[0].parentNode) {
      this.hide();
      this.$element = null;
      this.options = null;
    }
  };
  Tooltip.prototype.enable = function () {
    this.enabled = true;
  };
  Tooltip.prototype.disable = function () {
    this.enabled = false;
  };
  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled;
  };
  Tooltip.prototype.toggle = function (e) {
    var self = e ? $(e.currentTarget)[this.type](this.getDelegateOptions()).data('bs.' + this.type) : this;
    self.tip().hasClass('in') ? self.leave(self) : self.enter(self);
  };
  Tooltip.prototype.destroy = function () {
    clearTimeout(this.timeout);
    this.hide().$element.off('.' + this.type).removeData('bs.' + this.type);
  };
  // TOOLTIP PLUGIN DEFINITION
  // =========================
  var old = $.fn.tooltip;
  $.fn.tooltip = function (option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.tooltip');
      var options = typeof option == 'object' && option;
      if (!data && option == 'destroy')
        return;
      if (!data)
        $this.data('bs.tooltip', data = new Tooltip(this, options));
      if (typeof option == 'string')
        data[option]();
    });
  };
  $.fn.tooltip.Constructor = Tooltip;
  // TOOLTIP NO CONFLICT
  // ===================
  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old;
    return this;
  };
}(jQuery);
/* ========================================================================
 * Bootstrap: popover.js v3.1.1
 * http://getbootstrap.com/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // POPOVER PUBLIC CLASS DEFINITION
  // ===============================
  var Popover = function (element, options) {
    this.init('popover', element, options);
  };
  if (!$.fn.tooltip)
    throw new Error('Popover requires tooltip.js');
  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  });
  // NOTE: POPOVER EXTENDS tooltip.js
  // ================================
  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);
  Popover.prototype.constructor = Popover;
  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS;
  };
  Popover.prototype.setContent = function () {
    var $tip = this.tip();
    var title = this.getTitle();
    var content = this.getContent();
    $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title);
    $tip.find('.popover-content')[this.options.html ? typeof content == 'string' ? 'html' : 'append' : 'text'](content);
    $tip.removeClass('fade top bottom left right in');
    // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.
    if (!$tip.find('.popover-title').html())
      $tip.find('.popover-title').hide();
  };
  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent();
  };
  Popover.prototype.getContent = function () {
    var $e = this.$element;
    var o = this.options;
    return $e.attr('data-content') || (typeof o.content == 'function' ? o.content.call($e[0]) : o.content);
  };
  Popover.prototype.arrow = function () {
    return this.$arrow = this.$arrow || this.tip().find('.arrow');
  };
  Popover.prototype.tip = function () {
    if (!this.$tip)
      this.$tip = $(this.options.template);
    return this.$tip;
  };
  // POPOVER PLUGIN DEFINITION
  // =========================
  var old = $.fn.popover;
  $.fn.popover = function (option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.popover');
      var options = typeof option == 'object' && option;
      if (!data && option == 'destroy')
        return;
      if (!data)
        $this.data('bs.popover', data = new Popover(this, options));
      if (typeof option == 'string')
        data[option]();
    });
  };
  $.fn.popover.Constructor = Popover;
  // POPOVER NO CONFLICT
  // ===================
  $.fn.popover.noConflict = function () {
    $.fn.popover = old;
    return this;
  };
}(jQuery);
/* ========================================================================
 * Bootstrap: scrollspy.js v3.1.1
 * http://getbootstrap.com/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // SCROLLSPY CLASS DEFINITION
  // ==========================
  function ScrollSpy(element, options) {
    var href;
    var process = $.proxy(this.process, this);
    this.$element = $(element).is('body') ? $(window) : $(element);
    this.$body = $('body');
    this.$scrollElement = this.$element.on('scroll.bs.scroll-spy.data-api', process);
    this.options = $.extend({}, ScrollSpy.DEFAULTS, options);
    this.selector = (this.options.target || (href = $(element).attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '') || '') + ' .nav li > a';
    this.offsets = $([]);
    this.targets = $([]);
    this.activeTarget = null;
    this.refresh();
    this.process();
  }
  ScrollSpy.DEFAULTS = { offset: 10 };
  ScrollSpy.prototype.refresh = function () {
    var offsetMethod = this.$element[0] == window ? 'offset' : 'position';
    this.offsets = $([]);
    this.targets = $([]);
    var self = this;
    var $targets = this.$body.find(this.selector).map(function () {
        var $el = $(this);
        var href = $el.data('target') || $el.attr('href');
        var $href = /^#./.test(href) && $(href);
        return $href && $href.length && $href.is(':visible') && [[
            $href[offsetMethod]().top + (!$.isWindow(self.$scrollElement.get(0)) && self.$scrollElement.scrollTop()),
            href
          ]] || null;
      }).sort(function (a, b) {
        return a[0] - b[0];
      }).each(function () {
        self.offsets.push(this[0]);
        self.targets.push(this[1]);
      });
  };
  ScrollSpy.prototype.process = function () {
    var scrollTop = this.$scrollElement.scrollTop() + this.options.offset;
    var scrollHeight = this.$scrollElement[0].scrollHeight || this.$body[0].scrollHeight;
    var maxScroll = scrollHeight - this.$scrollElement.height();
    var offsets = this.offsets;
    var targets = this.targets;
    var activeTarget = this.activeTarget;
    var i;
    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets.last()[0]) && this.activate(i);
    }
    if (activeTarget && scrollTop <= offsets[0]) {
      return activeTarget != (i = targets[0]) && this.activate(i);
    }
    for (i = offsets.length; i--;) {
      activeTarget != targets[i] && scrollTop >= offsets[i] && (!offsets[i + 1] || scrollTop <= offsets[i + 1]) && this.activate(targets[i]);
    }
  };
  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target;
    $(this.selector).parentsUntil(this.options.target, '.active').removeClass('active');
    var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]';
    var active = $(selector).parents('li').addClass('active');
    if (active.parent('.dropdown-menu').length) {
      active = active.closest('li.dropdown').addClass('active');
    }
    active.trigger('activate.bs.scrollspy');
  };
  // SCROLLSPY PLUGIN DEFINITION
  // ===========================
  var old = $.fn.scrollspy;
  $.fn.scrollspy = function (option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.scrollspy');
      var options = typeof option == 'object' && option;
      if (!data)
        $this.data('bs.scrollspy', data = new ScrollSpy(this, options));
      if (typeof option == 'string')
        data[option]();
    });
  };
  $.fn.scrollspy.Constructor = ScrollSpy;
  // SCROLLSPY NO CONFLICT
  // =====================
  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old;
    return this;
  };
  // SCROLLSPY DATA-API
  // ==================
  $(window).on('load', function () {
    $('[data-spy="scroll"]').each(function () {
      var $spy = $(this);
      $spy.scrollspy($spy.data());
    });
  });
}(jQuery);
/* ========================================================================
 * Bootstrap: tab.js v3.1.1
 * http://getbootstrap.com/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // TAB CLASS DEFINITION
  // ====================
  var Tab = function (element) {
    this.element = $(element);
  };
  Tab.prototype.show = function () {
    var $this = this.element;
    var $ul = $this.closest('ul:not(.dropdown-menu)');
    var selector = $this.data('target');
    if (!selector) {
      selector = $this.attr('href');
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '');
    }
    if ($this.parent('li').hasClass('active'))
      return;
    var previous = $ul.find('.active:last a')[0];
    var e = $.Event('show.bs.tab', { relatedTarget: previous });
    $this.trigger(e);
    if (e.isDefaultPrevented())
      return;
    var $target = $(selector);
    this.activate($this.parent('li'), $ul);
    this.activate($target, $target.parent(), function () {
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: previous
      });
    });
  };
  Tab.prototype.activate = function (element, container, callback) {
    var $active = container.find('> .active');
    var transition = callback && $.support.transition && $active.hasClass('fade');
    function next() {
      $active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active');
      element.addClass('active');
      if (transition) {
        element[0].offsetWidth;
        // reflow for transition
        element.addClass('in');
      } else {
        element.removeClass('fade');
      }
      if (element.parent('.dropdown-menu')) {
        element.closest('li.dropdown').addClass('active');
      }
      callback && callback();
    }
    transition ? $active.one($.support.transition.end, next).emulateTransitionEnd(150) : next();
    $active.removeClass('in');
  };
  // TAB PLUGIN DEFINITION
  // =====================
  var old = $.fn.tab;
  $.fn.tab = function (option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.tab');
      if (!data)
        $this.data('bs.tab', data = new Tab(this));
      if (typeof option == 'string')
        data[option]();
    });
  };
  $.fn.tab.Constructor = Tab;
  // TAB NO CONFLICT
  // ===============
  $.fn.tab.noConflict = function () {
    $.fn.tab = old;
    return this;
  };
  // TAB DATA-API
  // ============
  $(document).on('click.bs.tab.data-api', '[data-toggle="tab"], [data-toggle="pill"]', function (e) {
    e.preventDefault();
    $(this).tab('show');
  });
}(jQuery);
/* ========================================================================
 * Bootstrap: affix.js v3.1.1
 * http://getbootstrap.com/javascript/#affix
 * ========================================================================
 * Copyright 2011-2014 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';
  // AFFIX CLASS DEFINITION
  // ======================
  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options);
    this.$window = $(window).on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this)).on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this));
    this.$element = $(element);
    this.affixed = this.unpin = this.pinnedOffset = null;
    this.checkPosition();
  };
  Affix.RESET = 'affix affix-top affix-bottom';
  Affix.DEFAULTS = { offset: 0 };
  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset)
      return this.pinnedOffset;
    this.$element.removeClass(Affix.RESET).addClass('affix');
    var scrollTop = this.$window.scrollTop();
    var position = this.$element.offset();
    return this.pinnedOffset = position.top - scrollTop;
  };
  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1);
  };
  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible'))
      return;
    var scrollHeight = $(document).height();
    var scrollTop = this.$window.scrollTop();
    var position = this.$element.offset();
    var offset = this.options.offset;
    var offsetTop = offset.top;
    var offsetBottom = offset.bottom;
    if (this.affixed == 'top')
      position.top += scrollTop;
    if (typeof offset != 'object')
      offsetBottom = offsetTop = offset;
    if (typeof offsetTop == 'function')
      offsetTop = offset.top(this.$element);
    if (typeof offsetBottom == 'function')
      offsetBottom = offset.bottom(this.$element);
    var affix = this.unpin != null && scrollTop + this.unpin <= position.top ? false : offsetBottom != null && position.top + this.$element.height() >= scrollHeight - offsetBottom ? 'bottom' : offsetTop != null && scrollTop <= offsetTop ? 'top' : false;
    if (this.affixed === affix)
      return;
    if (this.unpin)
      this.$element.css('top', '');
    var affixType = 'affix' + (affix ? '-' + affix : '');
    var e = $.Event(affixType + '.bs.affix');
    this.$element.trigger(e);
    if (e.isDefaultPrevented())
      return;
    this.affixed = affix;
    this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null;
    this.$element.removeClass(Affix.RESET).addClass(affixType).trigger($.Event(affixType.replace('affix', 'affixed')));
    if (affix == 'bottom') {
      this.$element.offset({ top: scrollHeight - offsetBottom - this.$element.height() });
    }
  };
  // AFFIX PLUGIN DEFINITION
  // =======================
  var old = $.fn.affix;
  $.fn.affix = function (option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.affix');
      var options = typeof option == 'object' && option;
      if (!data)
        $this.data('bs.affix', data = new Affix(this, options));
      if (typeof option == 'string')
        data[option]();
    });
  };
  $.fn.affix.Constructor = Affix;
  // AFFIX NO CONFLICT
  // =================
  $.fn.affix.noConflict = function () {
    $.fn.affix = old;
    return this;
  };
  // AFFIX DATA-API
  // ==============
  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this);
      var data = $spy.data();
      data.offset = data.offset || {};
      if (data.offsetBottom)
        data.offset.bottom = data.offsetBottom;
      if (data.offsetTop)
        data.offset.top = data.offsetTop;
      $spy.affix(data);
    });
  });
}(jQuery);
/*
 * JavaScript Templates 2.4.1
 * https://github.com/blueimp/JavaScript-Templates
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 *
 * Inspired by John Resig's JavaScript Micro-Templating:
 * http://ejohn.org/blog/javascript-micro-templating/
 */
/*jslint evil: true, regexp: true, unparam: true */
/*global document, define */
(function ($) {
  'use strict';
  var tmpl = function (str, data) {
    var f = !/[^\w\-\.:]/.test(str) ? tmpl.cache[str] = tmpl.cache[str] || tmpl(tmpl.load(str)) : new Function(tmpl.arg + ',tmpl', 'var _e=tmpl.encode' + tmpl.helper + ',_s=\'' + str.replace(tmpl.regexp, tmpl.func) + '\';return _s;');
    return data ? f(data, tmpl) : function (data) {
      return f(data, tmpl);
    };
  };
  tmpl.cache = {};
  tmpl.load = function (id) {
    return document.getElementById(id).innerHTML;
  };
  tmpl.regexp = /([\s'\\])(?!(?:[^{]|\{(?!%))*%\})|(?:\{%(=|#)([\s\S]+?)%\})|(\{%)|(%\})/g;
  tmpl.func = function (s, p1, p2, p3, p4, p5) {
    if (p1) {
      // whitespace, quote and backspace in HTML context
      return {
        '\n': '\\n',
        '\r': '\\r',
        '\t': '\\t',
        ' ': ' '
      }[p1] || '\\' + p1;
    }
    if (p2) {
      // interpolation: {%=prop%}, or unescaped: {%#prop%}
      if (p2 === '=') {
        return '\'+_e(' + p3 + ')+\'';
      }
      return '\'+(' + p3 + '==null?\'\':' + p3 + ')+\'';
    }
    if (p4) {
      // evaluation start tag: {%
      return '\';';
    }
    if (p5) {
      // evaluation end tag: %}
      return '_s+=\'';
    }
  };
  tmpl.encReg = /[<>&"'\x00]/g;
  tmpl.encMap = {
    '<': '&lt;',
    '>': '&gt;',
    '&': '&amp;',
    '"': '&quot;',
    '\'': '&#39;'
  };
  tmpl.encode = function (s) {
    /*jshint eqnull:true */
    return (s == null ? '' : '' + s).replace(tmpl.encReg, function (c) {
      return tmpl.encMap[c] || '';
    });
  };
  tmpl.arg = 'o';
  tmpl.helper = ',print=function(s,e){_s+=e?(s==null?\'\':s):_e(s);}' + ',include=function(s,d){_s+=tmpl(s,d);}';
  if (typeof define === 'function' && define.amd) {
    define(function () {
      return tmpl;
    });
  } else {
    $.tmpl = tmpl;
  }
}(this));
/*
 * JavaScript Load Image 1.9.0
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
/*jslint nomen: true */
/*global define, window, document, URL, webkitURL, Blob, File, FileReader */
(function ($) {
  'use strict';
  // Loads an image for a given File object.
  // Invokes the callback with an img or optional canvas
  // element (if supported by the browser) as parameter:
  var loadImage = function (file, callback, options) {
      var img = document.createElement('img'), url, oUrl;
      img.onerror = callback;
      img.onload = function () {
        if (oUrl && !(options && options.noRevoke)) {
          loadImage.revokeObjectURL(oUrl);
        }
        if (callback) {
          callback(loadImage.scale(img, options));
        }
      };
      if (loadImage.isInstanceOf('Blob', file) || loadImage.isInstanceOf('File', file)) {
        url = oUrl = loadImage.createObjectURL(file);
        // Store the file type for resize processing:
        img._type = file.type;
      } else if (typeof file === 'string') {
        url = file;
        if (options && options.crossOrigin) {
          img.crossOrigin = options.crossOrigin;
        }
      } else {
        return false;
      }
      if (url) {
        img.src = url;
        return img;
      }
      return loadImage.readFile(file, function (e) {
        var target = e.target;
        if (target && target.result) {
          img.src = target.result;
        } else {
          if (callback) {
            callback(e);
          }
        }
      });
    },
    // The check for URL.revokeObjectURL fixes an issue with Opera 12,
    // which provides URL.createObjectURL but doesn't properly implement it:
    urlAPI = window.createObjectURL && window || window.URL && URL.revokeObjectURL && URL || window.webkitURL && webkitURL;
  loadImage.isInstanceOf = function (type, obj) {
    // Cross-frame instanceof check
    return Object.prototype.toString.call(obj) === '[object ' + type + ']';
  };
  // Transform image coordinates, allows to override e.g.
  // the canvas orientation based on the orientation option,
  // gets canvas, options passed as arguments:
  loadImage.transformCoordinates = function () {
    return;
  };
  // Returns transformed options, allows to override e.g.
  // coordinate and dimension options based on the orientation:
  loadImage.getTransformedOptions = function (options) {
    return options;
  };
  // Canvas render method, allows to override the
  // rendering e.g. to work around issues on iOS:
  loadImage.renderImageToCanvas = function (canvas, img, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight) {
    canvas.getContext('2d').drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
    return canvas;
  };
  // This method is used to determine if the target image
  // should be a canvas element:
  loadImage.hasCanvasOption = function (options) {
    return options.canvas || options.crop;
  };
  // Scales and/or crops the given image (img or canvas HTML element)
  // using the given options.
  // Returns a canvas object if the browser supports canvas
  // and the hasCanvasOption method returns true or a canvas
  // object is passed as image, else the scaled image:
  loadImage.scale = function (img, options) {
    options = options || {};
    var canvas = document.createElement('canvas'), useCanvas = img.getContext || loadImage.hasCanvasOption(options) && canvas.getContext, width = img.naturalWidth || img.width, height = img.naturalHeight || img.height, destWidth = width, destHeight = height, maxWidth, maxHeight, minWidth, minHeight, sourceWidth, sourceHeight, sourceX, sourceY, tmp, scaleUp = function () {
        var scale = Math.max((minWidth || destWidth) / destWidth, (minHeight || destHeight) / destHeight);
        if (scale > 1) {
          destWidth = Math.ceil(destWidth * scale);
          destHeight = Math.ceil(destHeight * scale);
        }
      }, scaleDown = function () {
        var scale = Math.min((maxWidth || destWidth) / destWidth, (maxHeight || destHeight) / destHeight);
        if (scale < 1) {
          destWidth = Math.ceil(destWidth * scale);
          destHeight = Math.ceil(destHeight * scale);
        }
      };
    if (useCanvas) {
      options = loadImage.getTransformedOptions(options);
      sourceX = options.left || 0;
      sourceY = options.top || 0;
      if (options.sourceWidth) {
        sourceWidth = options.sourceWidth;
        if (options.right !== undefined && options.left === undefined) {
          sourceX = width - sourceWidth - options.right;
        }
      } else {
        sourceWidth = width - sourceX - (options.right || 0);
      }
      if (options.sourceHeight) {
        sourceHeight = options.sourceHeight;
        if (options.bottom !== undefined && options.top === undefined) {
          sourceY = height - sourceHeight - options.bottom;
        }
      } else {
        sourceHeight = height - sourceY - (options.bottom || 0);
      }
      destWidth = sourceWidth;
      destHeight = sourceHeight;
    }
    maxWidth = options.maxWidth;
    maxHeight = options.maxHeight;
    minWidth = options.minWidth;
    minHeight = options.minHeight;
    if (useCanvas && maxWidth && maxHeight && options.crop) {
      destWidth = maxWidth;
      destHeight = maxHeight;
      tmp = sourceWidth / sourceHeight - maxWidth / maxHeight;
      if (tmp < 0) {
        sourceHeight = maxHeight * sourceWidth / maxWidth;
        if (options.top === undefined && options.bottom === undefined) {
          sourceY = (height - sourceHeight) / 2;
        }
      } else if (tmp > 0) {
        sourceWidth = maxWidth * sourceHeight / maxHeight;
        if (options.left === undefined && options.right === undefined) {
          sourceX = (width - sourceWidth) / 2;
        }
      }
    } else {
      if (options.contain || options.cover) {
        minWidth = maxWidth = maxWidth || minWidth;
        minHeight = maxHeight = maxHeight || minHeight;
      }
      if (options.cover) {
        scaleDown();
        scaleUp();
      } else {
        scaleUp();
        scaleDown();
      }
    }
    if (useCanvas) {
      canvas.width = destWidth;
      canvas.height = destHeight;
      loadImage.transformCoordinates(canvas, options);
      return loadImage.renderImageToCanvas(canvas, img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, destWidth, destHeight);
    }
    img.width = destWidth;
    img.height = destHeight;
    return img;
  };
  loadImage.createObjectURL = function (file) {
    return urlAPI ? urlAPI.createObjectURL(file) : false;
  };
  loadImage.revokeObjectURL = function (url) {
    return urlAPI ? urlAPI.revokeObjectURL(url) : false;
  };
  // Loads a given File object via FileReader interface,
  // invokes the callback with the event object (load or error).
  // The result can be read via event.target.result:
  loadImage.readFile = function (file, callback, method) {
    if (window.FileReader) {
      var fileReader = new FileReader();
      fileReader.onload = fileReader.onerror = callback;
      method = method || 'readAsDataURL';
      if (fileReader[method]) {
        fileReader[method](file);
        return fileReader;
      }
    }
    return false;
  };
  if (typeof define === 'function' && define.amd) {
    define(function () {
      return loadImage;
    });
  } else {
    $.loadImage = loadImage;
  }
}(this));
/*
 * JavaScript Load Image iOS scaling fixes 1.0.3
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * iOS image scaling fixes based on
 * https://github.com/stomita/ios-imagefile-megapixel
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
/*jslint nomen: true, bitwise: true */
/*global define, window, document */
(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define(['load-image'], factory);
  } else {
    // Browser globals:
    factory(window.loadImage);
  }
}(function (loadImage) {
  'use strict';
  // Only apply fixes on the iOS platform:
  if (!window.navigator || !window.navigator.platform || !/iP(hone|od|ad)/.test(window.navigator.platform)) {
    return;
  }
  var originalRenderMethod = loadImage.renderImageToCanvas;
  // Detects subsampling in JPEG images:
  loadImage.detectSubsampling = function (img) {
    var canvas, context;
    if (img.width * img.height > 1024 * 1024) {
      // only consider mexapixel images
      canvas = document.createElement('canvas');
      canvas.width = canvas.height = 1;
      context = canvas.getContext('2d');
      context.drawImage(img, -img.width + 1, 0);
      // subsampled image becomes half smaller in rendering size.
      // check alpha channel value to confirm image is covering edge pixel or not.
      // if alpha value is 0 image is not covering, hence subsampled.
      return context.getImageData(0, 0, 1, 1).data[3] === 0;
    }
    return false;
  };
  // Detects vertical squash in JPEG images:
  loadImage.detectVerticalSquash = function (img, subsampled) {
    var naturalHeight = img.naturalHeight || img.height, canvas = document.createElement('canvas'), context = canvas.getContext('2d'), data, sy, ey, py, alpha;
    if (subsampled) {
      naturalHeight /= 2;
    }
    canvas.width = 1;
    canvas.height = naturalHeight;
    context.drawImage(img, 0, 0);
    data = context.getImageData(0, 0, 1, naturalHeight).data;
    // search image edge pixel position in case it is squashed vertically:
    sy = 0;
    ey = naturalHeight;
    py = naturalHeight;
    while (py > sy) {
      alpha = data[(py - 1) * 4 + 3];
      if (alpha === 0) {
        ey = py;
      } else {
        sy = py;
      }
      py = ey + sy >> 1;
    }
    return py / naturalHeight || 1;
  };
  // Renders image to canvas while working around iOS image scaling bugs:
  // https://github.com/blueimp/JavaScript-Load-Image/issues/13
  loadImage.renderImageToCanvas = function (canvas, img, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight) {
    if (img._type === 'image/jpeg') {
      var context = canvas.getContext('2d'), tmpCanvas = document.createElement('canvas'), tileSize = 1024, tmpContext = tmpCanvas.getContext('2d'), subsampled, vertSquashRatio, tileX, tileY;
      tmpCanvas.width = tileSize;
      tmpCanvas.height = tileSize;
      context.save();
      subsampled = loadImage.detectSubsampling(img);
      if (subsampled) {
        sourceX /= 2;
        sourceY /= 2;
        sourceWidth /= 2;
        sourceHeight /= 2;
      }
      vertSquashRatio = loadImage.detectVerticalSquash(img, subsampled);
      if (subsampled || vertSquashRatio !== 1) {
        sourceY *= vertSquashRatio;
        destWidth = Math.ceil(tileSize * destWidth / sourceWidth);
        destHeight = Math.ceil(tileSize * destHeight / sourceHeight / vertSquashRatio);
        destY = 0;
        tileY = 0;
        while (tileY < sourceHeight) {
          destX = 0;
          tileX = 0;
          while (tileX < sourceWidth) {
            tmpContext.clearRect(0, 0, tileSize, tileSize);
            tmpContext.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, -tileX, -tileY, sourceWidth, sourceHeight);
            context.drawImage(tmpCanvas, 0, 0, tileSize, tileSize, destX, destY, destWidth, destHeight);
            tileX += tileSize;
            destX += destWidth;
          }
          tileY += tileSize;
          destY += destHeight;
        }
        context.restore();
        return canvas;
      }
    }
    return originalRenderMethod(canvas, img, sourceX, sourceY, sourceWidth, sourceHeight, destX, destY, destWidth, destHeight);
  };
}));
/*
 * JavaScript Load Image Orientation 1.0.0
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
/*global define, window */
(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define(['load-image'], factory);
  } else {
    // Browser globals:
    factory(window.loadImage);
  }
}(function (loadImage) {
  'use strict';
  var originalHasCanvasOptionMethod = loadImage.hasCanvasOption;
  // This method is used to determine if the target image
  // should be a canvas element:
  loadImage.hasCanvasOption = function (options) {
    return originalHasCanvasOptionMethod(options) || options.orientation;
  };
  // Transform image orientation based on
  // the given EXIF orientation option:
  loadImage.transformCoordinates = function (canvas, options) {
    var ctx = canvas.getContext('2d'), width = canvas.width, height = canvas.height, orientation = options.orientation;
    if (!orientation) {
      return;
    }
    if (orientation > 4) {
      canvas.width = height;
      canvas.height = width;
    }
    switch (orientation) {
    case 2:
      // horizontal flip
      ctx.translate(width, 0);
      ctx.scale(-1, 1);
      break;
    case 3:
      // 180 rotate left
      ctx.translate(width, height);
      ctx.rotate(Math.PI);
      break;
    case 4:
      // vertical flip
      ctx.translate(0, height);
      ctx.scale(1, -1);
      break;
    case 5:
      // vertical flip + 90 rotate right
      ctx.rotate(0.5 * Math.PI);
      ctx.scale(1, -1);
      break;
    case 6:
      // 90 rotate right
      ctx.rotate(0.5 * Math.PI);
      ctx.translate(0, -height);
      break;
    case 7:
      // horizontal flip + 90 rotate right
      ctx.rotate(0.5 * Math.PI);
      ctx.translate(width, -height);
      ctx.scale(-1, 1);
      break;
    case 8:
      // 90 rotate left
      ctx.rotate(-0.5 * Math.PI);
      ctx.translate(-width, 0);
      break;
    }
  };
  // Transforms coordinate and dimension options
  // based on the given orientation option:
  loadImage.getTransformedOptions = function (options) {
    if (!options.orientation || options.orientation === 1) {
      return options;
    }
    var newOptions = {}, i;
    for (i in options) {
      if (options.hasOwnProperty(i)) {
        newOptions[i] = options[i];
      }
    }
    switch (options.orientation) {
    case 2:
      // horizontal flip
      newOptions.left = options.right;
      newOptions.right = options.left;
      break;
    case 3:
      // 180 rotate left
      newOptions.left = options.right;
      newOptions.top = options.bottom;
      newOptions.right = options.left;
      newOptions.bottom = options.top;
      break;
    case 4:
      // vertical flip
      newOptions.top = options.bottom;
      newOptions.bottom = options.top;
      break;
    case 5:
      // vertical flip + 90 rotate right
      newOptions.left = options.top;
      newOptions.top = options.left;
      newOptions.right = options.bottom;
      newOptions.bottom = options.right;
      break;
    case 6:
      // 90 rotate right
      newOptions.left = options.top;
      newOptions.top = options.right;
      newOptions.right = options.bottom;
      newOptions.bottom = options.left;
      break;
    case 7:
      // horizontal flip + 90 rotate right
      newOptions.left = options.bottom;
      newOptions.top = options.right;
      newOptions.right = options.top;
      newOptions.bottom = options.left;
      break;
    case 8:
      // 90 rotate left
      newOptions.left = options.bottom;
      newOptions.top = options.left;
      newOptions.right = options.top;
      newOptions.bottom = options.right;
      break;
    }
    if (options.orientation > 4) {
      newOptions.maxWidth = options.maxHeight;
      newOptions.maxHeight = options.maxWidth;
      newOptions.minWidth = options.minHeight;
      newOptions.minHeight = options.minWidth;
      newOptions.sourceWidth = options.sourceHeight;
      newOptions.sourceHeight = options.sourceWidth;
    }
    return newOptions;
  };
}));
/*
 * JavaScript Load Image Meta 1.0.2
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Image meta data handling implementation
 * based on the help and contribution of
 * Achim Sthr.
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
/*jslint continue:true */
/*global define, window, DataView, Blob, Uint8Array, console */
(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define(['load-image'], factory);
  } else {
    // Browser globals:
    factory(window.loadImage);
  }
}(function (loadImage) {
  'use strict';
  var hasblobSlice = window.Blob && (Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice);
  loadImage.blobSlice = hasblobSlice && function () {
    var slice = this.slice || this.webkitSlice || this.mozSlice;
    return slice.apply(this, arguments);
  };
  loadImage.metaDataParsers = { jpeg: { 65505: [] } };
  // Parses image meta data and calls the callback with an object argument
  // with the following properties:
  // * imageHead: The complete image head as ArrayBuffer (Uint8Array for IE10)
  // The options arguments accepts an object and supports the following properties:
  // * maxMetaDataSize: Defines the maximum number of bytes to parse.
  // * disableImageHead: Disables creating the imageHead property.
  loadImage.parseMetaData = function (file, callback, options) {
    options = options || {};
    var that = this,
      // 256 KiB should contain all EXIF/ICC/IPTC segments:
      maxMetaDataSize = options.maxMetaDataSize || 262144, data = {}, noMetaData = !(window.DataView && file && file.size >= 12 && file.type === 'image/jpeg' && loadImage.blobSlice);
    if (noMetaData || !loadImage.readFile(loadImage.blobSlice.call(file, 0, maxMetaDataSize), function (e) {
        if (e.target.error) {
          // FileReader error
          console.log(e.target.error);
          callback(data);
          return;
        }
        // Note on endianness:
        // Since the marker and length bytes in JPEG files are always
        // stored in big endian order, we can leave the endian parameter
        // of the DataView methods undefined, defaulting to big endian.
        var buffer = e.target.result, dataView = new DataView(buffer), offset = 2, maxOffset = dataView.byteLength - 4, headLength = offset, markerBytes, markerLength, parsers, i;
        // Check for the JPEG marker (0xffd8):
        if (dataView.getUint16(0) === 65496) {
          while (offset < maxOffset) {
            markerBytes = dataView.getUint16(offset);
            // Search for APPn (0xffeN) and COM (0xfffe) markers,
            // which contain application-specific meta-data like
            // Exif, ICC and IPTC data and text comments:
            if (markerBytes >= 65504 && markerBytes <= 65519 || markerBytes === 65534) {
              // The marker bytes (2) are always followed by
              // the length bytes (2), indicating the length of the
              // marker segment, which includes the length bytes,
              // but not the marker bytes, so we add 2:
              markerLength = dataView.getUint16(offset + 2) + 2;
              if (offset + markerLength > dataView.byteLength) {
                console.log('Invalid meta data: Invalid segment size.');
                break;
              }
              parsers = loadImage.metaDataParsers.jpeg[markerBytes];
              if (parsers) {
                for (i = 0; i < parsers.length; i += 1) {
                  parsers[i].call(that, dataView, offset, markerLength, data, options);
                }
              }
              offset += markerLength;
              headLength = offset;
            } else {
              // Not an APPn or COM marker, probably safe to
              // assume that this is the end of the meta data
              break;
            }
          }
          // Meta length must be longer than JPEG marker (2)
          // plus APPn marker (2), followed by length bytes (2):
          if (!options.disableImageHead && headLength > 6) {
            if (buffer.slice) {
              data.imageHead = buffer.slice(0, headLength);
            } else {
              // Workaround for IE10, which does not yet
              // support ArrayBuffer.slice:
              data.imageHead = new Uint8Array(buffer).subarray(0, headLength);
            }
          }
        } else {
          console.log('Invalid JPEG file: Missing JPEG marker.');
        }
        callback(data);
      }, 'readAsArrayBuffer')) {
      callback(data);
    }
  };
}));
/*
 * JavaScript Load Image Exif Parser 1.0.0
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
/*jslint unparam: true */
/*global define, window, console */
(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define([
      'load-image',
      'load-image-meta'
    ], factory);
  } else {
    // Browser globals:
    factory(window.loadImage);
  }
}(function (loadImage) {
  'use strict';
  loadImage.ExifMap = function () {
    return this;
  };
  loadImage.ExifMap.prototype.map = { 'Orientation': 274 };
  loadImage.ExifMap.prototype.get = function (id) {
    return this[id] || this[this.map[id]];
  };
  loadImage.getExifThumbnail = function (dataView, offset, length) {
    var hexData, i, b;
    if (!length || offset + length > dataView.byteLength) {
      console.log('Invalid Exif data: Invalid thumbnail data.');
      return;
    }
    hexData = [];
    for (i = 0; i < length; i += 1) {
      b = dataView.getUint8(offset + i);
      hexData.push((b < 16 ? '0' : '') + b.toString(16));
    }
    return 'data:image/jpeg,%' + hexData.join('%');
  };
  loadImage.exifTagTypes = {
    1: {
      getValue: function (dataView, dataOffset) {
        return dataView.getUint8(dataOffset);
      },
      size: 1
    },
    2: {
      getValue: function (dataView, dataOffset) {
        return String.fromCharCode(dataView.getUint8(dataOffset));
      },
      size: 1,
      ascii: true
    },
    3: {
      getValue: function (dataView, dataOffset, littleEndian) {
        return dataView.getUint16(dataOffset, littleEndian);
      },
      size: 2
    },
    4: {
      getValue: function (dataView, dataOffset, littleEndian) {
        return dataView.getUint32(dataOffset, littleEndian);
      },
      size: 4
    },
    5: {
      getValue: function (dataView, dataOffset, littleEndian) {
        return dataView.getUint32(dataOffset, littleEndian) / dataView.getUint32(dataOffset + 4, littleEndian);
      },
      size: 8
    },
    9: {
      getValue: function (dataView, dataOffset, littleEndian) {
        return dataView.getInt32(dataOffset, littleEndian);
      },
      size: 4
    },
    10: {
      getValue: function (dataView, dataOffset, littleEndian) {
        return dataView.getInt32(dataOffset, littleEndian) / dataView.getInt32(dataOffset + 4, littleEndian);
      },
      size: 8
    }
  };
  // undefined, 8-bit byte, value depending on field:
  loadImage.exifTagTypes[7] = loadImage.exifTagTypes[1];
  loadImage.getExifValue = function (dataView, tiffOffset, offset, type, length, littleEndian) {
    var tagType = loadImage.exifTagTypes[type], tagSize, dataOffset, values, i, str, c;
    if (!tagType) {
      console.log('Invalid Exif data: Invalid tag type.');
      return;
    }
    tagSize = tagType.size * length;
    // Determine if the value is contained in the dataOffset bytes,
    // or if the value at the dataOffset is a pointer to the actual data:
    dataOffset = tagSize > 4 ? tiffOffset + dataView.getUint32(offset + 8, littleEndian) : offset + 8;
    if (dataOffset + tagSize > dataView.byteLength) {
      console.log('Invalid Exif data: Invalid data offset.');
      return;
    }
    if (length === 1) {
      return tagType.getValue(dataView, dataOffset, littleEndian);
    }
    values = [];
    for (i = 0; i < length; i += 1) {
      values[i] = tagType.getValue(dataView, dataOffset + i * tagType.size, littleEndian);
    }
    if (tagType.ascii) {
      str = '';
      // Concatenate the chars:
      for (i = 0; i < values.length; i += 1) {
        c = values[i];
        // Ignore the terminating NULL byte(s):
        if (c === '\0') {
          break;
        }
        str += c;
      }
      return str;
    }
    return values;
  };
  loadImage.parseExifTag = function (dataView, tiffOffset, offset, littleEndian, data) {
    var tag = dataView.getUint16(offset, littleEndian);
    data.exif[tag] = loadImage.getExifValue(dataView, tiffOffset, offset, dataView.getUint16(offset + 2, littleEndian), dataView.getUint32(offset + 4, littleEndian), littleEndian);
  };
  loadImage.parseExifTags = function (dataView, tiffOffset, dirOffset, littleEndian, data) {
    var tagsNumber, dirEndOffset, i;
    if (dirOffset + 6 > dataView.byteLength) {
      console.log('Invalid Exif data: Invalid directory offset.');
      return;
    }
    tagsNumber = dataView.getUint16(dirOffset, littleEndian);
    dirEndOffset = dirOffset + 2 + 12 * tagsNumber;
    if (dirEndOffset + 4 > dataView.byteLength) {
      console.log('Invalid Exif data: Invalid directory size.');
      return;
    }
    for (i = 0; i < tagsNumber; i += 1) {
      this.parseExifTag(dataView, tiffOffset, dirOffset + 2 + 12 * i, littleEndian, data);
    }
    // Return the offset to the next directory:
    return dataView.getUint32(dirEndOffset, littleEndian);
  };
  loadImage.parseExifData = function (dataView, offset, length, data, options) {
    if (options.disableExif) {
      return;
    }
    var tiffOffset = offset + 10, littleEndian, dirOffset, thumbnailData;
    // Check for the ASCII code for "Exif" (0x45786966):
    if (dataView.getUint32(offset + 4) !== 1165519206) {
      // No Exif data, might be XMP data instead
      return;
    }
    if (tiffOffset + 8 > dataView.byteLength) {
      console.log('Invalid Exif data: Invalid segment size.');
      return;
    }
    // Check for the two null bytes:
    if (dataView.getUint16(offset + 8) !== 0) {
      console.log('Invalid Exif data: Missing byte alignment offset.');
      return;
    }
    // Check the byte alignment:
    switch (dataView.getUint16(tiffOffset)) {
    case 18761:
      littleEndian = true;
      break;
    case 19789:
      littleEndian = false;
      break;
    default:
      console.log('Invalid Exif data: Invalid byte alignment marker.');
      return;
    }
    // Check for the TIFF tag marker (0x002A):
    if (dataView.getUint16(tiffOffset + 2, littleEndian) !== 42) {
      console.log('Invalid Exif data: Missing TIFF marker.');
      return;
    }
    // Retrieve the directory offset bytes, usually 0x00000008 or 8 decimal:
    dirOffset = dataView.getUint32(tiffOffset + 4, littleEndian);
    // Create the exif object to store the tags:
    data.exif = new loadImage.ExifMap();
    // Parse the tags of the main image directory and retrieve the
    // offset to the next directory, usually the thumbnail directory:
    dirOffset = loadImage.parseExifTags(dataView, tiffOffset, tiffOffset + dirOffset, littleEndian, data);
    if (dirOffset && !options.disableExifThumbnail) {
      thumbnailData = { exif: {} };
      dirOffset = loadImage.parseExifTags(dataView, tiffOffset, tiffOffset + dirOffset, littleEndian, thumbnailData);
      // Check for JPEG Thumbnail offset:
      if (thumbnailData.exif[513]) {
        data.exif.Thumbnail = loadImage.getExifThumbnail(dataView, tiffOffset + thumbnailData.exif[513], thumbnailData.exif[514]);
      }
    }
    // Check for Exif Sub IFD Pointer:
    if (data.exif[34665] && !options.disableExifSub) {
      loadImage.parseExifTags(dataView, tiffOffset, tiffOffset + data.exif[34665], littleEndian, data);
    }
    // Check for GPS Info IFD Pointer:
    if (data.exif[34853] && !options.disableExifGps) {
      loadImage.parseExifTags(dataView, tiffOffset, tiffOffset + data.exif[34853], littleEndian, data);
    }
  };
  // Registers the Exif parser for the APP1 JPEG meta data segment:
  loadImage.metaDataParsers.jpeg[65505].push(loadImage.parseExifData);  // Adds the following properties to the parseMetaData callback data:
                                                                        // * exif: The exif tags, parsed by the parseExifData method
                                                                        // Adds the following options to the parseMetaData method:
                                                                        // * disableExif: Disables Exif parsing.
                                                                        // * disableExifThumbnail: Disables parsing of the Exif Thumbnail.
                                                                        // * disableExifSub: Disables parsing of the Exif Sub IFD.
                                                                        // * disableExifGps: Disables parsing of the Exif GPS Info IFD.
}));
/*
 * JavaScript Load Image Exif Map 1.0.2
 * https://github.com/blueimp/JavaScript-Load-Image
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Exif tags mapping based on
 * https://github.com/jseidelin/exif-js
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
/*global define, window */
(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define([
      'load-image',
      'load-image-exif'
    ], factory);
  } else {
    // Browser globals:
    factory(window.loadImage);
  }
}(function (loadImage) {
  'use strict';
  loadImage.ExifMap.prototype.tags = {
    256: 'ImageWidth',
    257: 'ImageHeight',
    34665: 'ExifIFDPointer',
    34853: 'GPSInfoIFDPointer',
    40965: 'InteroperabilityIFDPointer',
    258: 'BitsPerSample',
    259: 'Compression',
    262: 'PhotometricInterpretation',
    274: 'Orientation',
    277: 'SamplesPerPixel',
    284: 'PlanarConfiguration',
    530: 'YCbCrSubSampling',
    531: 'YCbCrPositioning',
    282: 'XResolution',
    283: 'YResolution',
    296: 'ResolutionUnit',
    273: 'StripOffsets',
    278: 'RowsPerStrip',
    279: 'StripByteCounts',
    513: 'JPEGInterchangeFormat',
    514: 'JPEGInterchangeFormatLength',
    301: 'TransferFunction',
    318: 'WhitePoint',
    319: 'PrimaryChromaticities',
    529: 'YCbCrCoefficients',
    532: 'ReferenceBlackWhite',
    306: 'DateTime',
    270: 'ImageDescription',
    271: 'Make',
    272: 'Model',
    305: 'Software',
    315: 'Artist',
    33432: 'Copyright',
    36864: 'ExifVersion',
    40960: 'FlashpixVersion',
    40961: 'ColorSpace',
    40962: 'PixelXDimension',
    40963: 'PixelYDimension',
    42240: 'Gamma',
    37121: 'ComponentsConfiguration',
    37122: 'CompressedBitsPerPixel',
    37500: 'MakerNote',
    37510: 'UserComment',
    40964: 'RelatedSoundFile',
    36867: 'DateTimeOriginal',
    36868: 'DateTimeDigitized',
    37520: 'SubSecTime',
    37521: 'SubSecTimeOriginal',
    37522: 'SubSecTimeDigitized',
    33434: 'ExposureTime',
    33437: 'FNumber',
    34850: 'ExposureProgram',
    34852: 'SpectralSensitivity',
    34855: 'PhotographicSensitivity',
    34856: 'OECF',
    34864: 'SensitivityType',
    34865: 'StandardOutputSensitivity',
    34866: 'RecommendedExposureIndex',
    34867: 'ISOSpeed',
    34868: 'ISOSpeedLatitudeyyy',
    34869: 'ISOSpeedLatitudezzz',
    37377: 'ShutterSpeedValue',
    37378: 'ApertureValue',
    37379: 'BrightnessValue',
    37380: 'ExposureBias',
    37381: 'MaxApertureValue',
    37382: 'SubjectDistance',
    37383: 'MeteringMode',
    37384: 'LightSource',
    37385: 'Flash',
    37396: 'SubjectArea',
    37386: 'FocalLength',
    41483: 'FlashEnergy',
    41484: 'SpatialFrequencyResponse',
    41486: 'FocalPlaneXResolution',
    41487: 'FocalPlaneYResolution',
    41488: 'FocalPlaneResolutionUnit',
    41492: 'SubjectLocation',
    41493: 'ExposureIndex',
    41495: 'SensingMethod',
    41728: 'FileSource',
    41729: 'SceneType',
    41730: 'CFAPattern',
    41985: 'CustomRendered',
    41986: 'ExposureMode',
    41987: 'WhiteBalance',
    41988: 'DigitalZoomRatio',
    41989: 'FocalLengthIn35mmFilm',
    41990: 'SceneCaptureType',
    41991: 'GainControl',
    41992: 'Contrast',
    41993: 'Saturation',
    41994: 'Sharpness',
    41995: 'DeviceSettingDescription',
    41996: 'SubjectDistanceRange',
    42016: 'ImageUniqueID',
    42032: 'CameraOwnerName',
    42033: 'BodySerialNumber',
    42034: 'LensSpecification',
    42035: 'LensMake',
    42036: 'LensModel',
    42037: 'LensSerialNumber',
    0: 'GPSVersionID',
    1: 'GPSLatitudeRef',
    2: 'GPSLatitude',
    3: 'GPSLongitudeRef',
    4: 'GPSLongitude',
    5: 'GPSAltitudeRef',
    6: 'GPSAltitude',
    7: 'GPSTimeStamp',
    8: 'GPSSatellites',
    9: 'GPSStatus',
    10: 'GPSMeasureMode',
    11: 'GPSDOP',
    12: 'GPSSpeedRef',
    13: 'GPSSpeed',
    14: 'GPSTrackRef',
    15: 'GPSTrack',
    16: 'GPSImgDirectionRef',
    17: 'GPSImgDirection',
    18: 'GPSMapDatum',
    19: 'GPSDestLatitudeRef',
    20: 'GPSDestLatitude',
    21: 'GPSDestLongitudeRef',
    22: 'GPSDestLongitude',
    23: 'GPSDestBearingRef',
    24: 'GPSDestBearing',
    25: 'GPSDestDistanceRef',
    26: 'GPSDestDistance',
    27: 'GPSProcessingMethod',
    28: 'GPSAreaInformation',
    29: 'GPSDateStamp',
    30: 'GPSDifferential',
    31: 'GPSHPositioningError'
  };
  loadImage.ExifMap.prototype.stringValues = {
    ExposureProgram: {
      0: 'Undefined',
      1: 'Manual',
      2: 'Normal program',
      3: 'Aperture priority',
      4: 'Shutter priority',
      5: 'Creative program',
      6: 'Action program',
      7: 'Portrait mode',
      8: 'Landscape mode'
    },
    MeteringMode: {
      0: 'Unknown',
      1: 'Average',
      2: 'CenterWeightedAverage',
      3: 'Spot',
      4: 'MultiSpot',
      5: 'Pattern',
      6: 'Partial',
      255: 'Other'
    },
    LightSource: {
      0: 'Unknown',
      1: 'Daylight',
      2: 'Fluorescent',
      3: 'Tungsten (incandescent light)',
      4: 'Flash',
      9: 'Fine weather',
      10: 'Cloudy weather',
      11: 'Shade',
      12: 'Daylight fluorescent (D 5700 - 7100K)',
      13: 'Day white fluorescent (N 4600 - 5400K)',
      14: 'Cool white fluorescent (W 3900 - 4500K)',
      15: 'White fluorescent (WW 3200 - 3700K)',
      17: 'Standard light A',
      18: 'Standard light B',
      19: 'Standard light C',
      20: 'D55',
      21: 'D65',
      22: 'D75',
      23: 'D50',
      24: 'ISO studio tungsten',
      255: 'Other'
    },
    Flash: {
      0: 'Flash did not fire',
      1: 'Flash fired',
      5: 'Strobe return light not detected',
      7: 'Strobe return light detected',
      9: 'Flash fired, compulsory flash mode',
      13: 'Flash fired, compulsory flash mode, return light not detected',
      15: 'Flash fired, compulsory flash mode, return light detected',
      16: 'Flash did not fire, compulsory flash mode',
      24: 'Flash did not fire, auto mode',
      25: 'Flash fired, auto mode',
      29: 'Flash fired, auto mode, return light not detected',
      31: 'Flash fired, auto mode, return light detected',
      32: 'No flash function',
      65: 'Flash fired, red-eye reduction mode',
      69: 'Flash fired, red-eye reduction mode, return light not detected',
      71: 'Flash fired, red-eye reduction mode, return light detected',
      73: 'Flash fired, compulsory flash mode, red-eye reduction mode',
      77: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',
      79: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',
      89: 'Flash fired, auto mode, red-eye reduction mode',
      93: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',
      95: 'Flash fired, auto mode, return light detected, red-eye reduction mode'
    },
    SensingMethod: {
      1: 'Undefined',
      2: 'One-chip color area sensor',
      3: 'Two-chip color area sensor',
      4: 'Three-chip color area sensor',
      5: 'Color sequential area sensor',
      7: 'Trilinear sensor',
      8: 'Color sequential linear sensor'
    },
    SceneCaptureType: {
      0: 'Standard',
      1: 'Landscape',
      2: 'Portrait',
      3: 'Night scene'
    },
    SceneType: { 1: 'Directly photographed' },
    CustomRendered: {
      0: 'Normal process',
      1: 'Custom process'
    },
    WhiteBalance: {
      0: 'Auto white balance',
      1: 'Manual white balance'
    },
    GainControl: {
      0: 'None',
      1: 'Low gain up',
      2: 'High gain up',
      3: 'Low gain down',
      4: 'High gain down'
    },
    Contrast: {
      0: 'Normal',
      1: 'Soft',
      2: 'Hard'
    },
    Saturation: {
      0: 'Normal',
      1: 'Low saturation',
      2: 'High saturation'
    },
    Sharpness: {
      0: 'Normal',
      1: 'Soft',
      2: 'Hard'
    },
    SubjectDistanceRange: {
      0: 'Unknown',
      1: 'Macro',
      2: 'Close view',
      3: 'Distant view'
    },
    FileSource: { 3: 'DSC' },
    ComponentsConfiguration: {
      0: '',
      1: 'Y',
      2: 'Cb',
      3: 'Cr',
      4: 'R',
      5: 'G',
      6: 'B'
    },
    Orientation: {
      1: 'top-left',
      2: 'top-right',
      3: 'bottom-right',
      4: 'bottom-left',
      5: 'left-top',
      6: 'right-top',
      7: 'right-bottom',
      8: 'left-bottom'
    }
  };
  loadImage.ExifMap.prototype.getText = function (id) {
    var value = this.get(id);
    switch (id) {
    case 'LightSource':
    case 'Flash':
    case 'MeteringMode':
    case 'ExposureProgram':
    case 'SensingMethod':
    case 'SceneCaptureType':
    case 'SceneType':
    case 'CustomRendered':
    case 'WhiteBalance':
    case 'GainControl':
    case 'Contrast':
    case 'Saturation':
    case 'Sharpness':
    case 'SubjectDistanceRange':
    case 'FileSource':
    case 'Orientation':
      return this.stringValues[id][value];
    case 'ExifVersion':
    case 'FlashpixVersion':
      return String.fromCharCode(value[0], value[1], value[2], value[3]);
    case 'ComponentsConfiguration':
      return this.stringValues[id][value[0]] + this.stringValues[id][value[1]] + this.stringValues[id][value[2]] + this.stringValues[id][value[3]];
    case 'GPSVersionID':
      return value[0] + '.' + value[1] + '.' + value[2] + '.' + value[3];
    }
    return String(value);
  };
  (function (exifMapPrototype) {
    var tags = exifMapPrototype.tags, map = exifMapPrototype.map, prop;
    // Map the tag names to tags:
    for (prop in tags) {
      if (tags.hasOwnProperty(prop)) {
        map[tags[prop]] = prop;
      }
    }
  }(loadImage.ExifMap.prototype));
  loadImage.ExifMap.prototype.getAll = function () {
    var map = {}, prop, id;
    for (prop in this) {
      if (this.hasOwnProperty(prop)) {
        id = this.tags[prop];
        if (id) {
          map[id] = this.getText(id);
        }
      }
    }
    return map;
  };
}));
/*
 * JavaScript Canvas to Blob 2.0.5
 * https://github.com/blueimp/JavaScript-Canvas-to-Blob
 *
 * Copyright 2012, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 *
 * Based on stackoverflow user Stoive's code snippet:
 * http://stackoverflow.com/q/4998908
 */
/*jslint nomen: true, regexp: true */
/*global window, atob, Blob, ArrayBuffer, Uint8Array, define */
(function (window) {
  'use strict';
  var CanvasPrototype = window.HTMLCanvasElement && window.HTMLCanvasElement.prototype, hasBlobConstructor = window.Blob && function () {
      try {
        return Boolean(new Blob());
      } catch (e) {
        return false;
      }
    }(), hasArrayBufferViewSupport = hasBlobConstructor && window.Uint8Array && function () {
      try {
        return new Blob([new Uint8Array(100)]).size === 100;
      } catch (e) {
        return false;
      }
    }(), BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder, dataURLtoBlob = (hasBlobConstructor || BlobBuilder) && window.atob && window.ArrayBuffer && window.Uint8Array && function (dataURI) {
      var byteString, arrayBuffer, intArray, i, mimeString, bb;
      if (dataURI.split(',')[0].indexOf('base64') >= 0) {
        // Convert base64 to raw binary data held in a string:
        byteString = atob(dataURI.split(',')[1]);
      } else {
        // Convert base64/URLEncoded data component to raw binary data:
        byteString = decodeURIComponent(dataURI.split(',')[1]);
      }
      // Write the bytes of the string to an ArrayBuffer:
      arrayBuffer = new ArrayBuffer(byteString.length);
      intArray = new Uint8Array(arrayBuffer);
      for (i = 0; i < byteString.length; i += 1) {
        intArray[i] = byteString.charCodeAt(i);
      }
      // Separate out the mime component:
      mimeString = dataURI.split(',')[0].split(':')[1].split(';')[0];
      // Write the ArrayBuffer (or ArrayBufferView) to a blob:
      if (hasBlobConstructor) {
        return new Blob([hasArrayBufferViewSupport ? intArray : arrayBuffer], { type: mimeString });
      }
      bb = new BlobBuilder();
      bb.append(arrayBuffer);
      return bb.getBlob(mimeString);
    };
  if (window.HTMLCanvasElement && !CanvasPrototype.toBlob) {
    if (CanvasPrototype.mozGetAsFile) {
      CanvasPrototype.toBlob = function (callback, type, quality) {
        if (quality && CanvasPrototype.toDataURL && dataURLtoBlob) {
          callback(dataURLtoBlob(this.toDataURL(type, quality)));
        } else {
          callback(this.mozGetAsFile('blob', type));
        }
      };
    } else if (CanvasPrototype.toDataURL && dataURLtoBlob) {
      CanvasPrototype.toBlob = function (callback, type, quality) {
        callback(dataURLtoBlob(this.toDataURL(type, quality)));
      };
    }
  }
  if (typeof define === 'function' && define.amd) {
    define(function () {
      return dataURLtoBlob;
    });
  } else {
    window.dataURLtoBlob = dataURLtoBlob;
  }
}(this));
/*
 * jQuery postMessage Transport Plugin 1.1.1
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
/* global define, window, document */
(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define(['jquery'], factory);
  } else {
    // Browser globals:
    factory(window.jQuery);
  }
}(function ($) {
  'use strict';
  var counter = 0, names = [
      'accepts',
      'cache',
      'contents',
      'contentType',
      'crossDomain',
      'data',
      'dataType',
      'headers',
      'ifModified',
      'mimeType',
      'password',
      'processData',
      'timeout',
      'traditional',
      'type',
      'url',
      'username'
    ], convert = function (p) {
      return p;
    };
  $.ajaxSetup({
    converters: {
      'postmessage text': convert,
      'postmessage json': convert,
      'postmessage html': convert
    }
  });
  $.ajaxTransport('postmessage', function (options) {
    if (options.postMessage && window.postMessage) {
      var iframe, loc = $('<a>').prop('href', options.postMessage)[0], target = loc.protocol + '//' + loc.host, xhrUpload = options.xhr().upload;
      return {
        send: function (_, completeCallback) {
          counter += 1;
          var message = { id: 'postmessage-transport-' + counter }, eventName = 'message.' + message.id;
          iframe = $('<iframe style="display:none;" src="' + options.postMessage + '" name="' + message.id + '"></iframe>').bind('load', function () {
            $.each(names, function (i, name) {
              message[name] = options[name];
            });
            message.dataType = message.dataType.replace('postmessage ', '');
            $(window).bind(eventName, function (e) {
              e = e.originalEvent;
              var data = e.data, ev;
              if (e.origin === target && data.id === message.id) {
                if (data.type === 'progress') {
                  ev = document.createEvent('Event');
                  ev.initEvent(data.type, false, true);
                  $.extend(ev, data);
                  xhrUpload.dispatchEvent(ev);
                } else {
                  completeCallback(data.status, data.statusText, { postmessage: data.result }, data.headers);
                  iframe.remove();
                  $(window).unbind(eventName);
                }
              }
            });
            iframe[0].contentWindow.postMessage(message, target);
          }).appendTo(document.body);
        },
        abort: function () {
          if (iframe) {
            iframe.remove();
          }
        }
      };
    }
  });
}));
/*
 * jQuery XDomainRequest Transport Plugin 1.1.3
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 *
 * Based on Julian Aubourg's ajaxHooks xdr.js:
 * https://github.com/jaubourg/ajaxHooks/
 */
/* global define, window, XDomainRequest */
(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define(['jquery'], factory);
  } else {
    // Browser globals:
    factory(window.jQuery);
  }
}(function ($) {
  'use strict';
  if (window.XDomainRequest && !$.support.cors) {
    $.ajaxTransport(function (s) {
      if (s.crossDomain && s.async) {
        if (s.timeout) {
          s.xdrTimeout = s.timeout;
          delete s.timeout;
        }
        var xdr;
        return {
          send: function (headers, completeCallback) {
            var addParamChar = /\?/.test(s.url) ? '&' : '?';
            function callback(status, statusText, responses, responseHeaders) {
              xdr.onload = xdr.onerror = xdr.ontimeout = $.noop;
              xdr = null;
              completeCallback(status, statusText, responses, responseHeaders);
            }
            xdr = new XDomainRequest();
            // XDomainRequest only supports GET and POST:
            if (s.type === 'DELETE') {
              s.url = s.url + addParamChar + '_method=DELETE';
              s.type = 'POST';
            } else if (s.type === 'PUT') {
              s.url = s.url + addParamChar + '_method=PUT';
              s.type = 'POST';
            } else if (s.type === 'PATCH') {
              s.url = s.url + addParamChar + '_method=PATCH';
              s.type = 'POST';
            }
            xdr.open(s.type, s.url);
            xdr.onload = function () {
              callback(200, 'OK', { text: xdr.responseText }, 'Content-Type: ' + xdr.contentType);
            };
            xdr.onerror = function () {
              callback(404, 'Not Found');
            };
            if (s.xdrTimeout) {
              xdr.ontimeout = function () {
                callback(0, 'timeout');
              };
              xdr.timeout = s.xdrTimeout;
            }
            xdr.send(s.hasContent && s.data || null);
          },
          abort: function () {
            if (xdr) {
              xdr.onerror = $.noop();
              xdr.abort();
            }
          }
        };
      }
    });
  }
}));
/*!
 * jQuery UI Widget 1.10.4+amd
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/jQuery.widget/
 */
(function (factory) {
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define(['jquery'], factory);
  } else {
    // Browser globals:
    factory(jQuery);
  }
}(function ($, undefined) {
  var uuid = 0, slice = Array.prototype.slice, _cleanData = $.cleanData;
  $.cleanData = function (elems) {
    for (var i = 0, elem; (elem = elems[i]) != null; i++) {
      try {
        $(elem).triggerHandler('remove');  // http://bugs.jquery.com/ticket/8235
      } catch (e) {
      }
    }
    _cleanData(elems);
  };
  $.widget = function (name, base, prototype) {
    var fullName, existingConstructor, constructor, basePrototype,
      // proxiedPrototype allows the provided prototype to remain unmodified
      // so that it can be used as a mixin for multiple widgets (#8876)
      proxiedPrototype = {}, namespace = name.split('.')[0];
    name = name.split('.')[1];
    fullName = namespace + '-' + name;
    if (!prototype) {
      prototype = base;
      base = $.Widget;
    }
    // create selector for plugin
    $.expr[':'][fullName.toLowerCase()] = function (elem) {
      return !!$.data(elem, fullName);
    };
    $[namespace] = $[namespace] || {};
    existingConstructor = $[namespace][name];
    constructor = $[namespace][name] = function (options, element) {
      // allow instantiation without "new" keyword
      if (!this._createWidget) {
        return new constructor(options, element);
      }
      // allow instantiation without initializing for simple inheritance
      // must use "new" keyword (the code above always passes args)
      if (arguments.length) {
        this._createWidget(options, element);
      }
    };
    // extend with the existing constructor to carry over any static properties
    $.extend(constructor, existingConstructor, {
      version: prototype.version,
      _proto: $.extend({}, prototype),
      _childConstructors: []
    });
    basePrototype = new base();
    // we need to make the options hash a property directly on the new instance
    // otherwise we'll modify the options hash on the prototype that we're
    // inheriting from
    basePrototype.options = $.widget.extend({}, basePrototype.options);
    $.each(prototype, function (prop, value) {
      if (!$.isFunction(value)) {
        proxiedPrototype[prop] = value;
        return;
      }
      proxiedPrototype[prop] = function () {
        var _super = function () {
            return base.prototype[prop].apply(this, arguments);
          }, _superApply = function (args) {
            return base.prototype[prop].apply(this, args);
          };
        return function () {
          var __super = this._super, __superApply = this._superApply, returnValue;
          this._super = _super;
          this._superApply = _superApply;
          returnValue = value.apply(this, arguments);
          this._super = __super;
          this._superApply = __superApply;
          return returnValue;
        };
      }();
    });
    constructor.prototype = $.widget.extend(basePrototype, { widgetEventPrefix: existingConstructor ? basePrototype.widgetEventPrefix || name : name }, proxiedPrototype, {
      constructor: constructor,
      namespace: namespace,
      widgetName: name,
      widgetFullName: fullName
    });
    // If this widget is being redefined then we need to find all widgets that
    // are inheriting from it and redefine all of them so that they inherit from
    // the new version of this widget. We're essentially trying to replace one
    // level in the prototype chain.
    if (existingConstructor) {
      $.each(existingConstructor._childConstructors, function (i, child) {
        var childPrototype = child.prototype;
        // redefine the child widget using the same prototype that was
        // originally used, but inherit from the new version of the base
        $.widget(childPrototype.namespace + '.' + childPrototype.widgetName, constructor, child._proto);
      });
      // remove the list of existing child constructors from the old constructor
      // so the old child constructors can be garbage collected
      delete existingConstructor._childConstructors;
    } else {
      base._childConstructors.push(constructor);
    }
    $.widget.bridge(name, constructor);
  };
  $.widget.extend = function (target) {
    var input = slice.call(arguments, 1), inputIndex = 0, inputLength = input.length, key, value;
    for (; inputIndex < inputLength; inputIndex++) {
      for (key in input[inputIndex]) {
        value = input[inputIndex][key];
        if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
          // Clone objects
          if ($.isPlainObject(value)) {
            target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : $.widget.extend({}, value);  // Copy everything else by reference
          } else {
            target[key] = value;
          }
        }
      }
    }
    return target;
  };
  $.widget.bridge = function (name, object) {
    var fullName = object.prototype.widgetFullName || name;
    $.fn[name] = function (options) {
      var isMethodCall = typeof options === 'string', args = slice.call(arguments, 1), returnValue = this;
      // allow multiple hashes to be passed on init
      options = !isMethodCall && args.length ? $.widget.extend.apply(null, [options].concat(args)) : options;
      if (isMethodCall) {
        this.each(function () {
          var methodValue, instance = $.data(this, fullName);
          if (!instance) {
            return $.error('cannot call methods on ' + name + ' prior to initialization; ' + 'attempted to call method \'' + options + '\'');
          }
          if (!$.isFunction(instance[options]) || options.charAt(0) === '_') {
            return $.error('no such method \'' + options + '\' for ' + name + ' widget instance');
          }
          methodValue = instance[options].apply(instance, args);
          if (methodValue !== instance && methodValue !== undefined) {
            returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
            return false;
          }
        });
      } else {
        this.each(function () {
          var instance = $.data(this, fullName);
          if (instance) {
            instance.option(options || {})._init();
          } else {
            $.data(this, fullName, new object(options, this));
          }
        });
      }
      return returnValue;
    };
  };
  $.Widget = function () {
  };
  $.Widget._childConstructors = [];
  $.Widget.prototype = {
    widgetName: 'widget',
    widgetEventPrefix: '',
    defaultElement: '<div>',
    options: {
      disabled: false,
      create: null
    },
    _createWidget: function (options, element) {
      element = $(element || this.defaultElement || this)[0];
      this.element = $(element);
      this.uuid = uuid++;
      this.eventNamespace = '.' + this.widgetName + this.uuid;
      this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);
      this.bindings = $();
      this.hoverable = $();
      this.focusable = $();
      if (element !== this) {
        $.data(element, this.widgetFullName, this);
        this._on(true, this.element, {
          remove: function (event) {
            if (event.target === element) {
              this.destroy();
            }
          }
        });
        this.document = $(element.style ? element.ownerDocument : element.document || element);
        this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
      }
      this._create();
      this._trigger('create', null, this._getCreateEventData());
      this._init();
    },
    _getCreateOptions: $.noop,
    _getCreateEventData: $.noop,
    _create: $.noop,
    _init: $.noop,
    destroy: function () {
      this._destroy();
      // we can probably remove the unbind calls in 2.0
      // all event bindings should go through this._on()
      this.element.unbind(this.eventNamespace).removeData(this.widgetName).removeData(this.widgetFullName).removeData($.camelCase(this.widgetFullName));
      this.widget().unbind(this.eventNamespace).removeAttr('aria-disabled').removeClass(this.widgetFullName + '-disabled ' + 'ui-state-disabled');
      // clean up events and states
      this.bindings.unbind(this.eventNamespace);
      this.hoverable.removeClass('ui-state-hover');
      this.focusable.removeClass('ui-state-focus');
    },
    _destroy: $.noop,
    widget: function () {
      return this.element;
    },
    option: function (key, value) {
      var options = key, parts, curOption, i;
      if (arguments.length === 0) {
        // don't return a reference to the internal hash
        return $.widget.extend({}, this.options);
      }
      if (typeof key === 'string') {
        // handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
        options = {};
        parts = key.split('.');
        key = parts.shift();
        if (parts.length) {
          curOption = options[key] = $.widget.extend({}, this.options[key]);
          for (i = 0; i < parts.length - 1; i++) {
            curOption[parts[i]] = curOption[parts[i]] || {};
            curOption = curOption[parts[i]];
          }
          key = parts.pop();
          if (arguments.length === 1) {
            return curOption[key] === undefined ? null : curOption[key];
          }
          curOption[key] = value;
        } else {
          if (arguments.length === 1) {
            return this.options[key] === undefined ? null : this.options[key];
          }
          options[key] = value;
        }
      }
      this._setOptions(options);
      return this;
    },
    _setOptions: function (options) {
      var key;
      for (key in options) {
        this._setOption(key, options[key]);
      }
      return this;
    },
    _setOption: function (key, value) {
      this.options[key] = value;
      if (key === 'disabled') {
        this.widget().toggleClass(this.widgetFullName + '-disabled ui-state-disabled', !!value).attr('aria-disabled', value);
        this.hoverable.removeClass('ui-state-hover');
        this.focusable.removeClass('ui-state-focus');
      }
      return this;
    },
    enable: function () {
      return this._setOption('disabled', false);
    },
    disable: function () {
      return this._setOption('disabled', true);
    },
    _on: function (suppressDisabledCheck, element, handlers) {
      var delegateElement, instance = this;
      // no suppressDisabledCheck flag, shuffle arguments
      if (typeof suppressDisabledCheck !== 'boolean') {
        handlers = element;
        element = suppressDisabledCheck;
        suppressDisabledCheck = false;
      }
      // no element argument, shuffle and use this.element
      if (!handlers) {
        handlers = element;
        element = this.element;
        delegateElement = this.widget();
      } else {
        // accept selectors, DOM elements
        element = delegateElement = $(element);
        this.bindings = this.bindings.add(element);
      }
      $.each(handlers, function (event, handler) {
        function handlerProxy() {
          // allow widgets to customize the disabled handling
          // - disabled as an array instead of boolean
          // - disabled class as method for disabling individual parts
          if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass('ui-state-disabled'))) {
            return;
          }
          return (typeof handler === 'string' ? instance[handler] : handler).apply(instance, arguments);
        }
        // copy the guid so direct unbinding works
        if (typeof handler !== 'string') {
          handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
        }
        var match = event.match(/^(\w+)\s*(.*)$/), eventName = match[1] + instance.eventNamespace, selector = match[2];
        if (selector) {
          delegateElement.delegate(selector, eventName, handlerProxy);
        } else {
          element.bind(eventName, handlerProxy);
        }
      });
    },
    _off: function (element, eventName) {
      eventName = (eventName || '').split(' ').join(this.eventNamespace + ' ') + this.eventNamespace;
      element.unbind(eventName).undelegate(eventName);
    },
    _delay: function (handler, delay) {
      function handlerProxy() {
        return (typeof handler === 'string' ? instance[handler] : handler).apply(instance, arguments);
      }
      var instance = this;
      return setTimeout(handlerProxy, delay || 0);
    },
    _hoverable: function (element) {
      this.hoverable = this.hoverable.add(element);
      this._on(element, {
        mouseenter: function (event) {
          $(event.currentTarget).addClass('ui-state-hover');
        },
        mouseleave: function (event) {
          $(event.currentTarget).removeClass('ui-state-hover');
        }
      });
    },
    _focusable: function (element) {
      this.focusable = this.focusable.add(element);
      this._on(element, {
        focusin: function (event) {
          $(event.currentTarget).addClass('ui-state-focus');
        },
        focusout: function (event) {
          $(event.currentTarget).removeClass('ui-state-focus');
        }
      });
    },
    _trigger: function (type, event, data) {
      var prop, orig, callback = this.options[type];
      data = data || {};
      event = $.Event(event);
      event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();
      // the original event may come from any element
      // so we need to reset the target on the new event
      event.target = this.element[0];
      // copy original event properties over to the new event
      orig = event.originalEvent;
      if (orig) {
        for (prop in orig) {
          if (!(prop in event)) {
            event[prop] = orig[prop];
          }
        }
      }
      this.element.trigger(event, data);
      return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());
    }
  };
  $.each({
    show: 'fadeIn',
    hide: 'fadeOut'
  }, function (method, defaultEffect) {
    $.Widget.prototype['_' + method] = function (element, options, callback) {
      if (typeof options === 'string') {
        options = { effect: options };
      }
      var hasOptions, effectName = !options ? method : options === true || typeof options === 'number' ? defaultEffect : options.effect || defaultEffect;
      options = options || {};
      if (typeof options === 'number') {
        options = { duration: options };
      }
      hasOptions = !$.isEmptyObject(options);
      options.complete = callback;
      if (options.delay) {
        element.delay(options.delay);
      }
      if (hasOptions && $.effects && $.effects.effect[effectName]) {
        element[method](options);
      } else if (effectName !== method && element[effectName]) {
        element[effectName](options.duration, options.easing, callback);
      } else {
        element.queue(function (next) {
          $(this)[method]();
          if (callback) {
            callback.call(element[0]);
          }
          next();
        });
      }
    };
  });
}));
/*
 * jQuery File Upload Plugin 5.40.1
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2010, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
/* jshint nomen:false */
/* global define, window, document, location, Blob, FormData */
(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define([
      'jquery',
      'jquery.ui.widget'
    ], factory);
  } else {
    // Browser globals:
    factory(window.jQuery);
  }
}(function ($) {
  'use strict';
  // Detect file input support, based on
  // http://viljamis.com/blog/2012/file-upload-support-on-mobile/
  $.support.fileInput = !(new RegExp('(Android (1\\.[0156]|2\\.[01]))' + '|(Windows Phone (OS 7|8\\.0))|(XBLWP)|(ZuneWP)|(WPDesktop)' + '|(w(eb)?OSBrowser)|(webOS)' + '|(Kindle/(1\\.0|2\\.[05]|3\\.0))').test(window.navigator.userAgent) || $('<input type="file">').prop('disabled'));
  // The FileReader API is not actually used, but works as feature detection,
  // as some Safari versions (5?) support XHR file uploads via the FormData API,
  // but not non-multipart XHR file uploads.
  // window.XMLHttpRequestUpload is not available on IE10, so we check for
  // window.ProgressEvent instead to detect XHR2 file upload capability:
  $.support.xhrFileUpload = !!(window.ProgressEvent && window.FileReader);
  $.support.xhrFormDataFileUpload = !!window.FormData;
  // Detect support for Blob slicing (required for chunked uploads):
  $.support.blobSlice = window.Blob && (Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice);
  // The fileupload widget listens for change events on file input fields defined
  // via fileInput setting and paste or drop events of the given dropZone.
  // In addition to the default jQuery Widget methods, the fileupload widget
  // exposes the "add" and "send" methods, to add or directly send files using
  // the fileupload API.
  // By default, files added via file input selection, paste, drag & drop or
  // "add" method are uploaded immediately, but it is possible to override
  // the "add" callback option to queue file uploads.
  $.widget('blueimp.fileupload', {
    options: {
      dropZone: $(document),
      pasteZone: $(document),
      fileInput: undefined,
      replaceFileInput: true,
      paramName: undefined,
      singleFileUploads: true,
      limitMultiFileUploads: undefined,
      limitMultiFileUploadSize: undefined,
      limitMultiFileUploadSizeOverhead: 512,
      sequentialUploads: false,
      limitConcurrentUploads: undefined,
      forceIframeTransport: false,
      redirect: undefined,
      redirectParamName: undefined,
      postMessage: undefined,
      multipart: true,
      maxChunkSize: undefined,
      uploadedBytes: undefined,
      recalculateProgress: true,
      progressInterval: 100,
      bitrateInterval: 500,
      autoUpload: true,
      messages: { uploadedBytes: 'Uploaded bytes exceed file size' },
      i18n: function (message, context) {
        message = this.messages[message] || message.toString();
        if (context) {
          $.each(context, function (key, value) {
            message = message.replace('{' + key + '}', value);
          });
        }
        return message;
      },
      formData: function (form) {
        return form.serializeArray();
      },
      add: function (e, data) {
        if (e.isDefaultPrevented()) {
          return false;
        }
        if (data.autoUpload || data.autoUpload !== false && $(this).fileupload('option', 'autoUpload')) {
          data.process().done(function () {
            data.submit();
          });
        }
      },
      processData: false,
      contentType: false,
      cache: false
    },
    _specialOptions: [
      'fileInput',
      'dropZone',
      'pasteZone',
      'multipart',
      'forceIframeTransport'
    ],
    _blobSlice: $.support.blobSlice && function () {
      var slice = this.slice || this.webkitSlice || this.mozSlice;
      return slice.apply(this, arguments);
    },
    _BitrateTimer: function () {
      this.timestamp = Date.now ? Date.now() : new Date().getTime();
      this.loaded = 0;
      this.bitrate = 0;
      this.getBitrate = function (now, loaded, interval) {
        var timeDiff = now - this.timestamp;
        if (!this.bitrate || !interval || timeDiff > interval) {
          this.bitrate = (loaded - this.loaded) * (1000 / timeDiff) * 8;
          this.loaded = loaded;
          this.timestamp = now;
        }
        return this.bitrate;
      };
    },
    _isXHRUpload: function (options) {
      return !options.forceIframeTransport && (!options.multipart && $.support.xhrFileUpload || $.support.xhrFormDataFileUpload);
    },
    _getFormData: function (options) {
      var formData;
      if ($.type(options.formData) === 'function') {
        return options.formData(options.form);
      }
      if ($.isArray(options.formData)) {
        return options.formData;
      }
      if ($.type(options.formData) === 'object') {
        formData = [];
        $.each(options.formData, function (name, value) {
          formData.push({
            name: name,
            value: value
          });
        });
        return formData;
      }
      return [];
    },
    _getTotal: function (files) {
      var total = 0;
      $.each(files, function (index, file) {
        total += file.size || 1;
      });
      return total;
    },
    _initProgressObject: function (obj) {
      var progress = {
          loaded: 0,
          total: 0,
          bitrate: 0
        };
      if (obj._progress) {
        $.extend(obj._progress, progress);
      } else {
        obj._progress = progress;
      }
    },
    _initResponseObject: function (obj) {
      var prop;
      if (obj._response) {
        for (prop in obj._response) {
          if (obj._response.hasOwnProperty(prop)) {
            delete obj._response[prop];
          }
        }
      } else {
        obj._response = {};
      }
    },
    _onProgress: function (e, data) {
      if (e.lengthComputable) {
        var now = Date.now ? Date.now() : new Date().getTime(), loaded;
        if (data._time && data.progressInterval && now - data._time < data.progressInterval && e.loaded !== e.total) {
          return;
        }
        data._time = now;
        loaded = Math.floor(e.loaded / e.total * (data.chunkSize || data._progress.total)) + (data.uploadedBytes || 0);
        // Add the difference from the previously loaded state
        // to the global loaded counter:
        this._progress.loaded += loaded - data._progress.loaded;
        this._progress.bitrate = this._bitrateTimer.getBitrate(now, this._progress.loaded, data.bitrateInterval);
        data._progress.loaded = data.loaded = loaded;
        data._progress.bitrate = data.bitrate = data._bitrateTimer.getBitrate(now, loaded, data.bitrateInterval);
        // Trigger a custom progress event with a total data property set
        // to the file size(s) of the current upload and a loaded data
        // property calculated accordingly:
        this._trigger('progress', $.Event('progress', { delegatedEvent: e }), data);
        // Trigger a global progress event for all current file uploads,
        // including ajax calls queued for sequential file uploads:
        this._trigger('progressall', $.Event('progressall', { delegatedEvent: e }), this._progress);
      }
    },
    _initProgressListener: function (options) {
      var that = this, xhr = options.xhr ? options.xhr() : $.ajaxSettings.xhr();
      // Accesss to the native XHR object is required to add event listeners
      // for the upload progress event:
      if (xhr.upload) {
        $(xhr.upload).bind('progress', function (e) {
          var oe = e.originalEvent;
          // Make sure the progress event properties get copied over:
          e.lengthComputable = oe.lengthComputable;
          e.loaded = oe.loaded;
          e.total = oe.total;
          that._onProgress(e, options);
        });
        options.xhr = function () {
          return xhr;
        };
      }
    },
    _isInstanceOf: function (type, obj) {
      // Cross-frame instanceof check
      return Object.prototype.toString.call(obj) === '[object ' + type + ']';
    },
    _initXHRData: function (options) {
      var that = this, formData, file = options.files[0],
        // Ignore non-multipart setting if not supported:
        multipart = options.multipart || !$.support.xhrFileUpload, paramName = $.type(options.paramName) === 'array' ? options.paramName[0] : options.paramName;
      options.headers = $.extend({}, options.headers);
      if (options.contentRange) {
        options.headers['Content-Range'] = options.contentRange;
      }
      if (!multipart || options.blob || !this._isInstanceOf('File', file)) {
        options.headers['Content-Disposition'] = 'attachment; filename="' + encodeURI(file.name) + '"';
      }
      if (!multipart) {
        options.contentType = file.type || 'application/octet-stream';
        options.data = options.blob || file;
      } else if ($.support.xhrFormDataFileUpload) {
        if (options.postMessage) {
          // window.postMessage does not allow sending FormData
          // objects, so we just add the File/Blob objects to
          // the formData array and let the postMessage window
          // create the FormData object out of this array:
          formData = this._getFormData(options);
          if (options.blob) {
            formData.push({
              name: paramName,
              value: options.blob
            });
          } else {
            $.each(options.files, function (index, file) {
              formData.push({
                name: $.type(options.paramName) === 'array' && options.paramName[index] || paramName,
                value: file
              });
            });
          }
        } else {
          if (that._isInstanceOf('FormData', options.formData)) {
            formData = options.formData;
          } else {
            formData = new FormData();
            $.each(this._getFormData(options), function (index, field) {
              formData.append(field.name, field.value);
            });
          }
          if (options.blob) {
            formData.append(paramName, options.blob, file.name);
          } else {
            $.each(options.files, function (index, file) {
              // This check allows the tests to run with
              // dummy objects:
              if (that._isInstanceOf('File', file) || that._isInstanceOf('Blob', file)) {
                formData.append($.type(options.paramName) === 'array' && options.paramName[index] || paramName, file, file.uploadName || file.name);
              }
            });
          }
        }
        options.data = formData;
      }
      // Blob reference is not needed anymore, free memory:
      options.blob = null;
    },
    _initIframeSettings: function (options) {
      var targetHost = $('<a></a>').prop('href', options.url).prop('host');
      // Setting the dataType to iframe enables the iframe transport:
      options.dataType = 'iframe ' + (options.dataType || '');
      // The iframe transport accepts a serialized array as form data:
      options.formData = this._getFormData(options);
      // Add redirect url to form data on cross-domain uploads:
      if (options.redirect && targetHost && targetHost !== location.host) {
        options.formData.push({
          name: options.redirectParamName || 'redirect',
          value: options.redirect
        });
      }
    },
    _initDataSettings: function (options) {
      if (this._isXHRUpload(options)) {
        if (!this._chunkedUpload(options, true)) {
          if (!options.data) {
            this._initXHRData(options);
          }
          this._initProgressListener(options);
        }
        if (options.postMessage) {
          // Setting the dataType to postmessage enables the
          // postMessage transport:
          options.dataType = 'postmessage ' + (options.dataType || '');
        }
      } else {
        this._initIframeSettings(options);
      }
    },
    _getParamName: function (options) {
      var fileInput = $(options.fileInput), paramName = options.paramName;
      if (!paramName) {
        paramName = [];
        fileInput.each(function () {
          var input = $(this), name = input.prop('name') || 'files[]', i = (input.prop('files') || [1]).length;
          while (i) {
            paramName.push(name);
            i -= 1;
          }
        });
        if (!paramName.length) {
          paramName = [fileInput.prop('name') || 'files[]'];
        }
      } else if (!$.isArray(paramName)) {
        paramName = [paramName];
      }
      return paramName;
    },
    _initFormSettings: function (options) {
      // Retrieve missing options from the input field and the
      // associated form, if available:
      if (!options.form || !options.form.length) {
        options.form = $(options.fileInput.prop('form'));
        // If the given file input doesn't have an associated form,
        // use the default widget file input's form:
        if (!options.form.length) {
          options.form = $(this.options.fileInput.prop('form'));
        }
      }
      options.paramName = this._getParamName(options);
      if (!options.url) {
        options.url = options.form.prop('action') || location.href;
      }
      // The HTTP request method must be "POST" or "PUT":
      options.type = (options.type || $.type(options.form.prop('method')) === 'string' && options.form.prop('method') || '').toUpperCase();
      if (options.type !== 'POST' && options.type !== 'PUT' && options.type !== 'PATCH') {
        options.type = 'POST';
      }
      if (!options.formAcceptCharset) {
        options.formAcceptCharset = options.form.attr('accept-charset');
      }
    },
    _getAJAXSettings: function (data) {
      var options = $.extend({}, this.options, data);
      this._initFormSettings(options);
      this._initDataSettings(options);
      return options;
    },
    _getDeferredState: function (deferred) {
      if (deferred.state) {
        return deferred.state();
      }
      if (deferred.isResolved()) {
        return 'resolved';
      }
      if (deferred.isRejected()) {
        return 'rejected';
      }
      return 'pending';
    },
    _enhancePromise: function (promise) {
      promise.success = promise.done;
      promise.error = promise.fail;
      promise.complete = promise.always;
      return promise;
    },
    _getXHRPromise: function (resolveOrReject, context, args) {
      var dfd = $.Deferred(), promise = dfd.promise();
      context = context || this.options.context || promise;
      if (resolveOrReject === true) {
        dfd.resolveWith(context, args);
      } else if (resolveOrReject === false) {
        dfd.rejectWith(context, args);
      }
      promise.abort = dfd.promise;
      return this._enhancePromise(promise);
    },
    _addConvenienceMethods: function (e, data) {
      var that = this, getPromise = function (args) {
          return $.Deferred().resolveWith(that, args).promise();
        };
      data.process = function (resolveFunc, rejectFunc) {
        if (resolveFunc || rejectFunc) {
          data._processQueue = this._processQueue = (this._processQueue || getPromise([this])).pipe(function () {
            if (data.errorThrown) {
              return $.Deferred().rejectWith(that, [data]).promise();
            }
            return getPromise(arguments);
          }).pipe(resolveFunc, rejectFunc);
        }
        return this._processQueue || getPromise([this]);
      };
      data.submit = function () {
        if (this.state() !== 'pending') {
          data.jqXHR = this.jqXHR = that._trigger('submit', $.Event('submit', { delegatedEvent: e }), this) !== false && that._onSend(e, this);
        }
        return this.jqXHR || that._getXHRPromise();
      };
      data.abort = function () {
        if (this.jqXHR) {
          return this.jqXHR.abort();
        }
        this.errorThrown = 'abort';
        that._trigger('fail', null, this);
        return that._getXHRPromise(false);
      };
      data.state = function () {
        if (this.jqXHR) {
          return that._getDeferredState(this.jqXHR);
        }
        if (this._processQueue) {
          return that._getDeferredState(this._processQueue);
        }
      };
      data.processing = function () {
        return !this.jqXHR && this._processQueue && that._getDeferredState(this._processQueue) === 'pending';
      };
      data.progress = function () {
        return this._progress;
      };
      data.response = function () {
        return this._response;
      };
    },
    _getUploadedBytes: function (jqXHR) {
      var range = jqXHR.getResponseHeader('Range'), parts = range && range.split('-'), upperBytesPos = parts && parts.length > 1 && parseInt(parts[1], 10);
      return upperBytesPos && upperBytesPos + 1;
    },
    _chunkedUpload: function (options, testOnly) {
      options.uploadedBytes = options.uploadedBytes || 0;
      var that = this, file = options.files[0], fs = file.size, ub = options.uploadedBytes, mcs = options.maxChunkSize || fs, slice = this._blobSlice, dfd = $.Deferred(), promise = dfd.promise(), jqXHR, upload;
      if (!(this._isXHRUpload(options) && slice && (ub || mcs < fs)) || options.data) {
        return false;
      }
      if (testOnly) {
        return true;
      }
      if (ub >= fs) {
        file.error = options.i18n('uploadedBytes');
        return this._getXHRPromise(false, options.context, [
          null,
          'error',
          file.error
        ]);
      }
      // The chunk upload method:
      upload = function () {
        // Clone the options object for each chunk upload:
        var o = $.extend({}, options), currentLoaded = o._progress.loaded;
        o.blob = slice.call(file, ub, ub + mcs, file.type);
        // Store the current chunk size, as the blob itself
        // will be dereferenced after data processing:
        o.chunkSize = o.blob.size;
        // Expose the chunk bytes position range:
        o.contentRange = 'bytes ' + ub + '-' + (ub + o.chunkSize - 1) + '/' + fs;
        // Process the upload data (the blob and potential form data):
        that._initXHRData(o);
        // Add progress listeners for this chunk upload:
        that._initProgressListener(o);
        jqXHR = (that._trigger('chunksend', null, o) !== false && $.ajax(o) || that._getXHRPromise(false, o.context)).done(function (result, textStatus, jqXHR) {
          ub = that._getUploadedBytes(jqXHR) || ub + o.chunkSize;
          // Create a progress event if no final progress event
          // with loaded equaling total has been triggered
          // for this chunk:
          if (currentLoaded + o.chunkSize - o._progress.loaded) {
            that._onProgress($.Event('progress', {
              lengthComputable: true,
              loaded: ub - o.uploadedBytes,
              total: ub - o.uploadedBytes
            }), o);
          }
          options.uploadedBytes = o.uploadedBytes = ub;
          o.result = result;
          o.textStatus = textStatus;
          o.jqXHR = jqXHR;
          that._trigger('chunkdone', null, o);
          that._trigger('chunkalways', null, o);
          if (ub < fs) {
            // File upload not yet complete,
            // continue with the next chunk:
            upload();
          } else {
            dfd.resolveWith(o.context, [
              result,
              textStatus,
              jqXHR
            ]);
          }
        }).fail(function (jqXHR, textStatus, errorThrown) {
          o.jqXHR = jqXHR;
          o.textStatus = textStatus;
          o.errorThrown = errorThrown;
          that._trigger('chunkfail', null, o);
          that._trigger('chunkalways', null, o);
          dfd.rejectWith(o.context, [
            jqXHR,
            textStatus,
            errorThrown
          ]);
        });
      };
      this._enhancePromise(promise);
      promise.abort = function () {
        return jqXHR.abort();
      };
      upload();
      return promise;
    },
    _beforeSend: function (e, data) {
      if (this._active === 0) {
        // the start callback is triggered when an upload starts
        // and no other uploads are currently running,
        // equivalent to the global ajaxStart event:
        this._trigger('start');
        // Set timer for global bitrate progress calculation:
        this._bitrateTimer = new this._BitrateTimer();
        // Reset the global progress values:
        this._progress.loaded = this._progress.total = 0;
        this._progress.bitrate = 0;
      }
      // Make sure the container objects for the .response() and
      // .progress() methods on the data object are available
      // and reset to their initial state:
      this._initResponseObject(data);
      this._initProgressObject(data);
      data._progress.loaded = data.loaded = data.uploadedBytes || 0;
      data._progress.total = data.total = this._getTotal(data.files) || 1;
      data._progress.bitrate = data.bitrate = 0;
      this._active += 1;
      // Initialize the global progress values:
      this._progress.loaded += data.loaded;
      this._progress.total += data.total;
    },
    _onDone: function (result, textStatus, jqXHR, options) {
      var total = options._progress.total, response = options._response;
      if (options._progress.loaded < total) {
        // Create a progress event if no final progress event
        // with loaded equaling total has been triggered:
        this._onProgress($.Event('progress', {
          lengthComputable: true,
          loaded: total,
          total: total
        }), options);
      }
      response.result = options.result = result;
      response.textStatus = options.textStatus = textStatus;
      response.jqXHR = options.jqXHR = jqXHR;
      this._trigger('done', null, options);
    },
    _onFail: function (jqXHR, textStatus, errorThrown, options) {
      var response = options._response;
      if (options.recalculateProgress) {
        // Remove the failed (error or abort) file upload from
        // the global progress calculation:
        this._progress.loaded -= options._progress.loaded;
        this._progress.total -= options._progress.total;
      }
      response.jqXHR = options.jqXHR = jqXHR;
      response.textStatus = options.textStatus = textStatus;
      response.errorThrown = options.errorThrown = errorThrown;
      this._trigger('fail', null, options);
    },
    _onAlways: function (jqXHRorResult, textStatus, jqXHRorError, options) {
      // jqXHRorResult, textStatus and jqXHRorError are added to the
      // options object via done and fail callbacks
      this._trigger('always', null, options);
    },
    _onSend: function (e, data) {
      if (!data.submit) {
        this._addConvenienceMethods(e, data);
      }
      var that = this, jqXHR, aborted, slot, pipe, options = that._getAJAXSettings(data), send = function () {
          that._sending += 1;
          // Set timer for bitrate progress calculation:
          options._bitrateTimer = new that._BitrateTimer();
          jqXHR = jqXHR || ((aborted || that._trigger('send', $.Event('send', { delegatedEvent: e }), options) === false) && that._getXHRPromise(false, options.context, aborted) || that._chunkedUpload(options) || $.ajax(options)).done(function (result, textStatus, jqXHR) {
            that._onDone(result, textStatus, jqXHR, options);
          }).fail(function (jqXHR, textStatus, errorThrown) {
            that._onFail(jqXHR, textStatus, errorThrown, options);
          }).always(function (jqXHRorResult, textStatus, jqXHRorError) {
            that._onAlways(jqXHRorResult, textStatus, jqXHRorError, options);
            that._sending -= 1;
            that._active -= 1;
            if (options.limitConcurrentUploads && options.limitConcurrentUploads > that._sending) {
              // Start the next queued upload,
              // that has not been aborted:
              var nextSlot = that._slots.shift();
              while (nextSlot) {
                if (that._getDeferredState(nextSlot) === 'pending') {
                  nextSlot.resolve();
                  break;
                }
                nextSlot = that._slots.shift();
              }
            }
            if (that._active === 0) {
              // The stop callback is triggered when all uploads have
              // been completed, equivalent to the global ajaxStop event:
              that._trigger('stop');
            }
          });
          return jqXHR;
        };
      this._beforeSend(e, options);
      if (this.options.sequentialUploads || this.options.limitConcurrentUploads && this.options.limitConcurrentUploads <= this._sending) {
        if (this.options.limitConcurrentUploads > 1) {
          slot = $.Deferred();
          this._slots.push(slot);
          pipe = slot.pipe(send);
        } else {
          this._sequence = this._sequence.pipe(send, send);
          pipe = this._sequence;
        }
        // Return the piped Promise object, enhanced with an abort method,
        // which is delegated to the jqXHR object of the current upload,
        // and jqXHR callbacks mapped to the equivalent Promise methods:
        pipe.abort = function () {
          aborted = [
            undefined,
            'abort',
            'abort'
          ];
          if (!jqXHR) {
            if (slot) {
              slot.rejectWith(options.context, aborted);
            }
            return send();
          }
          return jqXHR.abort();
        };
        return this._enhancePromise(pipe);
      }
      return send();
    },
    _onAdd: function (e, data) {
      var that = this, result = true, options = $.extend({}, this.options, data), files = data.files, filesLength = files.length, limit = options.limitMultiFileUploads, limitSize = options.limitMultiFileUploadSize, overhead = options.limitMultiFileUploadSizeOverhead, batchSize = 0, paramName = this._getParamName(options), paramNameSet, paramNameSlice, fileSet, i, j = 0;
      if (limitSize && (!filesLength || files[0].size === undefined)) {
        limitSize = undefined;
      }
      if (!(options.singleFileUploads || limit || limitSize) || !this._isXHRUpload(options)) {
        fileSet = [files];
        paramNameSet = [paramName];
      } else if (!(options.singleFileUploads || limitSize) && limit) {
        fileSet = [];
        paramNameSet = [];
        for (i = 0; i < filesLength; i += limit) {
          fileSet.push(files.slice(i, i + limit));
          paramNameSlice = paramName.slice(i, i + limit);
          if (!paramNameSlice.length) {
            paramNameSlice = paramName;
          }
          paramNameSet.push(paramNameSlice);
        }
      } else if (!options.singleFileUploads && limitSize) {
        fileSet = [];
        paramNameSet = [];
        for (i = 0; i < filesLength; i = i + 1) {
          batchSize += files[i].size + overhead;
          if (i + 1 === filesLength || batchSize + files[i + 1].size + overhead > limitSize || limit && i + 1 - j >= limit) {
            fileSet.push(files.slice(j, i + 1));
            paramNameSlice = paramName.slice(j, i + 1);
            if (!paramNameSlice.length) {
              paramNameSlice = paramName;
            }
            paramNameSet.push(paramNameSlice);
            j = i + 1;
            batchSize = 0;
          }
        }
      } else {
        paramNameSet = paramName;
      }
      data.originalFiles = files;
      $.each(fileSet || files, function (index, element) {
        var newData = $.extend({}, data);
        newData.files = fileSet ? element : [element];
        newData.paramName = paramNameSet[index];
        that._initResponseObject(newData);
        that._initProgressObject(newData);
        that._addConvenienceMethods(e, newData);
        result = that._trigger('add', $.Event('add', { delegatedEvent: e }), newData);
        return result;
      });
      return result;
    },
    _replaceFileInput: function (input) {
      var inputClone = input.clone(true);
      $('<form></form>').append(inputClone)[0].reset();
      // Detaching allows to insert the fileInput on another form
      // without loosing the file input value:
      input.after(inputClone).detach();
      // Avoid memory leaks with the detached file input:
      $.cleanData(input.unbind('remove'));
      // Replace the original file input element in the fileInput
      // elements set with the clone, which has been copied including
      // event handlers:
      this.options.fileInput = this.options.fileInput.map(function (i, el) {
        if (el === input[0]) {
          return inputClone[0];
        }
        return el;
      });
      // If the widget has been initialized on the file input itself,
      // override this.element with the file input clone:
      if (input[0] === this.element[0]) {
        this.element = inputClone;
      }
    },
    _handleFileTreeEntry: function (entry, path) {
      var that = this, dfd = $.Deferred(), errorHandler = function (e) {
          if (e && !e.entry) {
            e.entry = entry;
          }
          // Since $.when returns immediately if one
          // Deferred is rejected, we use resolve instead.
          // This allows valid files and invalid items
          // to be returned together in one set:
          dfd.resolve([e]);
        }, dirReader;
      path = path || '';
      if (entry.isFile) {
        if (entry._file) {
          // Workaround for Chrome bug #149735
          entry._file.relativePath = path;
          dfd.resolve(entry._file);
        } else {
          entry.file(function (file) {
            file.relativePath = path;
            dfd.resolve(file);
          }, errorHandler);
        }
      } else if (entry.isDirectory) {
        dirReader = entry.createReader();
        dirReader.readEntries(function (entries) {
          that._handleFileTreeEntries(entries, path + entry.name + '/').done(function (files) {
            dfd.resolve(files);
          }).fail(errorHandler);
        }, errorHandler);
      } else {
        // Return an empy list for file system items
        // other than files or directories:
        dfd.resolve([]);
      }
      return dfd.promise();
    },
    _handleFileTreeEntries: function (entries, path) {
      var that = this;
      return $.when.apply($, $.map(entries, function (entry) {
        return that._handleFileTreeEntry(entry, path);
      })).pipe(function () {
        return Array.prototype.concat.apply([], arguments);
      });
    },
    _getDroppedFiles: function (dataTransfer) {
      dataTransfer = dataTransfer || {};
      var items = dataTransfer.items;
      if (items && items.length && (items[0].webkitGetAsEntry || items[0].getAsEntry)) {
        return this._handleFileTreeEntries($.map(items, function (item) {
          var entry;
          if (item.webkitGetAsEntry) {
            entry = item.webkitGetAsEntry();
            if (entry) {
              // Workaround for Chrome bug #149735:
              entry._file = item.getAsFile();
            }
            return entry;
          }
          return item.getAsEntry();
        }));
      }
      return $.Deferred().resolve($.makeArray(dataTransfer.files)).promise();
    },
    _getSingleFileInputFiles: function (fileInput) {
      fileInput = $(fileInput);
      var entries = fileInput.prop('webkitEntries') || fileInput.prop('entries'), files, value;
      if (entries && entries.length) {
        return this._handleFileTreeEntries(entries);
      }
      files = $.makeArray(fileInput.prop('files'));
      if (!files.length) {
        value = fileInput.prop('value');
        if (!value) {
          return $.Deferred().resolve([]).promise();
        }
        // If the files property is not available, the browser does not
        // support the File API and we add a pseudo File object with
        // the input value as name with path information removed:
        files = [{ name: value.replace(/^.*\\/, '') }];
      } else if (files[0].name === undefined && files[0].fileName) {
        // File normalization for Safari 4 and Firefox 3:
        $.each(files, function (index, file) {
          file.name = file.fileName;
          file.size = file.fileSize;
        });
      }
      return $.Deferred().resolve(files).promise();
    },
    _getFileInputFiles: function (fileInput) {
      if (!(fileInput instanceof $) || fileInput.length === 1) {
        return this._getSingleFileInputFiles(fileInput);
      }
      return $.when.apply($, $.map(fileInput, this._getSingleFileInputFiles)).pipe(function () {
        return Array.prototype.concat.apply([], arguments);
      });
    },
    _onChange: function (e) {
      var that = this, data = {
          fileInput: $(e.target),
          form: $(e.target.form)
        };
      this._getFileInputFiles(data.fileInput).always(function (files) {
        data.files = files;
        if (that.options.replaceFileInput) {
          that._replaceFileInput(data.fileInput);
        }
        if (that._trigger('change', $.Event('change', { delegatedEvent: e }), data) !== false) {
          that._onAdd(e, data);
        }
      });
    },
    _onPaste: function (e) {
      var items = e.originalEvent && e.originalEvent.clipboardData && e.originalEvent.clipboardData.items, data = { files: [] };
      if (items && items.length) {
        $.each(items, function (index, item) {
          var file = item.getAsFile && item.getAsFile();
          if (file) {
            data.files.push(file);
          }
        });
        if (this._trigger('paste', $.Event('paste', { delegatedEvent: e }), data) !== false) {
          this._onAdd(e, data);
        }
      }
    },
    _onDrop: function (e) {
      e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
      var that = this, dataTransfer = e.dataTransfer, data = {};
      if (dataTransfer && dataTransfer.files && dataTransfer.files.length) {
        e.preventDefault();
        this._getDroppedFiles(dataTransfer).always(function (files) {
          data.files = files;
          if (that._trigger('drop', $.Event('drop', { delegatedEvent: e }), data) !== false) {
            that._onAdd(e, data);
          }
        });
      }
    },
    _onDragOver: function (e) {
      e.dataTransfer = e.originalEvent && e.originalEvent.dataTransfer;
      var dataTransfer = e.dataTransfer;
      if (dataTransfer && $.inArray('Files', dataTransfer.types) !== -1 && this._trigger('dragover', $.Event('dragover', { delegatedEvent: e })) !== false) {
        e.preventDefault();
        dataTransfer.dropEffect = 'copy';
      }
    },
    _initEventHandlers: function () {
      if (this._isXHRUpload(this.options)) {
        this._on(this.options.dropZone, {
          dragover: this._onDragOver,
          drop: this._onDrop
        });
        this._on(this.options.pasteZone, { paste: this._onPaste });
      }
      if ($.support.fileInput) {
        this._on(this.options.fileInput, { change: this._onChange });
      }
    },
    _destroyEventHandlers: function () {
      this._off(this.options.dropZone, 'dragover drop');
      this._off(this.options.pasteZone, 'paste');
      this._off(this.options.fileInput, 'change');
    },
    _setOption: function (key, value) {
      var reinit = $.inArray(key, this._specialOptions) !== -1;
      if (reinit) {
        this._destroyEventHandlers();
      }
      this._super(key, value);
      if (reinit) {
        this._initSpecialOptions();
        this._initEventHandlers();
      }
    },
    _initSpecialOptions: function () {
      var options = this.options;
      if (options.fileInput === undefined) {
        options.fileInput = this.element.is('input[type="file"]') ? this.element : this.element.find('input[type="file"]');
      } else if (!(options.fileInput instanceof $)) {
        options.fileInput = $(options.fileInput);
      }
      if (!(options.dropZone instanceof $)) {
        options.dropZone = $(options.dropZone);
      }
      if (!(options.pasteZone instanceof $)) {
        options.pasteZone = $(options.pasteZone);
      }
    },
    _getRegExp: function (str) {
      var parts = str.split('/'), modifiers = parts.pop();
      parts.shift();
      return new RegExp(parts.join('/'), modifiers);
    },
    _isRegExpOption: function (key, value) {
      return key !== 'url' && $.type(value) === 'string' && /^\/.*\/[igm]{0,3}$/.test(value);
    },
    _initDataAttributes: function () {
      var that = this, options = this.options, clone = $(this.element[0].cloneNode(false));
      // Initialize options set via HTML5 data-attributes:
      $.each(clone.data(), function (key, value) {
        var dataAttributeName = 'data-' + key.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
        if (clone.attr(dataAttributeName)) {
          if (that._isRegExpOption(key, value)) {
            value = that._getRegExp(value);
          }
          options[key] = value;
        }
      });
    },
    _create: function () {
      this._initDataAttributes();
      this._initSpecialOptions();
      this._slots = [];
      this._sequence = this._getXHRPromise(true);
      this._sending = this._active = 0;
      this._initProgressObject(this);
      this._initEventHandlers();
    },
    active: function () {
      return this._active;
    },
    progress: function () {
      return this._progress;
    },
    add: function (data) {
      var that = this;
      if (!data || this.options.disabled) {
        return;
      }
      if (data.fileInput && !data.files) {
        this._getFileInputFiles(data.fileInput).always(function (files) {
          data.files = files;
          that._onAdd(null, data);
        });
      } else {
        data.files = $.makeArray(data.files);
        this._onAdd(null, data);
      }
    },
    send: function (data) {
      if (data && !this.options.disabled) {
        if (data.fileInput && !data.files) {
          var that = this, dfd = $.Deferred(), promise = dfd.promise(), jqXHR, aborted;
          promise.abort = function () {
            aborted = true;
            if (jqXHR) {
              return jqXHR.abort();
            }
            dfd.reject(null, 'abort', 'abort');
            return promise;
          };
          this._getFileInputFiles(data.fileInput).always(function (files) {
            if (aborted) {
              return;
            }
            if (!files.length) {
              dfd.reject();
              return;
            }
            data.files = files;
            jqXHR = that._onSend(null, data).then(function (result, textStatus, jqXHR) {
              dfd.resolve(result, textStatus, jqXHR);
            }, function (jqXHR, textStatus, errorThrown) {
              dfd.reject(jqXHR, textStatus, errorThrown);
            });
          });
          return this._enhancePromise(promise);
        }
        data.files = $.makeArray(data.files);
        if (data.files.length) {
          return this._onSend(null, data);
        }
      }
      return this._getXHRPromise(false, data && data.context);
    }
  });
}));
/*
 * jQuery File Upload Processing Plugin 1.3.0
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2012, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
/* jshint nomen:false */
/* global define, window */
(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define([
      'jquery',
      './jquery.fileupload'
    ], factory);
  } else {
    // Browser globals:
    factory(window.jQuery);
  }
}(function ($) {
  'use strict';
  var originalAdd = $.blueimp.fileupload.prototype.options.add;
  // The File Upload Processing plugin extends the fileupload widget
  // with file processing functionality:
  $.widget('blueimp.fileupload', $.blueimp.fileupload, {
    options: {
      processQueue: [],
      add: function (e, data) {
        var $this = $(this);
        data.process(function () {
          return $this.fileupload('process', data);
        });
        originalAdd.call(this, e, data);
      }
    },
    processActions: {},
    _processFile: function (data, originalData) {
      var that = this, dfd = $.Deferred().resolveWith(that, [data]), chain = dfd.promise();
      this._trigger('process', null, data);
      $.each(data.processQueue, function (i, settings) {
        var func = function (data) {
          if (originalData.errorThrown) {
            return $.Deferred().rejectWith(that, [originalData]).promise();
          }
          return that.processActions[settings.action].call(that, data, settings);
        };
        chain = chain.pipe(func, settings.always && func);
      });
      chain.done(function () {
        that._trigger('processdone', null, data);
        that._trigger('processalways', null, data);
      }).fail(function () {
        that._trigger('processfail', null, data);
        that._trigger('processalways', null, data);
      });
      return chain;
    },
    _transformProcessQueue: function (options) {
      var processQueue = [];
      $.each(options.processQueue, function () {
        var settings = {}, action = this.action, prefix = this.prefix === true ? action : this.prefix;
        $.each(this, function (key, value) {
          if ($.type(value) === 'string' && value.charAt(0) === '@') {
            settings[key] = options[value.slice(1) || (prefix ? prefix + key.charAt(0).toUpperCase() + key.slice(1) : key)];
          } else {
            settings[key] = value;
          }
        });
        processQueue.push(settings);
      });
      options.processQueue = processQueue;
    },
    processing: function () {
      return this._processing;
    },
    process: function (data) {
      var that = this, options = $.extend({}, this.options, data);
      if (options.processQueue && options.processQueue.length) {
        this._transformProcessQueue(options);
        if (this._processing === 0) {
          this._trigger('processstart');
        }
        $.each(data.files, function (index) {
          var opts = index ? $.extend({}, options) : options, func = function () {
              if (data.errorThrown) {
                return $.Deferred().rejectWith(that, [data]).promise();
              }
              return that._processFile(opts, data);
            };
          opts.index = index;
          that._processing += 1;
          that._processingQueue = that._processingQueue.pipe(func, func).always(function () {
            that._processing -= 1;
            if (that._processing === 0) {
              that._trigger('processstop');
            }
          });
        });
      }
      return this._processingQueue;
    },
    _create: function () {
      this._super();
      this._processing = 0;
      this._processingQueue = $.Deferred().resolveWith(this).promise();
    }
  });
}));
/*
 * jQuery File Upload Validation Plugin 1.1.2
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
/* global define, window */
(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define([
      'jquery',
      './jquery.fileupload-process'
    ], factory);
  } else {
    // Browser globals:
    factory(window.jQuery);
  }
}(function ($) {
  'use strict';
  // Append to the default processQueue:
  $.blueimp.fileupload.prototype.options.processQueue.push({
    action: 'validate',
    always: true,
    acceptFileTypes: '@',
    maxFileSize: '@',
    minFileSize: '@',
    maxNumberOfFiles: '@',
    disabled: '@disableValidation'
  });
  // The File Upload Validation plugin extends the fileupload widget
  // with file validation functionality:
  $.widget('blueimp.fileupload', $.blueimp.fileupload, {
    options: {
      getNumberOfFiles: $.noop,
      messages: {
        maxNumberOfFiles: 'Maximum number of files exceeded',
        acceptFileTypes: 'File type not allowed',
        maxFileSize: 'File is too large',
        minFileSize: 'File is too small'
      }
    },
    processActions: {
      validate: function (data, options) {
        if (options.disabled) {
          return data;
        }
        var dfd = $.Deferred(), settings = this.options, file = data.files[data.index], fileSize;
        if (options.minFileSize || options.maxFileSize) {
          fileSize = file.size;
        }
        if ($.type(options.maxNumberOfFiles) === 'number' && (settings.getNumberOfFiles() || 0) + data.files.length > options.maxNumberOfFiles) {
          file.error = settings.i18n('maxNumberOfFiles');
        } else if (options.acceptFileTypes && !(options.acceptFileTypes.test(file.type) || options.acceptFileTypes.test(file.name))) {
          file.error = settings.i18n('acceptFileTypes');
        } else if (fileSize > options.maxFileSize) {
          file.error = settings.i18n('maxFileSize');
        } else if ($.type(fileSize) === 'number' && fileSize < options.minFileSize) {
          file.error = settings.i18n('minFileSize');
        } else {
          delete file.error;
        }
        if (file.error || data.files.error) {
          data.files.error = true;
          dfd.rejectWith(this, [data]);
        } else {
          dfd.resolveWith(this, [data]);
        }
        return dfd.promise();
      }
    }
  });
}));
/*
 * jQuery File Upload Image Preview & Resize Plugin 1.7.2
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
/* jshint nomen:false */
/* global define, window, Blob */
(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define([
      'jquery',
      'load-image',
      'load-image-meta',
      'load-image-exif',
      'load-image-ios',
      'canvas-to-blob',
      './jquery.fileupload-process'
    ], factory);
  } else {
    // Browser globals:
    factory(window.jQuery, window.loadImage);
  }
}(function ($, loadImage) {
  'use strict';
  // Prepend to the default processQueue:
  $.blueimp.fileupload.prototype.options.processQueue.unshift({
    action: 'loadImageMetaData',
    disableImageHead: '@',
    disableExif: '@',
    disableExifThumbnail: '@',
    disableExifSub: '@',
    disableExifGps: '@',
    disabled: '@disableImageMetaDataLoad'
  }, {
    action: 'loadImage',
    prefix: true,
    fileTypes: '@',
    maxFileSize: '@',
    noRevoke: '@',
    disabled: '@disableImageLoad'
  }, {
    action: 'resizeImage',
    prefix: 'image',
    maxWidth: '@',
    maxHeight: '@',
    minWidth: '@',
    minHeight: '@',
    crop: '@',
    orientation: '@',
    forceResize: '@',
    disabled: '@disableImageResize'
  }, {
    action: 'saveImage',
    quality: '@imageQuality',
    type: '@imageType',
    disabled: '@disableImageResize'
  }, {
    action: 'saveImageMetaData',
    disabled: '@disableImageMetaDataSave'
  }, {
    action: 'resizeImage',
    prefix: 'preview',
    maxWidth: '@',
    maxHeight: '@',
    minWidth: '@',
    minHeight: '@',
    crop: '@',
    orientation: '@',
    thumbnail: '@',
    canvas: '@',
    disabled: '@disableImagePreview'
  }, {
    action: 'setImage',
    name: '@imagePreviewName',
    disabled: '@disableImagePreview'
  }, {
    action: 'deleteImageReferences',
    disabled: '@disableImageReferencesDeletion'
  });
  // The File Upload Resize plugin extends the fileupload widget
  // with image resize functionality:
  $.widget('blueimp.fileupload', $.blueimp.fileupload, {
    options: {
      loadImageFileTypes: /^image\/(gif|jpeg|png|svg\+xml)$/,
      loadImageMaxFileSize: 10000000,
      imageMaxWidth: 1920,
      imageMaxHeight: 1080,
      imageOrientation: false,
      imageCrop: false,
      disableImageResize: true,
      previewMaxWidth: 80,
      previewMaxHeight: 80,
      previewOrientation: true,
      previewThumbnail: true,
      previewCrop: false,
      previewCanvas: true
    },
    processActions: {
      loadImage: function (data, options) {
        if (options.disabled) {
          return data;
        }
        var that = this, file = data.files[data.index], dfd = $.Deferred();
        if ($.type(options.maxFileSize) === 'number' && file.size > options.maxFileSize || options.fileTypes && !options.fileTypes.test(file.type) || !loadImage(file, function (img) {
            if (img.src) {
              data.img = img;
            }
            dfd.resolveWith(that, [data]);
          }, options)) {
          return data;
        }
        return dfd.promise();
      },
      resizeImage: function (data, options) {
        if (options.disabled || !(data.canvas || data.img)) {
          return data;
        }
        options = $.extend({ canvas: true }, options);
        var that = this, dfd = $.Deferred(), img = options.canvas && data.canvas || data.img, resolve = function (newImg) {
            if (newImg && (newImg.width !== img.width || newImg.height !== img.height || options.forceResize)) {
              data[newImg.getContext ? 'canvas' : 'img'] = newImg;
            }
            data.preview = newImg;
            dfd.resolveWith(that, [data]);
          }, thumbnail;
        if (data.exif) {
          if (options.orientation === true) {
            options.orientation = data.exif.get('Orientation');
          }
          if (options.thumbnail) {
            thumbnail = data.exif.get('Thumbnail');
            if (thumbnail) {
              loadImage(thumbnail, resolve, options);
              return dfd.promise();
            }
          }
          // Prevent orienting the same image twice:
          if (data.orientation) {
            delete options.orientation;
          } else {
            data.orientation = options.orientation;
          }
        }
        if (img) {
          resolve(loadImage.scale(img, options));
          return dfd.promise();
        }
        return data;
      },
      saveImage: function (data, options) {
        if (!data.canvas || options.disabled) {
          return data;
        }
        var that = this, file = data.files[data.index], dfd = $.Deferred();
        if (data.canvas.toBlob) {
          data.canvas.toBlob(function (blob) {
            if (!blob.name) {
              if (file.type === blob.type) {
                blob.name = file.name;
              } else if (file.name) {
                blob.name = file.name.replace(/\..+$/, '.' + blob.type.substr(6));
              }
            }
            // Don't restore invalid meta data:
            if (file.type !== blob.type) {
              delete data.imageHead;
            }
            // Store the created blob at the position
            // of the original file in the files list:
            data.files[data.index] = blob;
            dfd.resolveWith(that, [data]);
          }, options.type || file.type, options.quality);
        } else {
          return data;
        }
        return dfd.promise();
      },
      loadImageMetaData: function (data, options) {
        if (options.disabled) {
          return data;
        }
        var that = this, dfd = $.Deferred();
        loadImage.parseMetaData(data.files[data.index], function (result) {
          $.extend(data, result);
          dfd.resolveWith(that, [data]);
        }, options);
        return dfd.promise();
      },
      saveImageMetaData: function (data, options) {
        if (!(data.imageHead && data.canvas && data.canvas.toBlob && !options.disabled)) {
          return data;
        }
        var file = data.files[data.index], blob = new Blob([
            data.imageHead,
            this._blobSlice.call(file, 20)
          ], { type: file.type });
        blob.name = file.name;
        data.files[data.index] = blob;
        return data;
      },
      setImage: function (data, options) {
        if (data.preview && !options.disabled) {
          data.files[data.index][options.name || 'preview'] = data.preview;
        }
        return data;
      },
      deleteImageReferences: function (data, options) {
        if (!options.disabled) {
          delete data.img;
          delete data.canvas;
          delete data.preview;
          delete data.imageHead;
        }
        return data;
      }
    }
  });
}));
/*
 * jQuery File Upload Audio Preview Plugin 1.0.3
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
/* jshint nomen:false */
/* global define, window, document */
(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define([
      'jquery',
      'load-image',
      './jquery.fileupload-process'
    ], factory);
  } else {
    // Browser globals:
    factory(window.jQuery, window.loadImage);
  }
}(function ($, loadImage) {
  'use strict';
  // Prepend to the default processQueue:
  $.blueimp.fileupload.prototype.options.processQueue.unshift({
    action: 'loadAudio',
    prefix: true,
    fileTypes: '@',
    maxFileSize: '@',
    disabled: '@disableAudioPreview'
  }, {
    action: 'setAudio',
    name: '@audioPreviewName',
    disabled: '@disableAudioPreview'
  });
  // The File Upload Audio Preview plugin extends the fileupload widget
  // with audio preview functionality:
  $.widget('blueimp.fileupload', $.blueimp.fileupload, {
    options: { loadAudioFileTypes: /^audio\/.*$/ },
    _audioElement: document.createElement('audio'),
    processActions: {
      loadAudio: function (data, options) {
        if (options.disabled) {
          return data;
        }
        var file = data.files[data.index], url, audio;
        if (this._audioElement.canPlayType && this._audioElement.canPlayType(file.type) && ($.type(options.maxFileSize) !== 'number' || file.size <= options.maxFileSize) && (!options.fileTypes || options.fileTypes.test(file.type))) {
          url = loadImage.createObjectURL(file);
          if (url) {
            audio = this._audioElement.cloneNode(false);
            audio.src = url;
            audio.controls = true;
            data.audio = audio;
            return data;
          }
        }
        return data;
      },
      setAudio: function (data, options) {
        if (data.audio && !options.disabled) {
          data.files[data.index][options.name || 'preview'] = data.audio;
        }
        return data;
      }
    }
  });
}));
/*
 * jQuery File Upload Video Preview Plugin 1.0.3
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
/* jshint nomen:false */
/* global define, window, document */
(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define([
      'jquery',
      'load-image',
      './jquery.fileupload-process'
    ], factory);
  } else {
    // Browser globals:
    factory(window.jQuery, window.loadImage);
  }
}(function ($, loadImage) {
  'use strict';
  // Prepend to the default processQueue:
  $.blueimp.fileupload.prototype.options.processQueue.unshift({
    action: 'loadVideo',
    prefix: true,
    fileTypes: '@',
    maxFileSize: '@',
    disabled: '@disableVideoPreview'
  }, {
    action: 'setVideo',
    name: '@videoPreviewName',
    disabled: '@disableVideoPreview'
  });
  // The File Upload Video Preview plugin extends the fileupload widget
  // with video preview functionality:
  $.widget('blueimp.fileupload', $.blueimp.fileupload, {
    options: { loadVideoFileTypes: /^video\/.*$/ },
    _videoElement: document.createElement('video'),
    processActions: {
      loadVideo: function (data, options) {
        if (options.disabled) {
          return data;
        }
        var file = data.files[data.index], url, video;
        if (this._videoElement.canPlayType && this._videoElement.canPlayType(file.type) && ($.type(options.maxFileSize) !== 'number' || file.size <= options.maxFileSize) && (!options.fileTypes || options.fileTypes.test(file.type))) {
          url = loadImage.createObjectURL(file);
          if (url) {
            video = this._videoElement.cloneNode(false);
            video.src = url;
            video.controls = true;
            data.video = video;
            return data;
          }
        }
        return data;
      },
      setVideo: function (data, options) {
        if (data.video && !options.disabled) {
          data.files[data.index][options.name || 'preview'] = data.video;
        }
        return data;
      }
    }
  });
}));
/*
 * jQuery File Upload User Interface Plugin 9.5.2
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2010, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
/* jshint nomen:false */
/* global define, window */
(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define([
      'jquery',
      'tmpl',
      './jquery.fileupload-image',
      './jquery.fileupload-audio',
      './jquery.fileupload-video',
      './jquery.fileupload-validate'
    ], factory);
  } else {
    // Browser globals:
    factory(window.jQuery, window.tmpl);
  }
}(function ($, tmpl) {
  'use strict';
  $.blueimp.fileupload.prototype._specialOptions.push('filesContainer', 'uploadTemplateId', 'downloadTemplateId');
  // The UI version extends the file upload widget
  // and adds complete user interface interaction:
  $.widget('blueimp.fileupload', $.blueimp.fileupload, {
    options: {
      autoUpload: false,
      uploadTemplateId: 'template-upload',
      downloadTemplateId: 'template-download',
      filesContainer: undefined,
      prependFiles: false,
      dataType: 'json',
      getNumberOfFiles: function () {
        return this.filesContainer.children().not('.processing').length;
      },
      getFilesFromResponse: function (data) {
        if (data.result && $.isArray(data.result.files)) {
          return data.result.files;
        }
        return [];
      },
      add: function (e, data) {
        if (e.isDefaultPrevented()) {
          return false;
        }
        var $this = $(this), that = $this.data('blueimp-fileupload') || $this.data('fileupload'), options = that.options;
        data.context = that._renderUpload(data.files).data('data', data).addClass('processing');
        options.filesContainer[options.prependFiles ? 'prepend' : 'append'](data.context);
        that._forceReflow(data.context);
        that._transition(data.context);
        data.process(function () {
          return $this.fileupload('process', data);
        }).always(function () {
          data.context.each(function (index) {
            $(this).find('.size').text(that._formatFileSize(data.files[index].size));
          }).removeClass('processing');
          that._renderPreviews(data);
        }).done(function () {
          data.context.find('.start').prop('disabled', false);
          if (that._trigger('added', e, data) !== false && (options.autoUpload || data.autoUpload) && data.autoUpload !== false) {
            data.submit();
          }
        }).fail(function () {
          if (data.files.error) {
            data.context.each(function (index) {
              var error = data.files[index].error;
              if (error) {
                $(this).find('.error').text(error);
              }
            });
          }
        });
      },
      send: function (e, data) {
        if (e.isDefaultPrevented()) {
          return false;
        }
        var that = $(this).data('blueimp-fileupload') || $(this).data('fileupload');
        if (data.context && data.dataType && data.dataType.substr(0, 6) === 'iframe') {
          // Iframe Transport does not support progress events.
          // In lack of an indeterminate progress bar, we set
          // the progress to 100%, showing the full animated bar:
          data.context.find('.progress').addClass(!$.support.transition && 'progress-animated').attr('aria-valuenow', 100).children().first().css('width', '100%');
        }
        return that._trigger('sent', e, data);
      },
      done: function (e, data) {
        if (e.isDefaultPrevented()) {
          return false;
        }
        var that = $(this).data('blueimp-fileupload') || $(this).data('fileupload'), getFilesFromResponse = data.getFilesFromResponse || that.options.getFilesFromResponse, files = getFilesFromResponse(data), template, deferred;
        if (data.context) {
          data.context.each(function (index) {
            var file = files[index] || { error: 'Empty file upload result' };
            deferred = that._addFinishedDeferreds();
            that._transition($(this)).done(function () {
              var node = $(this);
              template = that._renderDownload([file]).replaceAll(node);
              that._forceReflow(template);
              that._transition(template).done(function () {
                data.context = $(this);
                that._trigger('completed', e, data);
                that._trigger('finished', e, data);
                deferred.resolve();
              });
            });
          });
        } else {
          template = that._renderDownload(files)[that.options.prependFiles ? 'prependTo' : 'appendTo'](that.options.filesContainer);
          that._forceReflow(template);
          deferred = that._addFinishedDeferreds();
          that._transition(template).done(function () {
            data.context = $(this);
            that._trigger('completed', e, data);
            that._trigger('finished', e, data);
            deferred.resolve();
          });
        }
      },
      fail: function (e, data) {
        if (e.isDefaultPrevented()) {
          return false;
        }
        var that = $(this).data('blueimp-fileupload') || $(this).data('fileupload'), template, deferred;
        if (data.context) {
          data.context.each(function (index) {
            if (data.errorThrown !== 'abort') {
              var file = data.files[index];
              file.error = file.error || data.errorThrown || true;
              deferred = that._addFinishedDeferreds();
              that._transition($(this)).done(function () {
                var node = $(this);
                template = that._renderDownload([file]).replaceAll(node);
                that._forceReflow(template);
                that._transition(template).done(function () {
                  data.context = $(this);
                  that._trigger('failed', e, data);
                  that._trigger('finished', e, data);
                  deferred.resolve();
                });
              });
            } else {
              deferred = that._addFinishedDeferreds();
              that._transition($(this)).done(function () {
                $(this).remove();
                that._trigger('failed', e, data);
                that._trigger('finished', e, data);
                deferred.resolve();
              });
            }
          });
        } else if (data.errorThrown !== 'abort') {
          data.context = that._renderUpload(data.files)[that.options.prependFiles ? 'prependTo' : 'appendTo'](that.options.filesContainer).data('data', data);
          that._forceReflow(data.context);
          deferred = that._addFinishedDeferreds();
          that._transition(data.context).done(function () {
            data.context = $(this);
            that._trigger('failed', e, data);
            that._trigger('finished', e, data);
            deferred.resolve();
          });
        } else {
          that._trigger('failed', e, data);
          that._trigger('finished', e, data);
          that._addFinishedDeferreds().resolve();
        }
      },
      progress: function (e, data) {
        if (e.isDefaultPrevented()) {
          return false;
        }
        var progress = Math.floor(data.loaded / data.total * 100);
        if (data.context) {
          data.context.each(function () {
            $(this).find('.progress').attr('aria-valuenow', progress).children().first().css('width', progress + '%');
          });
        }
      },
      progressall: function (e, data) {
        if (e.isDefaultPrevented()) {
          return false;
        }
        var $this = $(this), progress = Math.floor(data.loaded / data.total * 100), globalProgressNode = $this.find('.fileupload-progress'), extendedProgressNode = globalProgressNode.find('.progress-extended');
        if (extendedProgressNode.length) {
          extendedProgressNode.html(($this.data('blueimp-fileupload') || $this.data('fileupload'))._renderExtendedProgress(data));
        }
        globalProgressNode.find('.progress').attr('aria-valuenow', progress).children().first().css('width', progress + '%');
      },
      start: function (e) {
        if (e.isDefaultPrevented()) {
          return false;
        }
        var that = $(this).data('blueimp-fileupload') || $(this).data('fileupload');
        that._resetFinishedDeferreds();
        that._transition($(this).find('.fileupload-progress')).done(function () {
          that._trigger('started', e);
        });
      },
      stop: function (e) {
        if (e.isDefaultPrevented()) {
          return false;
        }
        var that = $(this).data('blueimp-fileupload') || $(this).data('fileupload'), deferred = that._addFinishedDeferreds();
        $.when.apply($, that._getFinishedDeferreds()).done(function () {
          that._trigger('stopped', e);
        });
        that._transition($(this).find('.fileupload-progress')).done(function () {
          $(this).find('.progress').attr('aria-valuenow', '0').children().first().css('width', '0%');
          $(this).find('.progress-extended').html('&nbsp;');
          deferred.resolve();
        });
      },
      processstart: function (e) {
        if (e.isDefaultPrevented()) {
          return false;
        }
        $(this).addClass('fileupload-processing');
      },
      processstop: function (e) {
        if (e.isDefaultPrevented()) {
          return false;
        }
        $(this).removeClass('fileupload-processing');
      },
      destroy: function (e, data) {
        if (e.isDefaultPrevented()) {
          return false;
        }
        var that = $(this).data('blueimp-fileupload') || $(this).data('fileupload'), removeNode = function () {
            that._transition(data.context).done(function () {
              $(this).remove();
              that._trigger('destroyed', e, data);
            });
          };
        if (data.url) {
          data.dataType = data.dataType || that.options.dataType;
          $.ajax(data).done(removeNode).fail(function () {
            that._trigger('destroyfailed', e, data);
          });
        } else {
          removeNode();
        }
      }
    },
    _resetFinishedDeferreds: function () {
      this._finishedUploads = [];
    },
    _addFinishedDeferreds: function (deferred) {
      if (!deferred) {
        deferred = $.Deferred();
      }
      this._finishedUploads.push(deferred);
      return deferred;
    },
    _getFinishedDeferreds: function () {
      return this._finishedUploads;
    },
    _enableDragToDesktop: function () {
      var link = $(this), url = link.prop('href'), name = link.prop('download'), type = 'application/octet-stream';
      link.bind('dragstart', function (e) {
        try {
          e.originalEvent.dataTransfer.setData('DownloadURL', [
            type,
            name,
            url
          ].join(':'));
        } catch (ignore) {
        }
      });
    },
    _formatFileSize: function (bytes) {
      if (typeof bytes !== 'number') {
        return '';
      }
      if (bytes >= 1000000000) {
        return (bytes / 1000000000).toFixed(2) + ' GB';
      }
      if (bytes >= 1000000) {
        return (bytes / 1000000).toFixed(2) + ' MB';
      }
      return (bytes / 1000).toFixed(2) + ' KB';
    },
    _formatBitrate: function (bits) {
      if (typeof bits !== 'number') {
        return '';
      }
      if (bits >= 1000000000) {
        return (bits / 1000000000).toFixed(2) + ' Gbit/s';
      }
      if (bits >= 1000000) {
        return (bits / 1000000).toFixed(2) + ' Mbit/s';
      }
      if (bits >= 1000) {
        return (bits / 1000).toFixed(2) + ' kbit/s';
      }
      return bits.toFixed(2) + ' bit/s';
    },
    _formatTime: function (seconds) {
      var date = new Date(seconds * 1000), days = Math.floor(seconds / 86400);
      days = days ? days + 'd ' : '';
      return days + ('0' + date.getUTCHours()).slice(-2) + ':' + ('0' + date.getUTCMinutes()).slice(-2) + ':' + ('0' + date.getUTCSeconds()).slice(-2);
    },
    _formatPercentage: function (floatValue) {
      return (floatValue * 100).toFixed(2) + ' %';
    },
    _renderExtendedProgress: function (data) {
      return this._formatBitrate(data.bitrate) + ' | ' + this._formatTime((data.total - data.loaded) * 8 / data.bitrate) + ' | ' + this._formatPercentage(data.loaded / data.total) + ' | ' + this._formatFileSize(data.loaded) + ' / ' + this._formatFileSize(data.total);
    },
    _renderTemplate: function (func, files) {
      if (!func) {
        return $();
      }
      var result = func({
          files: files,
          formatFileSize: this._formatFileSize,
          options: this.options
        });
      if (result instanceof $) {
        return result;
      }
      return $(this.options.templatesContainer).html(result).children();
    },
    _renderPreviews: function (data) {
      data.context.find('.preview').each(function (index, elm) {
        $(elm).append(data.files[index].preview);
      });
    },
    _renderUpload: function (files) {
      return this._renderTemplate(this.options.uploadTemplate, files);
    },
    _renderDownload: function (files) {
      return this._renderTemplate(this.options.downloadTemplate, files).find('a[download]').each(this._enableDragToDesktop).end();
    },
    _startHandler: function (e) {
      e.preventDefault();
      var button = $(e.currentTarget), template = button.closest('.template-upload'), data = template.data('data');
      button.prop('disabled', true);
      if (data && data.submit) {
        data.submit();
      }
    },
    _cancelHandler: function (e) {
      e.preventDefault();
      var template = $(e.currentTarget).closest('.template-upload,.template-download'), data = template.data('data') || {};
      data.context = data.context || template;
      if (data.abort) {
        data.abort();
      } else {
        data.errorThrown = 'abort';
        this._trigger('fail', e, data);
      }
    },
    _deleteHandler: function (e) {
      e.preventDefault();
      var button = $(e.currentTarget);
      this._trigger('destroy', e, $.extend({
        context: button.closest('.template-download'),
        type: 'DELETE'
      }, button.data()));
    },
    _forceReflow: function (node) {
      return $.support.transition && node.length && node[0].offsetWidth;
    },
    _transition: function (node) {
      var dfd = $.Deferred();
      if ($.support.transition && node.hasClass('fade') && node.is(':visible')) {
        node.bind($.support.transition.end, function (e) {
          // Make sure we don't respond to other transitions events
          // in the container element, e.g. from button elements:
          if (e.target === node[0]) {
            node.unbind($.support.transition.end);
            dfd.resolveWith(node);
          }
        }).toggleClass('in');
      } else {
        node.toggleClass('in');
        dfd.resolveWith(node);
      }
      return dfd;
    },
    _initButtonBarEventHandlers: function () {
      var fileUploadButtonBar = this.element.find('.fileupload-buttonbar'), filesList = this.options.filesContainer;
      this._on(fileUploadButtonBar.find('.start'), {
        click: function (e) {
          e.preventDefault();
          filesList.find('.start').click();
        }
      });
      this._on(fileUploadButtonBar.find('.cancel'), {
        click: function (e) {
          e.preventDefault();
          filesList.find('.cancel').click();
        }
      });
      this._on(fileUploadButtonBar.find('.delete'), {
        click: function (e) {
          e.preventDefault();
          filesList.find('.toggle:checked').closest('.template-download').find('.delete').click();
          fileUploadButtonBar.find('.toggle').prop('checked', false);
        }
      });
      this._on(fileUploadButtonBar.find('.toggle'), {
        change: function (e) {
          filesList.find('.toggle').prop('checked', $(e.currentTarget).is(':checked'));
        }
      });
    },
    _destroyButtonBarEventHandlers: function () {
      this._off(this.element.find('.fileupload-buttonbar').find('.start, .cancel, .delete'), 'click');
      this._off(this.element.find('.fileupload-buttonbar .toggle'), 'change.');
    },
    _initEventHandlers: function () {
      this._super();
      this._on(this.options.filesContainer, {
        'click .start': this._startHandler,
        'click .cancel': this._cancelHandler,
        'click .delete': this._deleteHandler
      });
      this._initButtonBarEventHandlers();
    },
    _destroyEventHandlers: function () {
      this._destroyButtonBarEventHandlers();
      this._off(this.options.filesContainer, 'click');
      this._super();
    },
    _enableFileInputButton: function () {
      this.element.find('.fileinput-button input').prop('disabled', false).parent().removeClass('disabled');
    },
    _disableFileInputButton: function () {
      this.element.find('.fileinput-button input').prop('disabled', true).parent().addClass('disabled');
    },
    _initTemplates: function () {
      var options = this.options;
      options.templatesContainer = this.document[0].createElement(options.filesContainer.prop('nodeName'));
      if (tmpl) {
        if (options.uploadTemplateId) {
          options.uploadTemplate = tmpl(options.uploadTemplateId);
        }
        if (options.downloadTemplateId) {
          options.downloadTemplate = tmpl(options.downloadTemplateId);
        }
      }
    },
    _initFilesContainer: function () {
      var options = this.options;
      if (options.filesContainer === undefined) {
        options.filesContainer = this.element.find('.files');
      } else if (!(options.filesContainer instanceof $)) {
        options.filesContainer = $(options.filesContainer);
      }
    },
    _initSpecialOptions: function () {
      this._super();
      this._initFilesContainer();
      this._initTemplates();
    },
    _create: function () {
      this._super();
      this._resetFinishedDeferreds();
      if (!$.support.fileInput) {
        this._disableFileInputButton();
      }
    },
    enable: function () {
      var wasDisabled = false;
      if (this.options.disabled) {
        wasDisabled = true;
      }
      this._super();
      if (wasDisabled) {
        this.element.find('input, button').prop('disabled', false);
        this._enableFileInputButton();
      }
    },
    disable: function () {
      if (!this.options.disabled) {
        this.element.find('input, button').prop('disabled', true);
        this._disableFileInputButton();
      }
      this._super();
    }
  });
}));
/*
 * jQuery File Upload jQuery UI Plugin 8.7.1
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2013, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
/* jshint nomen:false */
/* global define, window */
(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define([
      'jquery',
      './jquery.fileupload-ui'
    ], factory);
  } else {
    // Browser globals:
    factory(window.jQuery);
  }
}(function ($) {
  'use strict';
  $.widget('blueimp.fileupload', $.blueimp.fileupload, {
    options: {
      processdone: function (e, data) {
        data.context.find('.start').button('enable');
      },
      progress: function (e, data) {
        if (data.context) {
          data.context.find('.progress').progressbar('option', 'value', parseInt(data.loaded / data.total * 100, 10));
        }
      },
      progressall: function (e, data) {
        var $this = $(this);
        $this.find('.fileupload-progress').find('.progress').progressbar('option', 'value', parseInt(data.loaded / data.total * 100, 10)).end().find('.progress-extended').each(function () {
          $(this).html(($this.data('blueimp-fileupload') || $this.data('fileupload'))._renderExtendedProgress(data));
        });
      }
    },
    _renderUpload: function (func, files) {
      var node = this._super(func, files), showIconText = $(window).width() > 480;
      node.find('.progress').empty().progressbar();
      node.find('.start').button({
        icons: { primary: 'ui-icon-circle-arrow-e' },
        text: showIconText
      });
      node.find('.cancel').button({
        icons: { primary: 'ui-icon-cancel' },
        text: showIconText
      });
      if (node.hasClass('fade')) {
        node.hide();
      }
      return node;
    },
    _renderDownload: function (func, files) {
      var node = this._super(func, files), showIconText = $(window).width() > 480;
      node.find('.delete').button({
        icons: { primary: 'ui-icon-trash' },
        text: showIconText
      });
      if (node.hasClass('fade')) {
        node.hide();
      }
      return node;
    },
    _startHandler: function (e) {
      $(e.currentTarget).button('disable');
      this._super(e);
    },
    _transition: function (node) {
      var deferred = $.Deferred();
      if (node.hasClass('fade')) {
        node.fadeToggle(this.options.transitionDuration, this.options.transitionEasing, function () {
          deferred.resolveWith(node);
        });
      } else {
        deferred.resolveWith(node);
      }
      return deferred;
    },
    _create: function () {
      this._super();
      this.element.find('.fileupload-buttonbar').find('.fileinput-button').each(function () {
        var input = $(this).find('input:file').detach();
        $(this).button({ icons: { primary: 'ui-icon-plusthick' } }).append(input);
      }).end().find('.start').button({ icons: { primary: 'ui-icon-circle-arrow-e' } }).end().find('.cancel').button({ icons: { primary: 'ui-icon-cancel' } }).end().find('.delete').button({ icons: { primary: 'ui-icon-trash' } }).end().find('.progress').progressbar();
    },
    _destroy: function () {
      this.element.find('.fileupload-buttonbar').find('.fileinput-button').each(function () {
        var input = $(this).find('input:file').detach();
        $(this).button('destroy').append(input);
      }).end().find('.start').button('destroy').end().find('.cancel').button('destroy').end().find('.delete').button('destroy').end().find('.progress').progressbar('destroy');
      this._super();
    }
  });
}));
/*
 * jQuery Iframe Transport Plugin 1.8.2
 * https://github.com/blueimp/jQuery-File-Upload
 *
 * Copyright 2011, Sebastian Tschan
 * https://blueimp.net
 *
 * Licensed under the MIT license:
 * http://www.opensource.org/licenses/MIT
 */
/* global define, window, document */
(function (factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    // Register as an anonymous AMD module:
    define(['jquery'], factory);
  } else {
    // Browser globals:
    factory(window.jQuery);
  }
}(function ($) {
  'use strict';
  // Helper variable to create unique names for the transport iframes:
  var counter = 0;
  // The iframe transport accepts four additional options:
  // options.fileInput: a jQuery collection of file input fields
  // options.paramName: the parameter name for the file form data,
  //  overrides the name property of the file input field(s),
  //  can be a string or an array of strings.
  // options.formData: an array of objects with name and value properties,
  //  equivalent to the return data of .serializeArray(), e.g.:
  //  [{name: 'a', value: 1}, {name: 'b', value: 2}]
  // options.initialIframeSrc: the URL of the initial iframe src,
  //  by default set to "javascript:false;"
  $.ajaxTransport('iframe', function (options) {
    if (options.async) {
      // javascript:false as initial iframe src
      // prevents warning popups on HTTPS in IE6:
      /*jshint scripturl: true */
      var initialIframeSrc = options.initialIframeSrc || 'javascript:false;',
        /*jshint scripturl: false */
        form, iframe, addParamChar;
      return {
        send: function (_, completeCallback) {
          form = $('<form style="display:none;"></form>');
          form.attr('accept-charset', options.formAcceptCharset);
          addParamChar = /\?/.test(options.url) ? '&' : '?';
          // XDomainRequest only supports GET and POST:
          if (options.type === 'DELETE') {
            options.url = options.url + addParamChar + '_method=DELETE';
            options.type = 'POST';
          } else if (options.type === 'PUT') {
            options.url = options.url + addParamChar + '_method=PUT';
            options.type = 'POST';
          } else if (options.type === 'PATCH') {
            options.url = options.url + addParamChar + '_method=PATCH';
            options.type = 'POST';
          }
          // IE versions below IE8 cannot set the name property of
          // elements that have already been added to the DOM,
          // so we set the name along with the iframe HTML markup:
          counter += 1;
          iframe = $('<iframe src="' + initialIframeSrc + '" name="iframe-transport-' + counter + '"></iframe>').bind('load', function () {
            var fileInputClones, paramNames = $.isArray(options.paramName) ? options.paramName : [options.paramName];
            iframe.unbind('load').bind('load', function () {
              var response;
              // Wrap in a try/catch block to catch exceptions thrown
              // when trying to access cross-domain iframe contents:
              try {
                response = iframe.contents();
                // Google Chrome and Firefox do not throw an
                // exception when calling iframe.contents() on
                // cross-domain requests, so we unify the response:
                if (!response.length || !response[0].firstChild) {
                  throw new Error();
                }
              } catch (e) {
                response = undefined;
              }
              // The complete callback returns the
              // iframe content document as response object:
              completeCallback(200, 'success', { 'iframe': response });
              // Fix for IE endless progress bar activity bug
              // (happens on form submits to iframe targets):
              $('<iframe src="' + initialIframeSrc + '"></iframe>').appendTo(form);
              window.setTimeout(function () {
                // Removing the form in a setTimeout call
                // allows Chrome's developer tools to display
                // the response result
                form.remove();
              }, 0);
            });
            form.prop('target', iframe.prop('name')).prop('action', options.url).prop('method', options.type);
            if (options.formData) {
              $.each(options.formData, function (index, field) {
                $('<input type="hidden"/>').prop('name', field.name).val(field.value).appendTo(form);
              });
            }
            if (options.fileInput && options.fileInput.length && options.type === 'POST') {
              fileInputClones = options.fileInput.clone();
              // Insert a clone for each file input field:
              options.fileInput.after(function (index) {
                return fileInputClones[index];
              });
              if (options.paramName) {
                options.fileInput.each(function (index) {
                  $(this).prop('name', paramNames[index] || options.paramName);
                });
              }
              // Appending the file input fields to the hidden form
              // removes them from their original location:
              form.append(options.fileInput).prop('enctype', 'multipart/form-data').prop('encoding', 'multipart/form-data');
              // Remove the HTML5 form attribute from the input(s):
              options.fileInput.removeAttr('form');
            }
            form.submit();
            // Insert the file input fields at their original location
            // by replacing the clones with the originals:
            if (fileInputClones && fileInputClones.length) {
              options.fileInput.each(function (index, input) {
                var clone = $(fileInputClones[index]);
                // Restore the original name and form properties:
                $(input).prop('name', clone.prop('name')).attr('form', clone.attr('form'));
                clone.replaceWith(input);
              });
            }
          });
          form.append(iframe).appendTo(document.body);
        },
        abort: function () {
          if (iframe) {
            // javascript:false as iframe src aborts the request
            // and prevents warning popups on HTTPS in IE6.
            // concat is used to avoid the "Script URL" JSLint error:
            iframe.unbind('load').prop('src', initialIframeSrc);
          }
          if (form) {
            form.remove();
          }
        }
      };
    }
  });
  // The iframe transport returns the iframe content document as response.
  // The following adds converters from iframe to text, json, html, xml
  // and script.
  // Please note that the Content-Type for JSON responses has to be text/plain
  // or text/html, if the browser doesn't include application/json in the
  // Accept header, else IE will show a download dialog.
  // The Content-Type for XML responses on the other hand has to be always
  // application/xml or text/xml, so IE properly parses the XML response.
  // See also
  // https://github.com/blueimp/jQuery-File-Upload/wiki/Setup#content-type-negotiation
  $.ajaxSetup({
    converters: {
      'iframe text': function (iframe) {
        return iframe && $(iframe[0].body).text();
      },
      'iframe json': function (iframe) {
        return iframe && $.parseJSON($(iframe[0].body).text());
      },
      'iframe html': function (iframe) {
        return iframe && $(iframe[0].body).html();
      },
      'iframe xml': function (iframe) {
        var xmlDoc = iframe && iframe[0];
        return xmlDoc && $.isXMLDoc(xmlDoc) ? xmlDoc : $.parseXML(xmlDoc.XMLDocument && xmlDoc.XMLDocument.xml || $(xmlDoc.body).html());
      },
      'iframe script': function (iframe) {
        return iframe && $.globalEval($(iframe[0].body).text());
      }
    }
  });
}));
(function (e) {
  e.Parse = e.Parse || {}, e.Parse.VERSION = 'js1.2.17';
}(this), function () {
  var e = this, t = e._, n = {}, i = Array.prototype, r = Object.prototype, s = Function.prototype, a = i.push, o = i.slice, u = i.concat, c = r.toString, l = r.hasOwnProperty, h = i.forEach, d = i.map, f = i.reduce, p = i.reduceRight, _ = i.filter, m = i.every, v = i.some, g = i.indexOf, b = i.lastIndexOf, y = Array.isArray, O = Object.keys, E = s.bind, w = function (e) {
      return e instanceof w ? e : this instanceof w ? (this._wrapped = e, void 0) : new w(e);
    };
  'undefined' != typeof exports ? ('undefined' != typeof module && module.exports && (exports = module.exports = w), exports._ = w) : e._ = w, w.VERSION = '1.4.4';
  var x = w.each = w.forEach = function (e, t, i) {
      if (null != e)
        if (h && e.forEach === h)
          e.forEach(t, i);
        else if (e.length === +e.length) {
          for (var r = 0, s = e.length; s > r; r++)
            if (t.call(i, e[r], r, e) === n)
              return;
        } else
          for (var a in e)
            if (w.has(e, a) && t.call(i, e[a], a, e) === n)
              return;
    };
  w.map = w.collect = function (e, t, n) {
    var i = [];
    return null == e ? i : d && e.map === d ? e.map(t, n) : (x(e, function (e, r, s) {
      i[i.length] = t.call(n, e, r, s);
    }), i);
  };
  var A = 'Reduce of empty array with no initial value';
  w.reduce = w.foldl = w.inject = function (e, t, n, i) {
    var r = arguments.length > 2;
    if (null == e && (e = []), f && e.reduce === f)
      return i && (t = w.bind(t, i)), r ? e.reduce(t, n) : e.reduce(t);
    if (x(e, function (e, s, a) {
        r ? n = t.call(i, n, e, s, a) : (n = e, r = !0);
      }), !r)
      throw new TypeError(A);
    return n;
  }, w.reduceRight = w.foldr = function (e, t, n, i) {
    var r = arguments.length > 2;
    if (null == e && (e = []), p && e.reduceRight === p)
      return i && (t = w.bind(t, i)), r ? e.reduceRight(t, n) : e.reduceRight(t);
    var s = e.length;
    if (s !== +s) {
      var a = w.keys(e);
      s = a.length;
    }
    if (x(e, function (o, u, c) {
        u = a ? a[--s] : --s, r ? n = t.call(i, n, e[u], u, c) : (n = e[u], r = !0);
      }), !r)
      throw new TypeError(A);
    return n;
  }, w.find = w.detect = function (e, t, n) {
    var i;
    return S(e, function (e, r, s) {
      return t.call(n, e, r, s) ? (i = e, !0) : void 0;
    }), i;
  }, w.filter = w.select = function (e, t, n) {
    var i = [];
    return null == e ? i : _ && e.filter === _ ? e.filter(t, n) : (x(e, function (e, r, s) {
      t.call(n, e, r, s) && (i[i.length] = e);
    }), i);
  }, w.reject = function (e, t, n) {
    return w.filter(e, function (e, i, r) {
      return !t.call(n, e, i, r);
    }, n);
  }, w.every = w.all = function (e, t, i) {
    t || (t = w.identity);
    var r = !0;
    return null == e ? r : m && e.every === m ? e.every(t, i) : (x(e, function (e, s, a) {
      return (r = r && t.call(i, e, s, a)) ? void 0 : n;
    }), !!r);
  };
  var S = w.some = w.any = function (e, t, i) {
      t || (t = w.identity);
      var r = !1;
      return null == e ? r : v && e.some === v ? e.some(t, i) : (x(e, function (e, s, a) {
        return r || (r = t.call(i, e, s, a)) ? n : void 0;
      }), !!r);
    };
  w.contains = w.include = function (e, t) {
    return null == e ? !1 : g && e.indexOf === g ? -1 != e.indexOf(t) : S(e, function (e) {
      return e === t;
    });
  }, w.invoke = function (e, t) {
    var n = o.call(arguments, 2), i = w.isFunction(t);
    return w.map(e, function (e) {
      return (i ? t : e[t]).apply(e, n);
    });
  }, w.pluck = function (e, t) {
    return w.map(e, function (e) {
      return e[t];
    });
  }, w.where = function (e, t, n) {
    return w.isEmpty(t) ? n ? null : [] : w[n ? 'find' : 'filter'](e, function (e) {
      for (var n in t)
        if (t[n] !== e[n])
          return !1;
      return !0;
    });
  }, w.findWhere = function (e, t) {
    return w.where(e, t, !0);
  }, w.max = function (e, t, n) {
    if (!t && w.isArray(e) && e[0] === +e[0] && 65535 > e.length)
      return Math.max.apply(Math, e);
    if (!t && w.isEmpty(e))
      return -1 / 0;
    var i = {
        computed: -1 / 0,
        value: -1 / 0
      };
    return x(e, function (e, r, s) {
      var a = t ? t.call(n, e, r, s) : e;
      a >= i.computed && (i = {
        value: e,
        computed: a
      });
    }), i.value;
  }, w.min = function (e, t, n) {
    if (!t && w.isArray(e) && e[0] === +e[0] && 65535 > e.length)
      return Math.min.apply(Math, e);
    if (!t && w.isEmpty(e))
      return 1 / 0;
    var i = {
        computed: 1 / 0,
        value: 1 / 0
      };
    return x(e, function (e, r, s) {
      var a = t ? t.call(n, e, r, s) : e;
      i.computed > a && (i = {
        value: e,
        computed: a
      });
    }), i.value;
  }, w.shuffle = function (e) {
    var t, n = 0, i = [];
    return x(e, function (e) {
      t = w.random(n++), i[n - 1] = i[t], i[t] = e;
    }), i;
  };
  var j = function (e) {
    return w.isFunction(e) ? e : function (t) {
      return t[e];
    };
  };
  w.sortBy = function (e, t, n) {
    var i = j(t);
    return w.pluck(w.map(e, function (e, t, r) {
      return {
        value: e,
        index: t,
        criteria: i.call(n, e, t, r)
      };
    }).sort(function (e, t) {
      var n = e.criteria, i = t.criteria;
      if (n !== i) {
        if (n > i || void 0 === n)
          return 1;
        if (i > n || void 0 === i)
          return -1;
      }
      return e.index < t.index ? -1 : 1;
    }), 'value');
  };
  var N = function (e, t, n, i) {
    var r = {}, s = j(t || w.identity);
    return x(e, function (t, a) {
      var o = s.call(n, t, a, e);
      i(r, o, t);
    }), r;
  };
  w.groupBy = function (e, t, n) {
    return N(e, t, n, function (e, t, n) {
      (w.has(e, t) ? e[t] : e[t] = []).push(n);
    });
  }, w.countBy = function (e, t, n) {
    return N(e, t, n, function (e, t) {
      w.has(e, t) || (e[t] = 0), e[t]++;
    });
  }, w.sortedIndex = function (e, t, n, i) {
    n = null == n ? w.identity : j(n);
    for (var r = n.call(i, t), s = 0, a = e.length; a > s;) {
      var o = s + a >>> 1;
      r > n.call(i, e[o]) ? s = o + 1 : a = o;
    }
    return s;
  }, w.toArray = function (e) {
    return e ? w.isArray(e) ? o.call(e) : e.length === +e.length ? w.map(e, w.identity) : w.values(e) : [];
  }, w.size = function (e) {
    return null == e ? 0 : e.length === +e.length ? e.length : w.keys(e).length;
  }, w.first = w.head = w.take = function (e, t, n) {
    return null == e ? void 0 : null == t || n ? e[0] : o.call(e, 0, t);
  }, w.initial = function (e, t, n) {
    return o.call(e, 0, e.length - (null == t || n ? 1 : t));
  }, w.last = function (e, t, n) {
    return null == e ? void 0 : null == t || n ? e[e.length - 1] : o.call(e, Math.max(e.length - t, 0));
  }, w.rest = w.tail = w.drop = function (e, t, n) {
    return o.call(e, null == t || n ? 1 : t);
  }, w.compact = function (e) {
    return w.filter(e, w.identity);
  };
  var P = function (e, t, n) {
    return x(e, function (e) {
      w.isArray(e) ? t ? a.apply(n, e) : P(e, t, n) : n.push(e);
    }), n;
  };
  w.flatten = function (e, t) {
    return P(e, t, []);
  }, w.without = function (e) {
    return w.difference(e, o.call(arguments, 1));
  }, w.uniq = w.unique = function (e, t, n, i) {
    w.isFunction(t) && (i = n, n = t, t = !1);
    var r = n ? w.map(e, n, i) : e, s = [], a = [];
    return x(r, function (n, i) {
      (t ? i && a[a.length - 1] === n : w.contains(a, n)) || (a.push(n), s.push(e[i]));
    }), s;
  }, w.union = function () {
    return w.uniq(u.apply(i, arguments));
  }, w.intersection = function (e) {
    var t = o.call(arguments, 1);
    return w.filter(w.uniq(e), function (e) {
      return w.every(t, function (t) {
        return w.indexOf(t, e) >= 0;
      });
    });
  }, w.difference = function (e) {
    var t = u.apply(i, o.call(arguments, 1));
    return w.filter(e, function (e) {
      return !w.contains(t, e);
    });
  }, w.zip = function () {
    for (var e = o.call(arguments), t = w.max(w.pluck(e, 'length')), n = Array(t), i = 0; t > i; i++)
      n[i] = w.pluck(e, '' + i);
    return n;
  }, w.object = function (e, t) {
    if (null == e)
      return {};
    for (var n = {}, i = 0, r = e.length; r > i; i++)
      t ? n[e[i]] = t[i] : n[e[i][0]] = e[i][1];
    return n;
  }, w.indexOf = function (e, t, n) {
    if (null == e)
      return -1;
    var i = 0, r = e.length;
    if (n) {
      if ('number' != typeof n)
        return i = w.sortedIndex(e, t), e[i] === t ? i : -1;
      i = 0 > n ? Math.max(0, r + n) : n;
    }
    if (g && e.indexOf === g)
      return e.indexOf(t, n);
    for (; r > i; i++)
      if (e[i] === t)
        return i;
    return -1;
  }, w.lastIndexOf = function (e, t, n) {
    if (null == e)
      return -1;
    var i = null != n;
    if (b && e.lastIndexOf === b)
      return i ? e.lastIndexOf(t, n) : e.lastIndexOf(t);
    for (var r = i ? n : e.length; r--;)
      if (e[r] === t)
        return r;
    return -1;
  }, w.range = function (e, t, n) {
    1 >= arguments.length && (t = e || 0, e = 0), n = arguments[2] || 1;
    for (var i = Math.max(Math.ceil((t - e) / n), 0), r = 0, s = Array(i); i > r;)
      s[r++] = e, e += n;
    return s;
  }, w.bind = function (e, t) {
    if (e.bind === E && E)
      return E.apply(e, o.call(arguments, 1));
    var n = o.call(arguments, 2);
    return function () {
      return e.apply(t, n.concat(o.call(arguments)));
    };
  }, w.partial = function (e) {
    var t = o.call(arguments, 1);
    return function () {
      return e.apply(this, t.concat(o.call(arguments)));
    };
  }, w.bindAll = function (e) {
    var t = o.call(arguments, 1);
    return 0 === t.length && (t = w.functions(e)), x(t, function (t) {
      e[t] = w.bind(e[t], e);
    }), e;
  }, w.memoize = function (e, t) {
    var n = {};
    return t || (t = w.identity), function () {
      var i = t.apply(this, arguments);
      return w.has(n, i) ? n[i] : n[i] = e.apply(this, arguments);
    };
  }, w.delay = function (e, t) {
    var n = o.call(arguments, 2);
    return setTimeout(function () {
      return e.apply(null, n);
    }, t);
  }, w.defer = function (e) {
    return w.delay.apply(w, [
      e,
      1
    ].concat(o.call(arguments, 1)));
  }, w.throttle = function (e, t) {
    var n, i, r, s, a = 0, o = function () {
        a = new Date(), r = null, s = e.apply(n, i);
      };
    return function () {
      var u = new Date(), c = t - (u - a);
      return n = this, i = arguments, 0 >= c ? (clearTimeout(r), r = null, a = u, s = e.apply(n, i)) : r || (r = setTimeout(o, c)), s;
    };
  }, w.debounce = function (e, t, n) {
    var i, r;
    return function () {
      var s = this, a = arguments, o = function () {
          i = null, n || (r = e.apply(s, a));
        }, u = n && !i;
      return clearTimeout(i), i = setTimeout(o, t), u && (r = e.apply(s, a)), r;
    };
  }, w.once = function (e) {
    var t, n = !1;
    return function () {
      return n ? t : (n = !0, t = e.apply(this, arguments), e = null, t);
    };
  }, w.wrap = function (e, t) {
    return function () {
      var n = [e];
      return a.apply(n, arguments), t.apply(this, n);
    };
  }, w.compose = function () {
    var e = arguments;
    return function () {
      for (var t = arguments, n = e.length - 1; n >= 0; n--)
        t = [e[n].apply(this, t)];
      return t[0];
    };
  }, w.after = function (e, t) {
    return 0 >= e ? t() : function () {
      return 1 > --e ? t.apply(this, arguments) : void 0;
    };
  }, w.keys = O || function (e) {
    if (e !== Object(e))
      throw new TypeError('Invalid object');
    var t = [];
    for (var n in e)
      w.has(e, n) && (t[t.length] = n);
    return t;
  }, w.values = function (e) {
    var t = [];
    for (var n in e)
      w.has(e, n) && t.push(e[n]);
    return t;
  }, w.pairs = function (e) {
    var t = [];
    for (var n in e)
      w.has(e, n) && t.push([
        n,
        e[n]
      ]);
    return t;
  }, w.invert = function (e) {
    var t = {};
    for (var n in e)
      w.has(e, n) && (t[e[n]] = n);
    return t;
  }, w.functions = w.methods = function (e) {
    var t = [];
    for (var n in e)
      w.isFunction(e[n]) && t.push(n);
    return t.sort();
  }, w.extend = function (e) {
    return x(o.call(arguments, 1), function (t) {
      if (t)
        for (var n in t)
          e[n] = t[n];
    }), e;
  }, w.pick = function (e) {
    var t = {}, n = u.apply(i, o.call(arguments, 1));
    return x(n, function (n) {
      n in e && (t[n] = e[n]);
    }), t;
  }, w.omit = function (e) {
    var t = {}, n = u.apply(i, o.call(arguments, 1));
    for (var r in e)
      w.contains(n, r) || (t[r] = e[r]);
    return t;
  }, w.defaults = function (e) {
    return x(o.call(arguments, 1), function (t) {
      if (t)
        for (var n in t)
          null == e[n] && (e[n] = t[n]);
    }), e;
  }, w.clone = function (e) {
    return w.isObject(e) ? w.isArray(e) ? e.slice() : w.extend({}, e) : e;
  }, w.tap = function (e, t) {
    return t(e), e;
  };
  var C = function (e, t, n, i) {
    if (e === t)
      return 0 !== e || 1 / e == 1 / t;
    if (null == e || null == t)
      return e === t;
    e instanceof w && (e = e._wrapped), t instanceof w && (t = t._wrapped);
    var r = c.call(e);
    if (r != c.call(t))
      return !1;
    switch (r) {
    case '[object String]':
      return e == t + '';
    case '[object Number]':
      return e != +e ? t != +t : 0 == e ? 1 / e == 1 / t : e == +t;
    case '[object Date]':
    case '[object Boolean]':
      return +e == +t;
    case '[object RegExp]':
      return e.source == t.source && e.global == t.global && e.multiline == t.multiline && e.ignoreCase == t.ignoreCase;
    }
    if ('object' != typeof e || 'object' != typeof t)
      return !1;
    for (var s = n.length; s--;)
      if (n[s] == e)
        return i[s] == t;
    n.push(e), i.push(t);
    var a = 0, o = !0;
    if ('[object Array]' == r) {
      if (a = e.length, o = a == t.length)
        for (; a-- && (o = C(e[a], t[a], n, i)););
    } else {
      var u = e.constructor, l = t.constructor;
      if (u !== l && !(w.isFunction(u) && u instanceof u && w.isFunction(l) && l instanceof l))
        return !1;
      for (var h in e)
        if (w.has(e, h) && (a++, !(o = w.has(t, h) && C(e[h], t[h], n, i))))
          break;
      if (o) {
        for (h in t)
          if (w.has(t, h) && !a--)
            break;
        o = !a;
      }
    }
    return n.pop(), i.pop(), o;
  };
  w.isEqual = function (e, t) {
    return C(e, t, [], []);
  }, w.isEmpty = function (e) {
    if (null == e)
      return !0;
    if (w.isArray(e) || w.isString(e))
      return 0 === e.length;
    for (var t in e)
      if (w.has(e, t))
        return !1;
    return !0;
  }, w.isElement = function (e) {
    return !(!e || 1 !== e.nodeType);
  }, w.isArray = y || function (e) {
    return '[object Array]' == c.call(e);
  }, w.isObject = function (e) {
    return e === Object(e);
  }, x([
    'Arguments',
    'Function',
    'String',
    'Number',
    'Date',
    'RegExp'
  ], function (e) {
    w['is' + e] = function (t) {
      return c.call(t) == '[object ' + e + ']';
    };
  }), w.isArguments(arguments) || (w.isArguments = function (e) {
    return !(!e || !w.has(e, 'callee'));
  }), w.isFunction = function (e) {
    return 'function' == typeof e;
  }, w.isFinite = function (e) {
    return isFinite(e) && !isNaN(parseFloat(e));
  }, w.isNaN = function (e) {
    return w.isNumber(e) && e != +e;
  }, w.isBoolean = function (e) {
    return e === !0 || e === !1 || '[object Boolean]' == c.call(e);
  }, w.isNull = function (e) {
    return null === e;
  }, w.isUndefined = function (e) {
    return void 0 === e;
  }, w.has = function (e, t) {
    return l.call(e, t);
  }, w.noConflict = function () {
    return e._ = t, this;
  }, w.identity = function (e) {
    return e;
  }, w.times = function (e, t, n) {
    for (var i = Array(e), r = 0; e > r; r++)
      i[r] = t.call(n, r);
    return i;
  }, w.random = function (e, t) {
    return null == t && (t = e, e = 0), e + Math.floor(Math.random() * (t - e + 1));
  };
  var R = {
      escape: {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        '\'': '&#x27;',
        '/': '&#x2F;'
      }
    };
  R.unescape = w.invert(R.escape);
  var I = {
      escape: RegExp('[' + w.keys(R.escape).join('') + ']', 'g'),
      unescape: RegExp('(' + w.keys(R.unescape).join('|') + ')', 'g')
    };
  w.each([
    'escape',
    'unescape'
  ], function (e) {
    w[e] = function (t) {
      return null == t ? '' : ('' + t).replace(I[e], function (t) {
        return R[e][t];
      });
    };
  }), w.result = function (e, t) {
    if (null == e)
      return null;
    var n = e[t];
    return w.isFunction(n) ? n.call(e) : n;
  }, w.mixin = function (e) {
    x(w.functions(e), function (t) {
      var n = w[t] = e[t];
      w.prototype[t] = function () {
        var e = [this._wrapped];
        return a.apply(e, arguments), M.call(this, n.apply(w, e));
      };
    });
  };
  var U = 0;
  w.uniqueId = function (e) {
    var t = ++U + '';
    return e ? e + t : t;
  }, w.templateSettings = {
    evaluate: /<%([\s\S]+?)%>/g,
    interpolate: /<%=([\s\S]+?)%>/g,
    escape: /<%-([\s\S]+?)%>/g
  };
  var T = /(.)^/, k = {
      '\'': '\'',
      '\\': '\\',
      '\r': 'r',
      '\n': 'n',
      '\t': 't',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    }, D = /\\|'|\r|\n|\t|\u2028|\u2029/g;
  w.template = function (e, t, n) {
    var i;
    n = w.defaults({}, n, w.templateSettings);
    var r = RegExp([
        (n.escape || T).source,
        (n.interpolate || T).source,
        (n.evaluate || T).source
      ].join('|') + '|$', 'g'), s = 0, a = '__p+=\'';
    e.replace(r, function (t, n, i, r, o) {
      return a += e.slice(s, o).replace(D, function (e) {
        return '\\' + k[e];
      }), n && (a += '\'+\n((__t=(' + n + '))==null?\'\':_.escape(__t))+\n\''), i && (a += '\'+\n((__t=(' + i + '))==null?\'\':__t)+\n\''), r && (a += '\';\n' + r + '\n__p+=\''), s = o + t.length, t;
    }), a += '\';\n', n.variable || (a = 'with(obj||{}){\n' + a + '}\n'), a = 'var __t,__p=\'\',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,\'\');};\n' + a + 'return __p;\n';
    try {
      i = Function(n.variable || 'obj', '_', a);
    } catch (o) {
      throw o.source = a, o;
    }
    if (t)
      return i(t, w);
    var u = function (e) {
      return i.call(this, e, w);
    };
    return u.source = 'function(' + (n.variable || 'obj') + '){\n' + a + '}', u;
  }, w.chain = function (e) {
    return w(e).chain();
  };
  var M = function (e) {
    return this._chain ? w(e).chain() : e;
  };
  w.mixin(w), x([
    'pop',
    'push',
    'reverse',
    'shift',
    'sort',
    'splice',
    'unshift'
  ], function (e) {
    var t = i[e];
    w.prototype[e] = function () {
      var n = this._wrapped;
      return t.apply(n, arguments), 'shift' != e && 'splice' != e || 0 !== n.length || delete n[0], M.call(this, n);
    };
  }), x([
    'concat',
    'join',
    'slice'
  ], function (e) {
    var t = i[e];
    w.prototype[e] = function () {
      return M.call(this, t.apply(this._wrapped, arguments));
    };
  }), w.extend(w.prototype, {
    chain: function () {
      return this._chain = !0, this;
    },
    value: function () {
      return this._wrapped;
    }
  });
}.call(this), function (e) {
  e.Parse = e.Parse || {};
  var t = e.Parse;
  'undefined' != typeof exports && exports._ ? (t._ = exports._.noConflict(), t.localStorage = require('localStorage'), t.XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest, exports.Parse = t) : (t._ = _.noConflict(), 'undefined' != typeof localStorage && (t.localStorage = localStorage), 'undefined' != typeof XMLHttpRequest && (t.XMLHttpRequest = XMLHttpRequest)), 'undefined' != typeof $ && (t.$ = $);
  var n = function () {
    }, i = function (e, i, r) {
      var s;
      return s = i && i.hasOwnProperty('constructor') ? i.constructor : function () {
        e.apply(this, arguments);
      }, t._.extend(s, e), n.prototype = e.prototype, s.prototype = new n(), i && t._.extend(s.prototype, i), r && t._.extend(s, r), s.prototype.constructor = s, s.__super__ = e.prototype, s;
    };
  t.serverURL = 'https://api.parse.com', 'undefined' != typeof process && process.versions && process.versions.node && (t._isNode = !0), t.initialize = function (e, n, i) {
    if (i)
      throw 'Parse.initialize() was passed a Master Key, which is only allowed from within Node.js.';
    t._initialize(e, n);
  }, t._initialize = function (e, n, i) {
    t.applicationId = e, t.javaScriptKey = n, t.masterKey = i, t._useMasterKey = !1;
  }, t._isNode && (t.initialize = t._initialize, t.Cloud = t.Cloud || {}, t.Cloud.useMasterKey = function () {
    t._useMasterKey = !0;
  }), t._getParsePath = function (e) {
    if (!t.applicationId)
      throw 'You need to call Parse.initialize before using Parse.';
    if (e || (e = ''), !t._.isString(e))
      throw 'Tried to get a localStorage path that wasn\'t a String.';
    return '/' === e[0] && (e = e.substring(1)), 'Parse/' + t.applicationId + '/' + e;
  }, t._installationId = null, t._getInstallationId = function () {
    if (t._installationId)
      return t._installationId;
    var e = t._getParsePath('installationId');
    if (t._installationId = t.localStorage.getItem(e), !t._installationId || '' === t._installationId) {
      var n = function () {
        return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);
      };
      t._installationId = n() + n() + '-' + n() + '-' + n() + '-' + n() + '-' + n() + n() + n(), t.localStorage.setItem(e, t._installationId);
    }
    return t._installationId;
  }, t._parseDate = function (e) {
    var t = RegExp('^([0-9]{1,4})-([0-9]{1,2})-([0-9]{1,2})T([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2})(.([0-9]+))?Z$'), n = t.exec(e);
    if (!n)
      return null;
    var i = n[1] || 0, r = (n[2] || 1) - 1, s = n[3] || 0, a = n[4] || 0, o = n[5] || 0, u = n[6] || 0, c = n[8] || 0;
    return new Date(Date.UTC(i, r, s, a, o, u, c));
  }, t._ajaxIE8 = function (e, n, i) {
    var r = new t.Promise(), s = new XDomainRequest();
    return s.onload = function () {
      var e;
      try {
        e = JSON.parse(s.responseText);
      } catch (t) {
        r.reject(t);
      }
      e && r.resolve(e);
    }, s.onerror = s.ontimeout = function () {
      var e = {
          responseText: JSON.stringify({
            code: t.Error.X_DOMAIN_REQUEST,
            error: 'IE\'s XDomainRequest does not supply error info.'
          })
        };
      r.reject(e);
    }, s.onprogress = function () {
    }, s.open(e, n), s.send(i), r;
  }, t._useXDomainRequest = function () {
    return 'undefined' != typeof XDomainRequest ? 'withCredentials' in new XMLHttpRequest() ? !1 : !0 : !1;
  }, t._ajax = function (e, n, i, r, s) {
    var a = {
        success: r,
        error: s
      };
    if (t._useXDomainRequest())
      return t._ajaxIE8(e, n, i)._thenRunCallbacks(a);
    var o = new t.Promise(), u = !1, c = new t.XMLHttpRequest();
    return c.onreadystatechange = function () {
      if (4 === c.readyState) {
        if (u)
          return;
        if (u = !0, c.status >= 200 && 300 > c.status) {
          var e;
          try {
            e = JSON.parse(c.responseText);
          } catch (t) {
            o.reject(t);
          }
          e && o.resolve(e, c.status, c);
        } else
          o.reject(c);
      }
    }, c.open(e, n, !0), c.setRequestHeader('Content-Type', 'text/plain'), t._isNode && c.setRequestHeader('User-Agent', 'Parse/' + t.VERSION + ' (NodeJS ' + process.versions.node + ')'), c.send(i), o._thenRunCallbacks(a);
  }, t._extend = function (e, t) {
    var n = i(this, e, t);
    return n.extend = this.extend, n;
  }, t._request = function (e) {
    var n = e.route, i = e.className, r = e.objectId, s = e.method, a = e.useMasterKey, o = e.sessionToken, u = e.data;
    if (!t.applicationId)
      throw 'You must specify your applicationId using Parse.initialize.';
    if (!t.javaScriptKey && !t.masterKey)
      throw 'You must specify a key using Parse.initialize.';
    if (!o) {
      var c = t.User.current();
      c && c._sessionToken && (o = c._sessionToken);
    }
    if ('batch' !== n && 'classes' !== n && 'events' !== n && 'files' !== n && 'functions' !== n && 'login' !== n && 'push' !== n && 'requestPasswordReset' !== n && 'rest_verify_analytics' !== n && 'users' !== n && 'jobs' !== n)
      throw 'Bad route: \'' + n + '\'.';
    var l = t.serverURL;
    '/' !== l.charAt(l.length - 1) && (l += '/'), l += '1/' + n, i && (l += '/' + i), r && (l += '/' + r), u = t._.clone(u || {}), 'POST' !== s && (u._method = s, s = 'POST'), t._.isUndefined(a) && (a = t._useMasterKey), u._ApplicationId = t.applicationId, a ? u._MasterKey = t.masterKey : u._JavaScriptKey = t.javaScriptKey, u._ClientVersion = t.VERSION, u._InstallationId = t._getInstallationId(), o && (u._SessionToken = o);
    var h = JSON.stringify(u);
    return t._ajax(s, l, h).then(null, function (e) {
      var n;
      if (e && e.responseText)
        try {
          var i = JSON.parse(e.responseText);
          n = new t.Error(i.code, i.error);
        } catch (r) {
          n = new t.Error(t.Error.INVALID_JSON, 'Received an error with invalid JSON from Parse: ' + e.responseText);
        }
      else
        n = new t.Error(t.Error.CONNECTION_FAILED, 'XMLHttpRequest failed: ' + JSON.stringify(e));
      return t.Promise.error(n);
    });
  }, t._getValue = function (e, n) {
    return e && e[n] ? t._.isFunction(e[n]) ? e[n]() : e[n] : null;
  }, t._encode = function (e, n, i) {
    var r = t._;
    if (e instanceof t.Object) {
      if (i)
        throw 'Parse.Objects not allowed here';
      if (!n || r.include(n, e) || !e._hasData)
        return e._toPointer();
      if (!e.dirty())
        return n = n.concat(e), t._encode(e._toFullJSON(n), n, i);
      throw 'Tried to save an object with a pointer to a new, unsaved object.';
    }
    if (e instanceof t.ACL)
      return e.toJSON();
    if (r.isDate(e))
      return {
        __type: 'Date',
        iso: e.toJSON()
      };
    if (e instanceof t.GeoPoint)
      return e.toJSON();
    if (r.isArray(e))
      return r.map(e, function (e) {
        return t._encode(e, n, i);
      });
    if (r.isRegExp(e))
      return e.source;
    if (e instanceof t.Relation)
      return e.toJSON();
    if (e instanceof t.Op)
      return e.toJSON();
    if (e instanceof t.File) {
      if (!e.url())
        throw 'Tried to save an object containing an unsaved file.';
      return {
        __type: 'File',
        name: e.name(),
        url: e.url()
      };
    }
    if (r.isObject(e)) {
      var s = {};
      return t._objectEach(e, function (e, r) {
        s[r] = t._encode(e, n, i);
      }), s;
    }
    return e;
  }, t._decode = function (e, n) {
    var i = t._;
    if (!i.isObject(n))
      return n;
    if (i.isArray(n))
      return t._arrayEach(n, function (e, i) {
        n[i] = t._decode(i, e);
      }), n;
    if (n instanceof t.Object)
      return n;
    if (n instanceof t.File)
      return n;
    if (n instanceof t.Op)
      return n;
    if (n.__op)
      return t.Op._decode(n);
    if ('Pointer' === n.__type) {
      var r = t.Object._create(n.className);
      return r._finishFetch({ objectId: n.objectId }, !1), r;
    }
    if ('Object' === n.__type) {
      var s = n.className;
      delete n.__type, delete n.className;
      var a = t.Object._create(s);
      return a._finishFetch(n, !0), a;
    }
    if ('Date' === n.__type)
      return t._parseDate(n.iso);
    if ('GeoPoint' === n.__type)
      return new t.GeoPoint({
        latitude: n.latitude,
        longitude: n.longitude
      });
    if ('ACL' === e)
      return n instanceof t.ACL ? n : new t.ACL(n);
    if ('Relation' === n.__type) {
      var o = new t.Relation(null, e);
      return o.targetClassName = n.className, o;
    }
    if ('File' === n.__type) {
      var u = new t.File(n.name);
      return u._url = n.url, u;
    }
    return t._objectEach(n, function (e, i) {
      n[i] = t._decode(i, e);
    }), n;
  }, t._arrayEach = t._.each, t._traverse = function (e, n, i) {
    if (e instanceof t.Object) {
      if (i = i || [], t._.indexOf(i, e) >= 0)
        return;
      return i.push(e), t._traverse(e.attributes, n, i), n(e);
    }
    return e instanceof t.Relation || e instanceof t.File ? n(e) : t._.isArray(e) ? (t._.each(e, function (r, s) {
      var a = t._traverse(r, n, i);
      a && (e[s] = a);
    }), n(e)) : t._.isObject(e) ? (t._each(e, function (r, s) {
      var a = t._traverse(r, n, i);
      a && (e[s] = a);
    }), n(e)) : n(e);
  }, t._objectEach = t._each = function (e, n) {
    var i = t._;
    i.isObject(e) ? i.each(i.keys(e), function (t) {
      n(e[t], t);
    }) : i.each(e, n);
  }, t._isNullOrUndefined = function (e) {
    return t._.isNull(e) || t._.isUndefined(e);
  };
}(this), function (e) {
  e.Parse = e.Parse || {};
  var t = e.Parse, n = t._;
  t.Analytics = t.Analytics || {}, n.extend(t.Analytics, {
    track: function (e, i) {
      if (e = e || '', e = e.replace(/^\s*/, ''), e = e.replace(/\s*$/, ''), 0 === e.length)
        throw 'A name for the custom event must be provided';
      return n.each(i, function (e, t) {
        if (!n.isString(t) || !n.isString(e))
          throw 'track() dimensions expects keys and values of type "string".';
      }), t._request({
        route: 'events',
        className: e,
        method: 'POST',
        data: { dimensions: i }
      });
    }
  });
}(this), function (e) {
  e.Parse = e.Parse || {};
  var t = e.Parse, n = t._;
  t.Error = function (e, t) {
    this.code = e, this.message = t;
  }, n.extend(t.Error, {
    OTHER_CAUSE: -1,
    INTERNAL_SERVER_ERROR: 1,
    CONNECTION_FAILED: 100,
    OBJECT_NOT_FOUND: 101,
    INVALID_QUERY: 102,
    INVALID_CLASS_NAME: 103,
    MISSING_OBJECT_ID: 104,
    INVALID_KEY_NAME: 105,
    INVALID_POINTER: 106,
    INVALID_JSON: 107,
    COMMAND_UNAVAILABLE: 108,
    NOT_INITIALIZED: 109,
    INCORRECT_TYPE: 111,
    INVALID_CHANNEL_NAME: 112,
    PUSH_MISCONFIGURED: 115,
    OBJECT_TOO_LARGE: 116,
    OPERATION_FORBIDDEN: 119,
    CACHE_MISS: 120,
    INVALID_NESTED_KEY: 121,
    INVALID_FILE_NAME: 122,
    INVALID_ACL: 123,
    TIMEOUT: 124,
    INVALID_EMAIL_ADDRESS: 125,
    MISSING_CONTENT_TYPE: 126,
    MISSING_CONTENT_LENGTH: 127,
    INVALID_CONTENT_LENGTH: 128,
    FILE_TOO_LARGE: 129,
    FILE_SAVE_ERROR: 130,
    FILE_DELETE_ERROR: 153,
    DUPLICATE_VALUE: 137,
    INVALID_ROLE_NAME: 139,
    EXCEEDED_QUOTA: 140,
    SCRIPT_FAILED: 141,
    VALIDATION_ERROR: 142,
    INVALID_IMAGE_DATA: 150,
    UNSAVED_FILE_ERROR: 151,
    INVALID_PUSH_TIME_ERROR: 152,
    USERNAME_MISSING: 200,
    PASSWORD_MISSING: 201,
    USERNAME_TAKEN: 202,
    EMAIL_TAKEN: 203,
    EMAIL_MISSING: 204,
    EMAIL_NOT_FOUND: 205,
    SESSION_MISSING: 206,
    MUST_CREATE_USER_THROUGH_SIGNUP: 207,
    ACCOUNT_ALREADY_LINKED: 208,
    LINKED_ID_MISSING: 250,
    INVALID_LINKED_SESSION: 251,
    UNSUPPORTED_SERVICE: 252,
    AGGREGATE_ERROR: 600,
    FILE_READ_ERROR: 601,
    X_DOMAIN_REQUEST: 602
  });
}(this), function () {
  var e = this, t = e.Parse || (e.Parse = {}), n = /\s+/, i = Array.prototype.slice;
  t.Events = {
    on: function (e, t, i) {
      var r, s, a, o, u;
      if (!t)
        return this;
      for (e = e.split(n), r = this._callbacks || (this._callbacks = {}), s = e.shift(); s;)
        u = r[s], a = u ? u.tail : {}, a.next = o = {}, a.context = i, a.callback = t, r[s] = {
          tail: o,
          next: u ? u.next : a
        }, s = e.shift();
      return this;
    },
    off: function (e, t, i) {
      var r, s, a, o, u, c;
      if (s = this._callbacks) {
        if (!(e || t || i))
          return delete this._callbacks, this;
        for (e = e ? e.split(n) : _.keys(s), r = e.shift(); r;)
          if (a = s[r], delete s[r], a && (t || i)) {
            for (o = a.tail, a = a.next; a !== o;)
              u = a.callback, c = a.context, (t && u !== t || i && c !== i) && this.on(r, u, c), a = a.next;
            r = e.shift();
          }
        return this;
      }
    },
    trigger: function (e) {
      var t, r, s, a, o, u, c;
      if (!(s = this._callbacks))
        return this;
      for (u = s.all, e = e.split(n), c = i.call(arguments, 1), t = e.shift(); t;) {
        if (r = s[t])
          for (a = r.tail; (r = r.next) !== a;)
            r.callback.apply(r.context || this, c);
        if (r = u)
          for (a = r.tail, o = [t].concat(c); (r = r.next) !== a;)
            r.callback.apply(r.context || this, o);
        t = e.shift();
      }
      return this;
    }
  }, t.Events.bind = t.Events.on, t.Events.unbind = t.Events.off;
}.call(this), function (e) {
  e.Parse = e.Parse || {};
  var t = e.Parse, n = t._;
  t.GeoPoint = function (e, i) {
    n.isArray(e) ? (t.GeoPoint._validate(e[0], e[1]), this.latitude = e[0], this.longitude = e[1]) : n.isObject(e) ? (t.GeoPoint._validate(e.latitude, e.longitude), this.latitude = e.latitude, this.longitude = e.longitude) : n.isNumber(e) && n.isNumber(i) ? (t.GeoPoint._validate(e, i), this.latitude = e, this.longitude = i) : (this.latitude = 0, this.longitude = 0);
    var r = this;
    this.__defineGetter__ && this.__defineSetter__ && (this._latitude = this.latitude, this._longitude = this.longitude, this.__defineGetter__('latitude', function () {
      return r._latitude;
    }), this.__defineGetter__('longitude', function () {
      return r._longitude;
    }), this.__defineSetter__('latitude', function (e) {
      t.GeoPoint._validate(e, r.longitude), r._latitude = e;
    }), this.__defineSetter__('longitude', function (e) {
      t.GeoPoint._validate(r.latitude, e), r._longitude = e;
    }));
  }, t.GeoPoint._validate = function (e, t) {
    if (-90 > e)
      throw 'Parse.GeoPoint latitude ' + e + ' < -90.0.';
    if (e > 90)
      throw 'Parse.GeoPoint latitude ' + e + ' > 90.0.';
    if (-180 > t)
      throw 'Parse.GeoPoint longitude ' + t + ' < -180.0.';
    if (t > 180)
      throw 'Parse.GeoPoint longitude ' + t + ' > 180.0.';
  }, t.GeoPoint.current = function (e) {
    var n = new t.Promise();
    return navigator.geolocation.getCurrentPosition(function (e) {
      n.resolve(new t.GeoPoint({
        latitude: e.coords.latitude,
        longitude: e.coords.longitude
      }));
    }, function (e) {
      n.reject(e);
    }), n._thenRunCallbacks(e);
  }, t.GeoPoint.prototype = {
    toJSON: function () {
      return t.GeoPoint._validate(this.latitude, this.longitude), {
        __type: 'GeoPoint',
        latitude: this.latitude,
        longitude: this.longitude
      };
    },
    radiansTo: function (e) {
      var t = Math.PI / 180, n = this.latitude * t, i = this.longitude * t, r = e.latitude * t, s = e.longitude * t, a = n - r, o = i - s, u = Math.sin(a / 2), c = Math.sin(o / 2), l = u * u + Math.cos(n) * Math.cos(r) * c * c;
      return l = Math.min(1, l), 2 * Math.asin(Math.sqrt(l));
    },
    kilometersTo: function (e) {
      return 6371 * this.radiansTo(e);
    },
    milesTo: function (e) {
      return 3958.8 * this.radiansTo(e);
    }
  };
}(this), function (e) {
  e.Parse = e.Parse || {};
  var t = e.Parse, n = t._, i = '*';
  t.ACL = function (e) {
    var i = this;
    if (i.permissionsById = {}, n.isObject(e))
      if (e instanceof t.User)
        i.setReadAccess(e, !0), i.setWriteAccess(e, !0);
      else {
        if (n.isFunction(e))
          throw 'Parse.ACL() called with a function.  Did you forget ()?';
        t._objectEach(e, function (e, r) {
          if (!n.isString(r))
            throw 'Tried to create an ACL with an invalid userId.';
          i.permissionsById[r] = {}, t._objectEach(e, function (e, t) {
            if ('read' !== t && 'write' !== t)
              throw 'Tried to create an ACL with an invalid permission type.';
            if (!n.isBoolean(e))
              throw 'Tried to create an ACL with an invalid permission value.';
            i.permissionsById[r][t] = e;
          });
        });
      }
  }, t.ACL.prototype.toJSON = function () {
    return n.clone(this.permissionsById);
  }, t.ACL.prototype._setAccess = function (e, i, r) {
    if (i instanceof t.User ? i = i.id : i instanceof t.Role && (i = 'role:' + i.getName()), !n.isString(i))
      throw 'userId must be a string.';
    if (!n.isBoolean(r))
      throw 'allowed must be either true or false.';
    var s = this.permissionsById[i];
    if (!s) {
      if (!r)
        return;
      s = {}, this.permissionsById[i] = s;
    }
    r ? this.permissionsById[i][e] = !0 : (delete s[e], n.isEmpty(s) && delete s[i]);
  }, t.ACL.prototype._getAccess = function (e, n) {
    n instanceof t.User ? n = n.id : n instanceof t.Role && (n = 'role:' + n.getName());
    var i = this.permissionsById[n];
    return i ? i[e] ? !0 : !1 : !1;
  }, t.ACL.prototype.setReadAccess = function (e, t) {
    this._setAccess('read', e, t);
  }, t.ACL.prototype.getReadAccess = function (e) {
    return this._getAccess('read', e);
  }, t.ACL.prototype.setWriteAccess = function (e, t) {
    this._setAccess('write', e, t);
  }, t.ACL.prototype.getWriteAccess = function (e) {
    return this._getAccess('write', e);
  }, t.ACL.prototype.setPublicReadAccess = function (e) {
    this.setReadAccess(i, e);
  }, t.ACL.prototype.getPublicReadAccess = function () {
    return this.getReadAccess(i);
  }, t.ACL.prototype.setPublicWriteAccess = function (e) {
    this.setWriteAccess(i, e);
  }, t.ACL.prototype.getPublicWriteAccess = function () {
    return this.getWriteAccess(i);
  }, t.ACL.prototype.getRoleReadAccess = function (e) {
    if (e instanceof t.Role && (e = e.getName()), n.isString(e))
      return this.getReadAccess('role:' + e);
    throw 'role must be a Parse.Role or a String';
  }, t.ACL.prototype.getRoleWriteAccess = function (e) {
    if (e instanceof t.Role && (e = e.getName()), n.isString(e))
      return this.getWriteAccess('role:' + e);
    throw 'role must be a Parse.Role or a String';
  }, t.ACL.prototype.setRoleReadAccess = function (e, i) {
    if (e instanceof t.Role && (e = e.getName()), n.isString(e))
      return this.setReadAccess('role:' + e, i), void 0;
    throw 'role must be a Parse.Role or a String';
  }, t.ACL.prototype.setRoleWriteAccess = function (e, i) {
    if (e instanceof t.Role && (e = e.getName()), n.isString(e))
      return this.setWriteAccess('role:' + e, i), void 0;
    throw 'role must be a Parse.Role or a String';
  };
}(this), function (e) {
  e.Parse = e.Parse || {};
  var t = e.Parse, n = t._;
  t.Op = function () {
    this._initialize.apply(this, arguments);
  }, t.Op.prototype = {
    _initialize: function () {
    }
  }, n.extend(t.Op, {
    _extend: t._extend,
    _opDecoderMap: {},
    _registerDecoder: function (e, n) {
      t.Op._opDecoderMap[e] = n;
    },
    _decode: function (e) {
      var n = t.Op._opDecoderMap[e.__op];
      return n ? n(e) : void 0;
    }
  }), t.Op._registerDecoder('Batch', function (e) {
    var n = null;
    return t._arrayEach(e.ops, function (e) {
      e = t.Op._decode(e), n = e._mergeWithPrevious(n);
    }), n;
  }), t.Op.Set = t.Op._extend({
    _initialize: function (e) {
      this._value = e;
    },
    value: function () {
      return this._value;
    },
    toJSON: function () {
      return t._encode(this.value());
    },
    _mergeWithPrevious: function () {
      return this;
    },
    _estimate: function () {
      return this.value();
    }
  }), t.Op._UNSET = {}, t.Op.Unset = t.Op._extend({
    toJSON: function () {
      return { __op: 'Delete' };
    },
    _mergeWithPrevious: function () {
      return this;
    },
    _estimate: function () {
      return t.Op._UNSET;
    }
  }), t.Op._registerDecoder('Delete', function () {
    return new t.Op.Unset();
  }), t.Op.Increment = t.Op._extend({
    _initialize: function (e) {
      this._amount = e;
    },
    amount: function () {
      return this._amount;
    },
    toJSON: function () {
      return {
        __op: 'Increment',
        amount: this._amount
      };
    },
    _mergeWithPrevious: function (e) {
      if (e) {
        if (e instanceof t.Op.Unset)
          return new t.Op.Set(this.amount());
        if (e instanceof t.Op.Set)
          return new t.Op.Set(e.value() + this.amount());
        if (e instanceof t.Op.Increment)
          return new t.Op.Increment(this.amount() + e.amount());
        throw 'Op is invalid after previous op.';
      }
      return this;
    },
    _estimate: function (e) {
      return e ? e + this.amount() : this.amount();
    }
  }), t.Op._registerDecoder('Increment', function (e) {
    return new t.Op.Increment(e.amount);
  }), t.Op.Add = t.Op._extend({
    _initialize: function (e) {
      this._objects = e;
    },
    objects: function () {
      return this._objects;
    },
    toJSON: function () {
      return {
        __op: 'Add',
        objects: t._encode(this.objects())
      };
    },
    _mergeWithPrevious: function (e) {
      if (e) {
        if (e instanceof t.Op.Unset)
          return new t.Op.Set(this.objects());
        if (e instanceof t.Op.Set)
          return new t.Op.Set(this._estimate(e.value()));
        if (e instanceof t.Op.Add)
          return new t.Op.Add(e.objects().concat(this.objects()));
        throw 'Op is invalid after previous op.';
      }
      return this;
    },
    _estimate: function (e) {
      return e ? e.concat(this.objects()) : n.clone(this.objects());
    }
  }), t.Op._registerDecoder('Add', function (e) {
    return new t.Op.Add(t._decode(void 0, e.objects));
  }), t.Op.AddUnique = t.Op._extend({
    _initialize: function (e) {
      this._objects = n.uniq(e);
    },
    objects: function () {
      return this._objects;
    },
    toJSON: function () {
      return {
        __op: 'AddUnique',
        objects: t._encode(this.objects())
      };
    },
    _mergeWithPrevious: function (e) {
      if (e) {
        if (e instanceof t.Op.Unset)
          return new t.Op.Set(this.objects());
        if (e instanceof t.Op.Set)
          return new t.Op.Set(this._estimate(e.value()));
        if (e instanceof t.Op.AddUnique)
          return new t.Op.AddUnique(this._estimate(e.objects()));
        throw 'Op is invalid after previous op.';
      }
      return this;
    },
    _estimate: function (e) {
      if (e) {
        var i = n.clone(e);
        return t._arrayEach(this.objects(), function (e) {
          if (e instanceof t.Object && e.id) {
            var r = n.find(i, function (n) {
                return n instanceof t.Object && n.id === e.id;
              });
            if (r) {
              var s = n.indexOf(i, r);
              i[s] = e;
            } else
              i.push(e);
          } else
            n.contains(i, e) || i.push(e);
        }), i;
      }
      return n.clone(this.objects());
    }
  }), t.Op._registerDecoder('AddUnique', function (e) {
    return new t.Op.AddUnique(t._decode(void 0, e.objects));
  }), t.Op.Remove = t.Op._extend({
    _initialize: function (e) {
      this._objects = n.uniq(e);
    },
    objects: function () {
      return this._objects;
    },
    toJSON: function () {
      return {
        __op: 'Remove',
        objects: t._encode(this.objects())
      };
    },
    _mergeWithPrevious: function (e) {
      if (e) {
        if (e instanceof t.Op.Unset)
          return e;
        if (e instanceof t.Op.Set)
          return new t.Op.Set(this._estimate(e.value()));
        if (e instanceof t.Op.Remove)
          return new t.Op.Remove(n.union(e.objects(), this.objects()));
        throw 'Op is invalid after previous op.';
      }
      return this;
    },
    _estimate: function (e) {
      if (e) {
        var i = n.difference(e, this.objects());
        return t._arrayEach(this.objects(), function (e) {
          e instanceof t.Object && e.id && (i = n.reject(i, function (n) {
            return n instanceof t.Object && n.id === e.id;
          }));
        }), i;
      }
      return [];
    }
  }), t.Op._registerDecoder('Remove', function (e) {
    return new t.Op.Remove(t._decode(void 0, e.objects));
  }), t.Op.Relation = t.Op._extend({
    _initialize: function (e, i) {
      this._targetClassName = null;
      var r = this, s = function (e) {
          if (e instanceof t.Object) {
            if (!e.id)
              throw 'You can\'t add an unsaved Parse.Object to a relation.';
            if (r._targetClassName || (r._targetClassName = e.className), r._targetClassName !== e.className)
              throw 'Tried to create a Parse.Relation with 2 different types: ' + r._targetClassName + ' and ' + e.className + '.';
            return e.id;
          }
          return e;
        };
      this.relationsToAdd = n.uniq(n.map(e, s)), this.relationsToRemove = n.uniq(n.map(i, s));
    },
    added: function () {
      var e = this;
      return n.map(this.relationsToAdd, function (n) {
        var i = t.Object._create(e._targetClassName);
        return i.id = n, i;
      });
    },
    removed: function () {
      var e = this;
      return n.map(this.relationsToRemove, function (n) {
        var i = t.Object._create(e._targetClassName);
        return i.id = n, i;
      });
    },
    toJSON: function () {
      var e = null, t = null, i = this, r = function (e) {
          return {
            __type: 'Pointer',
            className: i._targetClassName,
            objectId: e
          };
        }, s = null;
      return this.relationsToAdd.length > 0 && (s = n.map(this.relationsToAdd, r), e = {
        __op: 'AddRelation',
        objects: s
      }), this.relationsToRemove.length > 0 && (s = n.map(this.relationsToRemove, r), t = {
        __op: 'RemoveRelation',
        objects: s
      }), e && t ? {
        __op: 'Batch',
        ops: [
          e,
          t
        ]
      } : e || t || {};
    },
    _mergeWithPrevious: function (e) {
      if (e) {
        if (e instanceof t.Op.Unset)
          throw 'You can\'t modify a relation after deleting it.';
        if (e instanceof t.Op.Relation) {
          if (e._targetClassName && e._targetClassName !== this._targetClassName)
            throw 'Related object must be of class ' + e._targetClassName + ', but ' + this._targetClassName + ' was passed in.';
          var i = n.union(n.difference(e.relationsToAdd, this.relationsToRemove), this.relationsToAdd), r = n.union(n.difference(e.relationsToRemove, this.relationsToAdd), this.relationsToRemove), s = new t.Op.Relation(i, r);
          return s._targetClassName = this._targetClassName, s;
        }
        throw 'Op is invalid after previous op.';
      }
      return this;
    },
    _estimate: function (e, n, i) {
      if (e) {
        if (e instanceof t.Relation) {
          if (this._targetClassName)
            if (e.targetClassName) {
              if (e.targetClassName !== this._targetClassName)
                throw 'Related object must be a ' + e.targetClassName + ', but a ' + this._targetClassName + ' was passed in.';
            } else
              e.targetClassName = this._targetClassName;
          return e;
        }
        throw 'Op is invalid after previous op.';
      }
      var r = new t.Relation(n, i);
      r.targetClassName = this._targetClassName;
    }
  }), t.Op._registerDecoder('AddRelation', function (e) {
    return new t.Op.Relation(t._decode(void 0, e.objects), []);
  }), t.Op._registerDecoder('RemoveRelation', function (e) {
    return new t.Op.Relation([], t._decode(void 0, e.objects));
  });
}(this), function (e) {
  e.Parse = e.Parse || {};
  var t = e.Parse, n = t._;
  t.Relation = function (e, t) {
    this.parent = e, this.key = t, this.targetClassName = null;
  }, t.Relation.prototype = {
    _ensureParentAndKey: function (e, t) {
      if (this.parent = this.parent || e, this.key = this.key || t, this.parent !== e)
        throw 'Internal Error. Relation retrieved from two different Objects.';
      if (this.key !== t)
        throw 'Internal Error. Relation retrieved from two different keys.';
    },
    add: function (e) {
      n.isArray(e) || (e = [e]);
      var i = new t.Op.Relation(e, []);
      this.parent.set(this.key, i), this.targetClassName = i._targetClassName;
    },
    remove: function (e) {
      n.isArray(e) || (e = [e]);
      var i = new t.Op.Relation([], e);
      this.parent.set(this.key, i), this.targetClassName = i._targetClassName;
    },
    toJSON: function () {
      return {
        __type: 'Relation',
        className: this.targetClassName
      };
    },
    query: function () {
      var e, n;
      return this.targetClassName ? (e = t.Object._getSubclass(this.targetClassName), n = new t.Query(e)) : (e = t.Object._getSubclass(this.parent.className), n = new t.Query(e), n._extraOptions.redirectClassNameForKey = this.key), n._addCondition('$relatedTo', 'object', this.parent._toPointer()), n._addCondition('$relatedTo', 'key', this.key), n;
    }
  };
}(this), function (e) {
  e.Parse = e.Parse || {};
  var t = e.Parse, n = t._;
  t.Promise = function () {
    this._resolved = !1, this._rejected = !1, this._resolvedCallbacks = [], this._rejectedCallbacks = [];
  }, n.extend(t.Promise, {
    is: function (e) {
      return e && e.then && n.isFunction(e.then);
    },
    as: function () {
      var e = new t.Promise();
      return e.resolve.apply(e, arguments), e;
    },
    error: function () {
      var e = new t.Promise();
      return e.reject.apply(e, arguments), e;
    },
    when: function (e) {
      var n;
      n = e && t._isNullOrUndefined(e.length) ? arguments : e;
      var i = n.length, r = !1, s = [], a = [];
      if (s.length = n.length, a.length = n.length, 0 === i)
        return t.Promise.as.apply(this, s);
      var o = new t.Promise(), u = function () {
          i -= 1, 0 === i && (r ? o.reject(a) : o.resolve.apply(o, s));
        };
      return t._arrayEach(n, function (e, n) {
        t.Promise.is(e) ? e.then(function (e) {
          s[n] = e, u();
        }, function (e) {
          a[n] = e, r = !0, u();
        }) : (s[n] = e, u());
      }), o;
    },
    _continueWhile: function (e, n) {
      return e() ? n().then(function () {
        return t.Promise._continueWhile(e, n);
      }) : t.Promise.as();
    }
  }), n.extend(t.Promise.prototype, {
    resolve: function () {
      if (this._resolved || this._rejected)
        throw 'A promise was resolved even though it had already been ' + (this._resolved ? 'resolved' : 'rejected') + '.';
      this._resolved = !0, this._result = arguments;
      var e = arguments;
      t._arrayEach(this._resolvedCallbacks, function (t) {
        t.apply(this, e);
      }), this._resolvedCallbacks = [], this._rejectedCallbacks = [];
    },
    reject: function (e) {
      if (this._resolved || this._rejected)
        throw 'A promise was rejected even though it had already been ' + (this._resolved ? 'resolved' : 'rejected') + '.';
      this._rejected = !0, this._error = e, t._arrayEach(this._rejectedCallbacks, function (t) {
        t(e);
      }), this._resolvedCallbacks = [], this._rejectedCallbacks = [];
    },
    then: function (e, n) {
      var i = new t.Promise(), r = function () {
          var n = arguments;
          e && (n = [e.apply(this, n)]), 1 === n.length && t.Promise.is(n[0]) ? n[0].then(function () {
            i.resolve.apply(i, arguments);
          }, function (e) {
            i.reject(e);
          }) : i.resolve.apply(i, n);
        }, s = function (e) {
          var r = [];
          n ? (r = [n(e)], 1 === r.length && t.Promise.is(r[0]) ? r[0].then(function () {
            i.resolve.apply(i, arguments);
          }, function (e) {
            i.reject(e);
          }) : i.reject(r[0])) : i.reject(e);
        };
      return this._resolved ? r.apply(this, this._result) : this._rejected ? s(this._error) : (this._resolvedCallbacks.push(r), this._rejectedCallbacks.push(s)), i;
    },
    always: function (e) {
      return this.then(e, e);
    },
    done: function (e) {
      return this.then(e);
    },
    fail: function (e) {
      return this.then(null, e);
    },
    _thenRunCallbacks: function (e, i) {
      var r;
      if (n.isFunction(e)) {
        var s = e;
        r = {
          success: function (e) {
            s(e, null);
          },
          error: function (e) {
            s(null, e);
          }
        };
      } else
        r = n.clone(e);
      return r = r || {}, this.then(function (e) {
        return r.success ? r.success.apply(this, arguments) : i && i.trigger('sync', i, e, r), t.Promise.as.apply(t.Promise, arguments);
      }, function (e) {
        return r.error ? n.isUndefined(i) ? r.error(e) : r.error(i, e) : i && i.trigger('error', i, e, r), t.Promise.error(e);
      });
    },
    _continueWith: function (e) {
      return this.then(function () {
        return e(arguments, null);
      }, function (t) {
        return e(null, t);
      });
    }
  });
}(this), function (e) {
  e.Parse = e.Parse || {};
  var t = e.Parse, n = t._, i = function (e) {
      if (26 > e)
        return String.fromCharCode(65 + e);
      if (52 > e)
        return String.fromCharCode(97 + (e - 26));
      if (62 > e)
        return String.fromCharCode(48 + (e - 52));
      if (62 === e)
        return '+';
      if (63 === e)
        return '/';
      throw 'Tried to encode large digit ' + e + ' in base64.';
    }, r = function (e) {
      var t = [];
      return t.length = Math.ceil(e.length / 3), n.times(t.length, function (n) {
        var r = e[3 * n], s = e[3 * n + 1] || 0, a = e[3 * n + 2] || 0, o = e.length > 3 * n + 1, u = e.length > 3 * n + 2;
        t[n] = [
          i(63 & r >> 2),
          i(48 & r << 4 | 15 & s >> 4),
          o ? i(60 & s << 2 | 3 & a >> 6) : '=',
          u ? i(63 & a) : '='
        ].join('');
      }), t.join('');
    }, s = {
      ai: 'application/postscript',
      aif: 'audio/x-aiff',
      aifc: 'audio/x-aiff',
      aiff: 'audio/x-aiff',
      asc: 'text/plain',
      atom: 'application/atom+xml',
      au: 'audio/basic',
      avi: 'video/x-msvideo',
      bcpio: 'application/x-bcpio',
      bin: 'application/octet-stream',
      bmp: 'image/bmp',
      cdf: 'application/x-netcdf',
      cgm: 'image/cgm',
      'class': 'application/octet-stream',
      cpio: 'application/x-cpio',
      cpt: 'application/mac-compactpro',
      csh: 'application/x-csh',
      css: 'text/css',
      dcr: 'application/x-director',
      dif: 'video/x-dv',
      dir: 'application/x-director',
      djv: 'image/vnd.djvu',
      djvu: 'image/vnd.djvu',
      dll: 'application/octet-stream',
      dmg: 'application/octet-stream',
      dms: 'application/octet-stream',
      doc: 'application/msword',
      docx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      dotx: 'application/vnd.openxmlformats-officedocument.wordprocessingml.template',
      docm: 'application/vnd.ms-word.document.macroEnabled.12',
      dotm: 'application/vnd.ms-word.template.macroEnabled.12',
      dtd: 'application/xml-dtd',
      dv: 'video/x-dv',
      dvi: 'application/x-dvi',
      dxr: 'application/x-director',
      eps: 'application/postscript',
      etx: 'text/x-setext',
      exe: 'application/octet-stream',
      ez: 'application/andrew-inset',
      gif: 'image/gif',
      gram: 'application/srgs',
      grxml: 'application/srgs+xml',
      gtar: 'application/x-gtar',
      hdf: 'application/x-hdf',
      hqx: 'application/mac-binhex40',
      htm: 'text/html',
      html: 'text/html',
      ice: 'x-conference/x-cooltalk',
      ico: 'image/x-icon',
      ics: 'text/calendar',
      ief: 'image/ief',
      ifb: 'text/calendar',
      iges: 'model/iges',
      igs: 'model/iges',
      jnlp: 'application/x-java-jnlp-file',
      jp2: 'image/jp2',
      jpe: 'image/jpeg',
      jpeg: 'image/jpeg',
      jpg: 'image/jpeg',
      js: 'application/x-javascript',
      kar: 'audio/midi',
      latex: 'application/x-latex',
      lha: 'application/octet-stream',
      lzh: 'application/octet-stream',
      m3u: 'audio/x-mpegurl',
      m4a: 'audio/mp4a-latm',
      m4b: 'audio/mp4a-latm',
      m4p: 'audio/mp4a-latm',
      m4u: 'video/vnd.mpegurl',
      m4v: 'video/x-m4v',
      mac: 'image/x-macpaint',
      man: 'application/x-troff-man',
      mathml: 'application/mathml+xml',
      me: 'application/x-troff-me',
      mesh: 'model/mesh',
      mid: 'audio/midi',
      midi: 'audio/midi',
      mif: 'application/vnd.mif',
      mov: 'video/quicktime',
      movie: 'video/x-sgi-movie',
      mp2: 'audio/mpeg',
      mp3: 'audio/mpeg',
      mp4: 'video/mp4',
      mpe: 'video/mpeg',
      mpeg: 'video/mpeg',
      mpg: 'video/mpeg',
      mpga: 'audio/mpeg',
      ms: 'application/x-troff-ms',
      msh: 'model/mesh',
      mxu: 'video/vnd.mpegurl',
      nc: 'application/x-netcdf',
      oda: 'application/oda',
      ogg: 'application/ogg',
      pbm: 'image/x-portable-bitmap',
      pct: 'image/pict',
      pdb: 'chemical/x-pdb',
      pdf: 'application/pdf',
      pgm: 'image/x-portable-graymap',
      pgn: 'application/x-chess-pgn',
      pic: 'image/pict',
      pict: 'image/pict',
      png: 'image/png',
      pnm: 'image/x-portable-anymap',
      pnt: 'image/x-macpaint',
      pntg: 'image/x-macpaint',
      ppm: 'image/x-portable-pixmap',
      ppt: 'application/vnd.ms-powerpoint',
      pptx: 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
      potx: 'application/vnd.openxmlformats-officedocument.presentationml.template',
      ppsx: 'application/vnd.openxmlformats-officedocument.presentationml.slideshow',
      ppam: 'application/vnd.ms-powerpoint.addin.macroEnabled.12',
      pptm: 'application/vnd.ms-powerpoint.presentation.macroEnabled.12',
      potm: 'application/vnd.ms-powerpoint.template.macroEnabled.12',
      ppsm: 'application/vnd.ms-powerpoint.slideshow.macroEnabled.12',
      ps: 'application/postscript',
      qt: 'video/quicktime',
      qti: 'image/x-quicktime',
      qtif: 'image/x-quicktime',
      ra: 'audio/x-pn-realaudio',
      ram: 'audio/x-pn-realaudio',
      ras: 'image/x-cmu-raster',
      rdf: 'application/rdf+xml',
      rgb: 'image/x-rgb',
      rm: 'application/vnd.rn-realmedia',
      roff: 'application/x-troff',
      rtf: 'text/rtf',
      rtx: 'text/richtext',
      sgm: 'text/sgml',
      sgml: 'text/sgml',
      sh: 'application/x-sh',
      shar: 'application/x-shar',
      silo: 'model/mesh',
      sit: 'application/x-stuffit',
      skd: 'application/x-koan',
      skm: 'application/x-koan',
      skp: 'application/x-koan',
      skt: 'application/x-koan',
      smi: 'application/smil',
      smil: 'application/smil',
      snd: 'audio/basic',
      so: 'application/octet-stream',
      spl: 'application/x-futuresplash',
      src: 'application/x-wais-source',
      sv4cpio: 'application/x-sv4cpio',
      sv4crc: 'application/x-sv4crc',
      svg: 'image/svg+xml',
      swf: 'application/x-shockwave-flash',
      t: 'application/x-troff',
      tar: 'application/x-tar',
      tcl: 'application/x-tcl',
      tex: 'application/x-tex',
      texi: 'application/x-texinfo',
      texinfo: 'application/x-texinfo',
      tif: 'image/tiff',
      tiff: 'image/tiff',
      tr: 'application/x-troff',
      tsv: 'text/tab-separated-values',
      txt: 'text/plain',
      ustar: 'application/x-ustar',
      vcd: 'application/x-cdlink',
      vrml: 'model/vrml',
      vxml: 'application/voicexml+xml',
      wav: 'audio/x-wav',
      wbmp: 'image/vnd.wap.wbmp',
      wbmxl: 'application/vnd.wap.wbxml',
      wml: 'text/vnd.wap.wml',
      wmlc: 'application/vnd.wap.wmlc',
      wmls: 'text/vnd.wap.wmlscript',
      wmlsc: 'application/vnd.wap.wmlscriptc',
      wrl: 'model/vrml',
      xbm: 'image/x-xbitmap',
      xht: 'application/xhtml+xml',
      xhtml: 'application/xhtml+xml',
      xls: 'application/vnd.ms-excel',
      xml: 'application/xml',
      xpm: 'image/x-xpixmap',
      xsl: 'application/xml',
      xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      xltx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.template',
      xlsm: 'application/vnd.ms-excel.sheet.macroEnabled.12',
      xltm: 'application/vnd.ms-excel.template.macroEnabled.12',
      xlam: 'application/vnd.ms-excel.addin.macroEnabled.12',
      xlsb: 'application/vnd.ms-excel.sheet.binary.macroEnabled.12',
      xslt: 'application/xslt+xml',
      xul: 'application/vnd.mozilla.xul+xml',
      xwd: 'image/x-xwindowdump',
      xyz: 'chemical/x-xyz',
      zip: 'application/zip'
    }, a = function (e, n) {
      var i = new t.Promise();
      if ('undefined' == typeof FileReader)
        return t.Promise.error(new t.Error(t.Error.FILE_READ_ERROR, 'Attempted to use a FileReader on an unsupported browser.'));
      var r = new FileReader();
      return r.onloadend = function () {
        if (2 !== r.readyState)
          return i.reject(new t.Error(t.Error.FILE_READ_ERROR, 'Error reading file.')), void 0;
        var e = r.result, s = /^data:([^;]*);base64,(.*)$/.exec(e);
        return s ? (i.resolve(s[2], n || s[1]), void 0) : (i.reject(new t.Error(t.ERROR.FILE_READ_ERROR, 'Unable to interpret data URL: ' + e)), void 0);
      }, r.readAsDataURL(e), i;
    };
  t.File = function (e, i, o) {
    this._name = e;
    var u = /\.([^.]*)$/.exec(e);
    u && (u = u[1].toLowerCase());
    var c = o || s[u] || 'text/plain';
    if (n.isArray(i))
      this._source = t.Promise.as(r(i), c);
    else if (i && i.base64) {
      var l = /^data:([a-zA-Z]*\/[a-zA-Z+.-]*);(charset=[a-zA-Z0-9\-\/\s]*,)?base64,(\S+)/, h = l.exec(i.base64);
      this._source = h && h.length > 0 ? t.Promise.as(4 === h.length ? h[3] : h[2], h[1]) : t.Promise.as(i.base64, c);
    } else if ('undefined' != typeof File && i instanceof File)
      this._source = a(i, o);
    else if (n.isString(i))
      throw 'Creating a Parse.File from a String is not yet supported.';
  }, t.File.prototype = {
    name: function () {
      return this._name;
    },
    url: function () {
      return this._url;
    },
    save: function (e) {
      e = e || {};
      var n = this;
      return n._previousSave || (n._previousSave = n._source.then(function (i, r) {
        var s = {
            base64: i,
            _ContentType: r
          };
        return t._request({
          route: 'files',
          className: n._name,
          method: 'POST',
          data: s,
          useMasterKey: e.useMasterKey
        });
      }).then(function (e) {
        return n._name = e.name, n._url = e.url, n;
      })), n._previousSave._thenRunCallbacks(e);
    }
  };
}(this), function (e) {
  e.Parse = e.Parse || {};
  var t = e.Parse, n = t._;
  t.Object = function (e, i) {
    if (n.isString(e))
      return t.Object._create.apply(this, arguments);
    e = e || {}, i && i.parse && (e = this.parse(e));
    var r = t._getValue(this, 'defaults');
    if (r && (e = n.extend({}, r, e)), i && i.collection && (this.collection = i.collection), this._serverData = {}, this._opSetQueue = [{}], this.attributes = {}, this._hashedJSON = {}, this._escapedAttributes = {}, this.cid = n.uniqueId('c'), this.changed = {}, this._silent = {}, this._pending = {}, !this.set(e, { silent: !0 }))
      throw Error('Can\'t create an invalid Parse.Object');
    this.changed = {}, this._silent = {}, this._pending = {}, this._hasData = !0, this._previousAttributes = n.clone(this.attributes), this.initialize.apply(this, arguments);
  }, t.Object.saveAll = function (e, n) {
    return n = n || {}, t.Object._deepSaveAsync(e, { useMasterKey: n.useMasterKey })._thenRunCallbacks(n);
  }, t.Object.destroyAll = function (e, i) {
    i = i || {};
    var r = function (e) {
        e.trigger('destroy', e, e.collection, i);
      }, s = [], a = function (e) {
        var a = t.Promise.as();
        return e.length > 0 && (a = a.then(function () {
          return t._request({
            route: 'batch',
            method: 'POST',
            useMasterKey: i.useMasterKey,
            data: {
              requests: n.map(e, function (e) {
                return {
                  method: 'DELETE',
                  path: '/1/classes/' + e.className + '/' + e.id
                };
              })
            }
          });
        }).then(function (n) {
          t._arrayEach(e, function (e, a) {
            if (n[a].success && i.wait)
              r(e);
            else if (n[a].error) {
              var o = new t.Error(n[a].error.code, n[a].error.error);
              o.object = e, s.push(o);
            }
          });
        })), a;
      }, o = t.Promise.as(), u = [];
    return t._arrayEach(e, function (t, n) {
      if (t.id && i.wait || r(t), t.id && u.push(t), 20 === u.length || n + 1 === e.length) {
        var s = u;
        u = [], o = o.then(function () {
          return a(s);
        });
      }
    }), o.then(function () {
      if (0 === s.length)
        return !0;
      var e = new t.Error(t.Error.AGGREGATE_ERROR, 'Error deleting an object in destroyAll');
      return e.errors = s, t.Promise.error(e);
    })._thenRunCallbacks(i);
  }, t.Object.fetchAll = function (e, n) {
    return t.Object._fetchAll(e, !0)._thenRunCallbacks(n);
  }, t.Object.fetchAllIfNeeded = function (e, n) {
    return t.Object._fetchAll(e, !1)._thenRunCallbacks(n);
  }, n.extend(t.Object.prototype, t.Events, {
    _existed: !1,
    initialize: function () {
    },
    toJSON: function () {
      var e = this._toFullJSON();
      return t._arrayEach([
        '__type',
        'className'
      ], function (t) {
        delete e[t];
      }), e;
    },
    _toFullJSON: function (e) {
      var i = n.clone(this.attributes);
      return t._objectEach(i, function (n, r) {
        i[r] = t._encode(n, e);
      }), t._objectEach(this._operations, function (e, t) {
        i[t] = e;
      }), n.has(this, 'id') && (i.objectId = this.id), n.has(this, 'createdAt') && (i.createdAt = n.isDate(this.createdAt) ? this.createdAt.toJSON() : this.createdAt), n.has(this, 'updatedAt') && (i.updatedAt = n.isDate(this.updatedAt) ? this.updatedAt.toJSON() : this.updatedAt), i.__type = 'Object', i.className = this.className, i;
    },
    _refreshCache: function () {
      var e = this;
      e._refreshingCache || (e._refreshingCache = !0, t._objectEach(this.attributes, function (i, r) {
        i instanceof t.Object ? i._refreshCache() : n.isObject(i) && e._resetCacheForKey(r) && e.set(r, new t.Op.Set(i), { silent: !0 });
      }), delete e._refreshingCache);
    },
    dirty: function (e) {
      this._refreshCache();
      var t = n.last(this._opSetQueue);
      return e ? t[e] ? !0 : !1 : this.id ? n.keys(t).length > 0 ? !0 : !1 : !0;
    },
    dirtyKeys: function () {
      return n.keys(n.last(this._opSetQueue));
    },
    _toPointer: function () {
      if (!this.id)
        throw Error('Can\'t serialize an unsaved Parse.Object');
      return {
        __type: 'Pointer',
        className: this.className,
        objectId: this.id
      };
    },
    get: function (e) {
      return this.attributes[e];
    },
    relation: function (e) {
      var n = this.get(e);
      if (n) {
        if (!(n instanceof t.Relation))
          throw 'Called relation() on non-relation field ' + e;
        return n._ensureParentAndKey(this, e), n;
      }
      return new t.Relation(this, e);
    },
    escape: function (e) {
      var i = this._escapedAttributes[e];
      if (i)
        return i;
      var r, s = this.attributes[e];
      return r = t._isNullOrUndefined(s) ? '' : n.escape('' + s), this._escapedAttributes[e] = r, r;
    },
    has: function (e) {
      return !t._isNullOrUndefined(this.attributes[e]);
    },
    _mergeMagicFields: function (e) {
      var i = this, r = [
          'id',
          'objectId',
          'createdAt',
          'updatedAt'
        ];
      t._arrayEach(r, function (r) {
        e[r] && ('objectId' === r ? i.id = e[r] : i[r] = 'createdAt' !== r && 'updatedAt' !== r || n.isDate(e[r]) ? e[r] : t._parseDate(e[r]), delete e[r]);
      });
    },
    _copyServerData: function (e) {
      var n = {};
      t._objectEach(e, function (e, i) {
        n[i] = t._decode(i, e);
      }), this._serverData = n, this._rebuildAllEstimatedData(), this._refreshCache(), this._opSetQueue = [{}], this._rebuildAllEstimatedData();
    },
    _mergeFromObject: function (e) {
      e && (this.id = e.id, this.createdAt = e.createdAt, this.updatedAt = e.updatedAt, this._copyServerData(e._serverData), this._hasData = !0);
    },
    _startSave: function () {
      this._opSetQueue.push({});
    },
    _cancelSave: function () {
      var e = n.first(this._opSetQueue);
      this._opSetQueue = n.rest(this._opSetQueue);
      var i = n.first(this._opSetQueue);
      t._objectEach(e, function (t, n) {
        var r = e[n], s = i[n];
        r && s ? i[n] = s._mergeWithPrevious(r) : r && (i[n] = r);
      }), this._saving = this._saving - 1;
    },
    _finishSave: function (e) {
      var i = {};
      t._traverse(this.attributes, function (e) {
        e instanceof t.Object && e.id && e._hasData && (i[e.id] = e);
      });
      var r = n.first(this._opSetQueue);
      this._opSetQueue = n.rest(this._opSetQueue), this._applyOpSet(r, this._serverData), this._mergeMagicFields(e);
      var s = this;
      t._objectEach(e, function (e, n) {
        s._serverData[n] = t._decode(n, e);
        var r = t._traverse(s._serverData[n], function (e) {
            return e instanceof t.Object && i[e.id] ? i[e.id] : void 0;
          });
        r && (s._serverData[n] = r);
      }), this._rebuildAllEstimatedData(), this._saving = this._saving - 1;
    },
    _finishFetch: function (e, t) {
      this._opSetQueue = [{}], this._mergeMagicFields(e), this._copyServerData(e), this._hasData = t;
    },
    _applyOpSet: function (e, n) {
      var i = this;
      t._objectEach(e, function (e, r) {
        n[r] = e._estimate(n[r], i, r), n[r] === t.Op._UNSET && delete n[r];
      });
    },
    _resetCacheForKey: function (e) {
      var i = this.attributes[e];
      if (!(!n.isObject(i) || i instanceof t.Object || i instanceof t.File)) {
        i = i.toJSON ? i.toJSON() : i;
        var r = JSON.stringify(i);
        if (this._hashedJSON[e] !== r)
          return this._hashedJSON[e] = r, !0;
      }
      return !1;
    },
    _rebuildEstimatedDataForKey: function (e) {
      var n = this;
      delete this.attributes[e], this._serverData[e] && (this.attributes[e] = this._serverData[e]), t._arrayEach(this._opSetQueue, function (i) {
        var r = i[e];
        r && (n.attributes[e] = r._estimate(n.attributes[e], n, e), n.attributes[e] === t.Op._UNSET ? delete n.attributes[e] : n._resetCacheForKey(e));
      });
    },
    _rebuildAllEstimatedData: function () {
      var e = this, i = n.clone(this.attributes);
      this.attributes = n.clone(this._serverData), t._arrayEach(this._opSetQueue, function (n) {
        e._applyOpSet(n, e.attributes), t._objectEach(n, function (t, n) {
          e._resetCacheForKey(n);
        });
      }), t._objectEach(i, function (t, n) {
        e.attributes[n] !== t && e.trigger('change:' + n, e, e.attributes[n], {});
      }), t._objectEach(this.attributes, function (t, r) {
        n.has(i, r) || e.trigger('change:' + r, e, t, {});
      });
    },
    set: function (e, i, r) {
      var s;
      if (n.isObject(e) || t._isNullOrUndefined(e) ? (s = e, t._objectEach(s, function (e, n) {
          s[n] = t._decode(n, e);
        }), r = i) : (s = {}, s[e] = t._decode(e, i)), r = r || {}, !s)
        return this;
      s instanceof t.Object && (s = s.attributes), r.unset && t._objectEach(s, function (e, n) {
        s[n] = new t.Op.Unset();
      });
      var a = n.clone(s), o = this;
      if (t._objectEach(a, function (e, n) {
          e instanceof t.Op && (a[n] = e._estimate(o.attributes[n], o, n), a[n] === t.Op._UNSET && delete a[n]);
        }), !this._validate(s, r))
        return !1;
      this._mergeMagicFields(s), r.changes = {};
      var u = this._escapedAttributes;
      return this._previousAttributes || {}, t._arrayEach(n.keys(s), function (e) {
        var i = s[e];
        i instanceof t.Relation && (i.parent = o), i instanceof t.Op || (i = new t.Op.Set(i));
        var a = !0;
        i instanceof t.Op.Set && n.isEqual(o.attributes[e], i.value) && (a = !1), a && (delete u[e], r.silent ? o._silent[e] = !0 : r.changes[e] = !0);
        var c = n.last(o._opSetQueue);
        c[e] = i._mergeWithPrevious(c[e]), o._rebuildEstimatedDataForKey(e), a ? (o.changed[e] = o.attributes[e], r.silent || (o._pending[e] = !0)) : (delete o.changed[e], delete o._pending[e]);
      }), r.silent || this.change(r), this;
    },
    unset: function (e, t) {
      return t = t || {}, t.unset = !0, this.set(e, null, t);
    },
    increment: function (e, i) {
      return (n.isUndefined(i) || n.isNull(i)) && (i = 1), this.set(e, new t.Op.Increment(i));
    },
    add: function (e, n) {
      return this.set(e, new t.Op.Add([n]));
    },
    addUnique: function (e, n) {
      return this.set(e, new t.Op.AddUnique([n]));
    },
    remove: function (e, n) {
      return this.set(e, new t.Op.Remove([n]));
    },
    op: function (e) {
      return n.last(this._opSetQueue)[e];
    },
    clear: function (e) {
      e = e || {}, e.unset = !0;
      var t = n.extend(this.attributes, this._operations);
      return this.set(t, e);
    },
    _getSaveJSON: function () {
      var e = n.clone(n.first(this._opSetQueue));
      return t._objectEach(e, function (t, n) {
        e[n] = t.toJSON();
      }), e;
    },
    _canBeSerialized: function () {
      return t.Object._canBeSerializedAsValue(this.attributes);
    },
    fetch: function (e) {
      var n = this;
      e = e || {};
      var i = t._request({
          method: 'GET',
          route: 'classes',
          className: this.className,
          objectId: this.id,
          useMasterKey: e.useMasterKey
        });
      return i.then(function (e, t, i) {
        return n._finishFetch(n.parse(e, t, i), !0), n;
      })._thenRunCallbacks(e, this);
    },
    save: function (e, i, r) {
      var s, a, o;
      if (n.isObject(e) || t._isNullOrUndefined(e) ? (s = e, o = i) : (s = {}, s[e] = i, o = r), !o && s) {
        var u = n.reject(s, function (e, t) {
            return n.include([
              'success',
              'error',
              'wait'
            ], t);
          });
        if (0 === u.length) {
          var c = !0;
          if (n.has(s, 'success') && !n.isFunction(s.success) && (c = !1), n.has(s, 'error') && !n.isFunction(s.error) && (c = !1), c)
            return this.save(null, s);
        }
      }
      o = n.clone(o) || {}, o.wait && (a = n.clone(this.attributes));
      var l = n.clone(o) || {};
      l.wait && (l.silent = !0);
      var h;
      if (l.error = function (e, t) {
          h = t;
        }, s && !this.set(s, l))
        return t.Promise.error(h)._thenRunCallbacks(o, this);
      var d = this;
      d._refreshCache();
      var f = [], p = [];
      return t.Object._findUnsavedChildren(d.attributes, f, p), f.length + p.length > 0 ? t.Object._deepSaveAsync(this.attributes, { useMasterKey: o.useMasterKey }).then(function () {
        return d.save(null, o);
      }, function (e) {
        return t.Promise.error(e)._thenRunCallbacks(o, d);
      }) : (this._startSave(), this._saving = (this._saving || 0) + 1, this._allPreviousSaves = this._allPreviousSaves || t.Promise.as(), this._allPreviousSaves = this._allPreviousSaves._continueWith(function () {
        var e = d.id ? 'PUT' : 'POST', i = d._getSaveJSON(), r = 'classes', u = d.className;
        '_User' !== d.className || d.id || (r = 'users', u = null);
        var c = t._request({
            route: r,
            className: u,
            objectId: d.id,
            method: e,
            useMasterKey: o.useMasterKey,
            data: i
          });
        return c = c.then(function (e, t, i) {
          var r = d.parse(e, t, i);
          return o.wait && (r = n.extend(s || {}, r)), d._finishSave(r), o.wait && d.set(a, l), d;
        }, function (e) {
          return d._cancelSave(), t.Promise.error(e);
        })._thenRunCallbacks(o, d);
      }), this._allPreviousSaves);
    },
    destroy: function (e) {
      e = e || {};
      var n = this, i = function () {
          n.trigger('destroy', n, n.collection, e);
        };
      if (!this.id)
        return i();
      e.wait || i();
      var r = t._request({
          route: 'classes',
          className: this.className,
          objectId: this.id,
          method: 'DELETE',
          useMasterKey: e.useMasterKey
        });
      return r.then(function () {
        return e.wait && i(), n;
      })._thenRunCallbacks(e, this);
    },
    parse: function (e, i) {
      var r = n.clone(e);
      return n([
        'createdAt',
        'updatedAt'
      ]).each(function (e) {
        r[e] && (r[e] = t._parseDate(r[e]));
      }), r.updatedAt || (r.updatedAt = r.createdAt), i && (this._existed = 201 !== i), r;
    },
    clone: function () {
      return new this.constructor(this.attributes);
    },
    isNew: function () {
      return !this.id;
    },
    change: function (e) {
      e = e || {};
      var i = this._changing;
      this._changing = !0;
      var r = this;
      t._objectEach(this._silent, function (e) {
        r._pending[e] = !0;
      });
      var s = n.extend({}, e.changes, this._silent);
      if (this._silent = {}, t._objectEach(s, function (t, n) {
          r.trigger('change:' + n, r, r.get(n), e);
        }), i)
        return this;
      for (var a = function (e, t) {
          r._pending[t] || r._silent[t] || delete r.changed[t];
        }; !n.isEmpty(this._pending);)
        this._pending = {}, this.trigger('change', this, e), t._objectEach(this.changed, a), r._previousAttributes = n.clone(this.attributes);
      return this._changing = !1, this;
    },
    existed: function () {
      return this._existed;
    },
    hasChanged: function (e) {
      return arguments.length ? this.changed && n.has(this.changed, e) : !n.isEmpty(this.changed);
    },
    changedAttributes: function (e) {
      if (!e)
        return this.hasChanged() ? n.clone(this.changed) : !1;
      var i = {}, r = this._previousAttributes;
      return t._objectEach(e, function (e, t) {
        n.isEqual(r[t], e) || (i[t] = e);
      }), i;
    },
    previous: function (e) {
      return arguments.length && this._previousAttributes ? this._previousAttributes[e] : null;
    },
    previousAttributes: function () {
      return n.clone(this._previousAttributes);
    },
    isValid: function () {
      return !this.validate(this.attributes);
    },
    validate: function (e) {
      if (n.has(e, 'ACL') && !(e.ACL instanceof t.ACL))
        return new t.Error(t.Error.OTHER_CAUSE, 'ACL must be a Parse.ACL.');
      var i = !0;
      return t._objectEach(e, function (e, t) {
        /^[A-Za-z][0-9A-Za-z_]*$/.test(t) || (i = !1);
      }), i ? !1 : new t.Error(t.Error.INVALID_KEY_NAME);
    },
    _validate: function (e, t) {
      if (t.silent || !this.validate)
        return !0;
      e = n.extend({}, this.attributes, e);
      var i = this.validate(e, t);
      return i ? (t && t.error ? t.error(this, i, t) : this.trigger('error', this, i, t), !1) : !0;
    },
    getACL: function () {
      return this.get('ACL');
    },
    setACL: function (e, t) {
      return this.set('ACL', e, t);
    }
  }), t.Object._getSubclass = function (e) {
    if (!n.isString(e))
      throw 'Parse.Object._getSubclass requires a string argument.';
    var i = t.Object._classMap[e];
    return i || (i = t.Object.extend(e), t.Object._classMap[e] = i), i;
  }, t.Object._create = function (e, n, i) {
    var r = t.Object._getSubclass(e);
    return new r(n, i);
  }, t.Object._toObjectIdArray = function (e, n) {
    if (0 === e.length)
      return t.Promise.as(e);
    for (var i, r = e[0].className, s = [], a = 0; e.length > a; a++) {
      var o = e[a];
      if (r !== o.className)
        return i = new t.Error(t.Error.INVALID_CLASS_NAME, 'All objects should be of the same class'), t.Promise.error(i);
      if (!o.id)
        return i = new t.Error(t.Error.MISSING_OBJECT_ID, 'All objects must have an ID'), t.Promise.error(i);
      n && o._hasData || s.push(o.id);
    }
    return t.Promise.as(s);
  }, t.Object._updateWithFetchedResults = function (e, n, i) {
    var r = {};
    t._arrayEach(n, function (e) {
      r[e.id] = e;
    });
    for (var s = 0; e.length > s; s++) {
      var a = e[s], o = r[a.id];
      if (!o && i) {
        var u = new t.Error(t.Error.OBJECT_NOT_FOUND, 'All objects must exist on the server');
        return t.Promise.error(u);
      }
      a._mergeFromObject(o);
    }
    return t.Promise.as(e);
  }, t.Object._fetchAll = function (e, n) {
    if (0 === e.length)
      return t.Promise.as(e);
    var i = !n;
    return t.Object._toObjectIdArray(e, i).then(function (n) {
      var i = e[0].className, r = new t.Query(i);
      return r.containedIn('objectId', n), r.limit = n.length, r.find();
    }).then(function (i) {
      return t.Object._updateWithFetchedResults(e, i, n);
    });
  }, t.Object._classMap = {}, t.Object._extend = t._extend, t.Object.extend = function (e, i, r) {
    if (!n.isString(e)) {
      if (e && n.has(e, 'className'))
        return t.Object.extend(e.className, e, i);
      throw Error('Parse.Object.extend\'s first argument should be the className.');
    }
    'User' === e && t.User._performUserRewrite && (e = '_User'), i = i || {}, i.className = e;
    var s = null;
    if (n.has(t.Object._classMap, e)) {
      var a = t.Object._classMap[e];
      s = a._extend(i, r);
    } else
      s = this._extend(i, r);
    return s.extend = function (i) {
      if (n.isString(i) || i && n.has(i, 'className'))
        return t.Object.extend.apply(s, arguments);
      var r = [e].concat(t._.toArray(arguments));
      return t.Object.extend.apply(s, r);
    }, t.Object._classMap[e] = s, s;
  }, t.Object._findUnsavedChildren = function (e, n, i) {
    t._traverse(e, function (e) {
      return e instanceof t.Object ? (e._refreshCache(), e.dirty() && n.push(e), void 0) : e instanceof t.File ? (e.url() || i.push(e), void 0) : void 0;
    });
  }, t.Object._canBeSerializedAsValue = function (e) {
    if (e instanceof t.Object)
      return !!e.id;
    if (e instanceof t.File)
      return !0;
    var i = !0;
    return n.isArray(e) ? t._arrayEach(e, function (e) {
      t.Object._canBeSerializedAsValue(e) || (i = !1);
    }) : n.isObject(e) && t._objectEach(e, function (e) {
      t.Object._canBeSerializedAsValue(e) || (i = !1);
    }), i;
  }, t.Object._deepSaveAsync = function (e, i) {
    var r = [], s = [];
    t.Object._findUnsavedChildren(e, r, s);
    var a = t.Promise.as();
    n.each(s, function (e) {
      a = a.then(function () {
        return e.save(i);
      });
    });
    var o = n.uniq(r), u = n.uniq(o);
    return a.then(function () {
      return t.Promise._continueWhile(function () {
        return u.length > 0;
      }, function () {
        var e = [], r = [];
        if (t._arrayEach(u, function (t) {
            return e.length > 20 ? (r.push(t), void 0) : (t._canBeSerialized() ? e.push(t) : r.push(t), void 0);
          }), u = r, 0 === e.length)
          return t.Promise.error(new t.Error(t.Error.OTHER_CAUSE, 'Tried to save a batch with a cycle.'));
        var s = t.Promise.when(n.map(e, function (e) {
            return e._allPreviousSaves || t.Promise.as();
          })), a = new t.Promise();
        return t._arrayEach(e, function (e) {
          e._allPreviousSaves = a;
        }), s._continueWith(function () {
          return t._request({
            route: 'batch',
            method: 'POST',
            useMasterKey: i.useMasterKey,
            data: {
              requests: n.map(e, function (e) {
                var t = e._getSaveJSON(), n = 'POST', i = '/1/classes/' + e.className;
                return e.id && (i = i + '/' + e.id, n = 'PUT'), e._startSave(), {
                  method: n,
                  path: i,
                  body: t
                };
              })
            }
          }).then(function (n, i, r) {
            var s;
            return t._arrayEach(e, function (e, t) {
              n[t].success ? e._finishSave(e.parse(n[t].success, i, r)) : (s = s || n[t].error, e._cancelSave());
            }), s ? t.Promise.error(new t.Error(s.code, s.error)) : void 0;
          }).then(function (e) {
            return a.resolve(e), e;
          }, function (e) {
            return a.reject(e), t.Promise.error(e);
          });
        });
      });
    }).then(function () {
      return e;
    });
  };
}(this), function (e) {
  e.Parse = e.Parse || {};
  var t = e.Parse, n = t._;
  t.Role = t.Object.extend('_Role', {
    constructor: function (e, i) {
      n.isString(e) && i instanceof t.ACL ? (t.Object.prototype.constructor.call(this, null, null), this.setName(e), this.setACL(i)) : t.Object.prototype.constructor.call(this, e, i);
    },
    getName: function () {
      return this.get('name');
    },
    setName: function (e, t) {
      return this.set('name', e, t);
    },
    getUsers: function () {
      return this.relation('users');
    },
    getRoles: function () {
      return this.relation('roles');
    },
    validate: function (e, i) {
      if ('name' in e && e.name !== this.getName()) {
        var r = e.name;
        if (this.id && this.id !== e.objectId)
          return new t.Error(t.Error.OTHER_CAUSE, 'A role\'s name can only be set before it has been saved.');
        if (!n.isString(r))
          return new t.Error(t.Error.OTHER_CAUSE, 'A role\'s name must be a String.');
        if (!/^[0-9a-zA-Z\-_ ]+$/.test(r))
          return new t.Error(t.Error.OTHER_CAUSE, 'A role\'s name can only contain alphanumeric characters, _, -, and spaces.');
      }
      return t.Object.prototype.validate ? t.Object.prototype.validate.call(this, e, i) : !1;
    }
  });
}(this), function (e) {
  e.Parse = e.Parse || {};
  var t = e.Parse, n = t._;
  t.Collection = function (e, t) {
    t = t || {}, t.comparator && (this.comparator = t.comparator), t.model && (this.model = t.model), t.query && (this.query = t.query), this._reset(), this.initialize.apply(this, arguments), e && this.reset(e, {
      silent: !0,
      parse: t.parse
    });
  }, n.extend(t.Collection.prototype, t.Events, {
    model: t.Object,
    initialize: function () {
    },
    toJSON: function () {
      return this.map(function (e) {
        return e.toJSON();
      });
    },
    add: function (e, i) {
      var r, s, a, o, u, c, l = {}, h = {};
      for (i = i || {}, e = n.isArray(e) ? e.slice() : [e], r = 0, a = e.length; a > r; r++) {
        if (e[r] = this._prepareModel(e[r], i), o = e[r], !o)
          throw Error('Can\'t add an invalid model to a collection');
        if (u = o.cid, l[u] || this._byCid[u])
          throw Error('Duplicate cid: can\'t add the same model to a collection twice');
        if (c = o.id, !t._isNullOrUndefined(c) && (h[c] || this._byId[c]))
          throw Error('Duplicate id: can\'t add the same model to a collection twice');
        h[c] = o, l[u] = o;
      }
      for (r = 0; a > r; r++)
        (o = e[r]).on('all', this._onModelEvent, this), this._byCid[o.cid] = o, o.id && (this._byId[o.id] = o);
      if (this.length += a, s = t._isNullOrUndefined(i.at) ? this.models.length : i.at, this.models.splice.apply(this.models, [
          s,
          0
        ].concat(e)), this.comparator && this.sort({ silent: !0 }), i.silent)
        return this;
      for (r = 0, a = this.models.length; a > r; r++)
        o = this.models[r], l[o.cid] && (i.index = r, o.trigger('add', o, this, i));
      return this;
    },
    remove: function (e, t) {
      var i, r, s, a;
      for (t = t || {}, e = n.isArray(e) ? e.slice() : [e], i = 0, r = e.length; r > i; i++)
        a = this.getByCid(e[i]) || this.get(e[i]), a && (delete this._byId[a.id], delete this._byCid[a.cid], s = this.indexOf(a), this.models.splice(s, 1), this.length--, t.silent || (t.index = s, a.trigger('remove', a, this, t)), this._removeReference(a));
      return this;
    },
    get: function (e) {
      return e && this._byId[e.id || e];
    },
    getByCid: function (e) {
      return e && this._byCid[e.cid || e];
    },
    at: function (e) {
      return this.models[e];
    },
    sort: function (e) {
      if (e = e || {}, !this.comparator)
        throw Error('Cannot sort a set without a comparator');
      var t = n.bind(this.comparator, this);
      return 1 === this.comparator.length ? this.models = this.sortBy(t) : this.models.sort(t), e.silent || this.trigger('reset', this, e), this;
    },
    pluck: function (e) {
      return n.map(this.models, function (t) {
        return t.get(e);
      });
    },
    reset: function (e, n) {
      var i = this;
      return e = e || [], n = n || {}, t._arrayEach(this.models, function (e) {
        i._removeReference(e);
      }), this._reset(), this.add(e, {
        silent: !0,
        parse: n.parse
      }), n.silent || this.trigger('reset', this, n), this;
    },
    fetch: function (e) {
      e = n.clone(e) || {}, void 0 === e.parse && (e.parse = !0);
      var i = this, r = this.query || new t.Query(this.model);
      return r.find({ useMasterKey: e.useMasterKey }).then(function (t) {
        return e.add ? i.add(t, e) : i.reset(t, e), i;
      })._thenRunCallbacks(e, this);
    },
    create: function (e, t) {
      var i = this;
      if (t = t ? n.clone(t) : {}, e = this._prepareModel(e, t), !e)
        return !1;
      t.wait || i.add(e, t);
      var r = t.success;
      return t.success = function (n, s) {
        t.wait && i.add(n, t), r ? r(n, s) : n.trigger('sync', e, s, t);
      }, e.save(null, t), e;
    },
    parse: function (e) {
      return e;
    },
    chain: function () {
      return n(this.models).chain();
    },
    _reset: function () {
      this.length = 0, this.models = [], this._byId = {}, this._byCid = {};
    },
    _prepareModel: function (e, n) {
      if (e instanceof t.Object)
        e.collection || (e.collection = this);
      else {
        var i = e;
        n.collection = this, e = new this.model(i, n), e._validate(e.attributes, n) || (e = !1);
      }
      return e;
    },
    _removeReference: function (e) {
      this === e.collection && delete e.collection, e.off('all', this._onModelEvent, this);
    },
    _onModelEvent: function (e, t, n, i) {
      ('add' !== e && 'remove' !== e || n === this) && ('destroy' === e && this.remove(t, i), t && 'change:objectId' === e && (delete this._byId[t.previous('objectId')], this._byId[t.id] = t), this.trigger.apply(this, arguments));
    }
  });
  var i = [
      'forEach',
      'each',
      'map',
      'reduce',
      'reduceRight',
      'find',
      'detect',
      'filter',
      'select',
      'reject',
      'every',
      'all',
      'some',
      'any',
      'include',
      'contains',
      'invoke',
      'max',
      'min',
      'sortBy',
      'sortedIndex',
      'toArray',
      'size',
      'first',
      'initial',
      'rest',
      'last',
      'without',
      'indexOf',
      'shuffle',
      'lastIndexOf',
      'isEmpty',
      'groupBy'
    ];
  t._arrayEach(i, function (e) {
    t.Collection.prototype[e] = function () {
      return n[e].apply(n, [this.models].concat(n.toArray(arguments)));
    };
  }), t.Collection.extend = t._extend;
}(this), function (e) {
  e.Parse = e.Parse || {};
  var t = e.Parse, n = t._;
  t.View = function (e) {
    this.cid = n.uniqueId('view'), this._configure(e || {}), this._ensureElement(), this.initialize.apply(this, arguments), this.delegateEvents();
  };
  var i = /^(\S+)\s*(.*)$/, r = [
      'model',
      'collection',
      'el',
      'id',
      'attributes',
      'className',
      'tagName'
    ];
  n.extend(t.View.prototype, t.Events, {
    tagName: 'div',
    $: function (e) {
      return this.$el.find(e);
    },
    initialize: function () {
    },
    render: function () {
      return this;
    },
    remove: function () {
      return this.$el.remove(), this;
    },
    make: function (e, n, i) {
      var r = document.createElement(e);
      return n && t.$(r).attr(n), i && t.$(r).html(i), r;
    },
    setElement: function (e, n) {
      return this.$el = t.$(e), this.el = this.$el[0], n !== !1 && this.delegateEvents(), this;
    },
    delegateEvents: function (e) {
      if (e = e || t._getValue(this, 'events')) {
        this.undelegateEvents();
        var r = this;
        t._objectEach(e, function (t, s) {
          if (n.isFunction(t) || (t = r[e[s]]), !t)
            throw Error('Event "' + e[s] + '" does not exist');
          var a = s.match(i), o = a[1], u = a[2];
          t = n.bind(t, r), o += '.delegateEvents' + r.cid, '' === u ? r.$el.bind(o, t) : r.$el.delegate(u, o, t);
        });
      }
    },
    undelegateEvents: function () {
      this.$el.unbind('.delegateEvents' + this.cid);
    },
    _configure: function (e) {
      this.options && (e = n.extend({}, this.options, e));
      var t = this;
      n.each(r, function (n) {
        e[n] && (t[n] = e[n]);
      }), this.options = e;
    },
    _ensureElement: function () {
      if (this.el)
        this.setElement(this.el, !1);
      else {
        var e = t._getValue(this, 'attributes') || {};
        this.id && (e.id = this.id), this.className && (e['class'] = this.className), this.setElement(this.make(this.tagName, e), !1);
      }
    }
  }), t.View.extend = t._extend;
}(this), function (e) {
  e.Parse = e.Parse || {};
  var t = e.Parse, n = t._;
  t.User = t.Object.extend('_User', {
    _isCurrentUser: !1,
    _mergeFromObject: function (e) {
      e.getSessionToken() && (this._sessionToken = e.getSessionToken()), t.User.__super__._mergeFromObject.call(this, e);
    },
    _mergeMagicFields: function (e) {
      e.sessionToken && (this._sessionToken = e.sessionToken, delete e.sessionToken), t.User.__super__._mergeMagicFields.call(this, e);
    },
    _cleanupAuthData: function () {
      if (this.isCurrent()) {
        var e = this.get('authData');
        e && t._objectEach(this.get('authData'), function (t, n) {
          e[n] || delete e[n];
        });
      }
    },
    _synchronizeAllAuthData: function () {
      var e = this.get('authData');
      if (e) {
        var n = this;
        t._objectEach(this.get('authData'), function (e, t) {
          n._synchronizeAuthData(t);
        });
      }
    },
    _synchronizeAuthData: function (e) {
      if (this.isCurrent()) {
        var i;
        n.isString(e) ? (i = e, e = t.User._authProviders[i]) : i = e.getAuthType();
        var r = this.get('authData');
        if (r && e) {
          var s = e.restoreAuthentication(r[i]);
          s || this._unlinkFrom(e);
        }
      }
    },
    _handleSaveResult: function (e) {
      e && (this._isCurrentUser = !0), this._cleanupAuthData(), this._synchronizeAllAuthData(), delete this._serverData.password, this._rebuildEstimatedDataForKey('password'), this._refreshCache(), (e || this.isCurrent()) && t.User._saveCurrentUser(this);
    },
    _linkWith: function (e, i) {
      var r;
      if (n.isString(e) ? (r = e, e = t.User._authProviders[e]) : r = e.getAuthType(), n.has(i, 'authData')) {
        var s = this.get('authData') || {};
        s[r] = i.authData, this.set('authData', s);
        var a = n.clone(i) || {};
        return a.success = function (e) {
          e._handleSaveResult(!0), i.success && i.success.apply(this, arguments);
        }, this.save({ authData: s }, a);
      }
      var o = this, u = new t.Promise();
      return e.authenticate({
        success: function (e, t) {
          o._linkWith(e, {
            authData: t,
            success: i.success,
            error: i.error
          }).then(function () {
            u.resolve(o);
          });
        },
        error: function (e, t) {
          i.error && i.error(o, t), u.reject(t);
        }
      }), u;
    },
    _unlinkFrom: function (e, i) {
      var r;
      n.isString(e) ? (r = e, e = t.User._authProviders[e]) : r = e.getAuthType();
      var s = n.clone(i), a = this;
      return s.authData = null, s.success = function () {
        a._synchronizeAuthData(e), i.success && i.success.apply(this, arguments);
      }, this._linkWith(e, s);
    },
    _isLinked: function (e) {
      var t;
      t = n.isString(e) ? e : e.getAuthType();
      var i = this.get('authData') || {};
      return !!i[t];
    },
    _logOutWithAll: function () {
      var e = this.get('authData');
      if (e) {
        var n = this;
        t._objectEach(this.get('authData'), function (e, t) {
          n._logOutWith(t);
        });
      }
    },
    _logOutWith: function (e) {
      this.isCurrent() && (n.isString(e) && (e = t.User._authProviders[e]), e && e.deauthenticate && e.deauthenticate());
    },
    signUp: function (e, i) {
      var r;
      i = i || {};
      var s = e && e.username || this.get('username');
      if (!s || '' === s)
        return r = new t.Error(t.Error.OTHER_CAUSE, 'Cannot sign up user with an empty name.'), i && i.error && i.error(this, r), t.Promise.error(r);
      var a = e && e.password || this.get('password');
      if (!a || '' === a)
        return r = new t.Error(t.Error.OTHER_CAUSE, 'Cannot sign up user with an empty password.'), i && i.error && i.error(this, r), t.Promise.error(r);
      var o = n.clone(i);
      return o.success = function (e) {
        e._handleSaveResult(!0), i.success && i.success.apply(this, arguments);
      }, this.save(e, o);
    },
    logIn: function (e) {
      var n = this;
      e = e || {};
      var i = t._request({
          route: 'login',
          method: 'GET',
          useMasterKey: e.useMasterKey,
          data: this.toJSON()
        });
      return i.then(function (e, t, i) {
        var r = n.parse(e, t, i);
        return n._finishFetch(r), n._handleSaveResult(!0), n;
      })._thenRunCallbacks(e, this);
    },
    save: function (e, i, r) {
      var s, a;
      n.isObject(e) || n.isNull(e) || n.isUndefined(e) ? (s = e, a = i) : (s = {}, s[e] = i, a = r), a = a || {};
      var o = n.clone(a);
      return o.success = function (e) {
        e._handleSaveResult(!1), a.success && a.success.apply(this, arguments);
      }, t.Object.prototype.save.call(this, s, o);
    },
    fetch: function (e) {
      var i = e ? n.clone(e) : {};
      return i.success = function (t) {
        t._handleSaveResult(!1), e && e.success && e.success.apply(this, arguments);
      }, t.Object.prototype.fetch.call(this, i);
    },
    isCurrent: function () {
      return this._isCurrentUser;
    },
    getUsername: function () {
      return this.get('username');
    },
    setUsername: function (e, t) {
      return this.set('username', e, t);
    },
    setPassword: function (e, t) {
      return this.set('password', e, t);
    },
    getEmail: function () {
      return this.get('email');
    },
    setEmail: function (e, t) {
      return this.set('email', e, t);
    },
    authenticated: function () {
      return !!this._sessionToken && t.User.current() && t.User.current().id === this.id;
    },
    getSessionToken: function () {
      return this._sessionToken;
    }
  }, {
    _currentUser: null,
    _currentUserMatchesDisk: !1,
    _CURRENT_USER_KEY: 'currentUser',
    _authProviders: {},
    _performUserRewrite: !0,
    signUp: function (e, n, i, r) {
      i = i || {}, i.username = e, i.password = n;
      var s = t.Object._create('_User');
      return s.signUp(i, r);
    },
    logIn: function (e, n, i) {
      var r = t.Object._create('_User');
      return r._finishFetch({
        username: e,
        password: n
      }), r.logIn(i);
    },
    become: function (e, n) {
      n = n || {};
      var i = t.Object._create('_User');
      return t._request({
        route: 'users',
        className: 'me',
        method: 'GET',
        useMasterKey: n.useMasterKey,
        sessionToken: e
      }).then(function (e, t, n) {
        var r = i.parse(e, t, n);
        return i._finishFetch(r), i._handleSaveResult(!0), i;
      })._thenRunCallbacks(n, i);
    },
    logOut: function () {
      null !== t.User._currentUser && (t.User._currentUser._logOutWithAll(), t.User._currentUser._isCurrentUser = !1), t.User._currentUserMatchesDisk = !0, t.User._currentUser = null, t.localStorage.removeItem(t._getParsePath(t.User._CURRENT_USER_KEY));
    },
    requestPasswordReset: function (e, n) {
      n = n || {};
      var i = t._request({
          route: 'requestPasswordReset',
          method: 'POST',
          useMasterKey: n.useMasterKey,
          data: { email: e }
        });
      return i._thenRunCallbacks(n);
    },
    current: function () {
      if (t.User._currentUser)
        return t.User._currentUser;
      if (t.User._currentUserMatchesDisk)
        return t.User._currentUser;
      t.User._currentUserMatchesDisk = !0;
      var e = t.localStorage.getItem(t._getParsePath(t.User._CURRENT_USER_KEY));
      if (!e)
        return null;
      t.User._currentUser = t.Object._create('_User'), t.User._currentUser._isCurrentUser = !0;
      var n = JSON.parse(e);
      return t.User._currentUser.id = n._id, delete n._id, t.User._currentUser._sessionToken = n._sessionToken, delete n._sessionToken, t.User._currentUser.set(n), t.User._currentUser._synchronizeAllAuthData(), t.User._currentUser._refreshCache(), t.User._currentUser._opSetQueue = [{}], t.User._currentUser;
    },
    allowCustomUserClass: function (e) {
      this._performUserRewrite = !e;
    },
    _saveCurrentUser: function (e) {
      t.User._currentUser !== e && t.User.logOut(), e._isCurrentUser = !0, t.User._currentUser = e, t.User._currentUserMatchesDisk = !0;
      var n = e.toJSON();
      n._id = e.id, n._sessionToken = e._sessionToken, t.localStorage.setItem(t._getParsePath(t.User._CURRENT_USER_KEY), JSON.stringify(n));
    },
    _registerAuthenticationProvider: function (e) {
      t.User._authProviders[e.getAuthType()] = e, t.User.current() && t.User.current()._synchronizeAuthData(e.getAuthType());
    },
    _logInWith: function (e, n) {
      var i = t.Object._create('_User');
      return i._linkWith(e, n);
    }
  });
}(this), function (e) {
  e.Parse = e.Parse || {};
  var t = e.Parse, n = t._;
  t.Query = function (e) {
    n.isString(e) && (e = t.Object._getSubclass(e)), this.objectClass = e, this.className = e.prototype.className, this._where = {}, this._include = [], this._limit = -1, this._skip = 0, this._extraOptions = {};
  }, t.Query.or = function () {
    var e = n.toArray(arguments), i = null;
    t._arrayEach(e, function (e) {
      if (n.isNull(i) && (i = e.className), i !== e.className)
        throw 'All queries must be for the same class';
    });
    var r = new t.Query(i);
    return r._orQuery(e), r;
  }, t.Query.prototype = {
    get: function (e, i) {
      var r = this;
      r.equalTo('objectId', e);
      var s = {};
      return i && n.has(i, 'useMasterKey') && (s = { useMasterKey: i.useMasterKey }), r.first(s).then(function (e) {
        if (e)
          return e;
        var n = new t.Error(t.Error.OBJECT_NOT_FOUND, 'Object not found.');
        return t.Promise.error(n);
      })._thenRunCallbacks(i, null);
    },
    toJSON: function () {
      var e = { where: this._where };
      return this._include.length > 0 && (e.include = this._include.join(',')), this._select && (e.keys = this._select.join(',')), this._limit >= 0 && (e.limit = this._limit), this._skip > 0 && (e.skip = this._skip), void 0 !== this._order && (e.order = this._order.join(',')), t._objectEach(this._extraOptions, function (t, n) {
        e[n] = t;
      }), e;
    },
    find: function (e) {
      var i = this;
      e = e || {};
      var r = t._request({
          route: 'classes',
          className: this.className,
          method: 'GET',
          useMasterKey: e.useMasterKey,
          data: this.toJSON()
        });
      return r.then(function (e) {
        return n.map(e.results, function (n) {
          var r;
          return r = e.className ? new t.Object(e.className) : new i.objectClass(), r._finishFetch(n, !0), r;
        });
      })._thenRunCallbacks(e);
    },
    count: function (e) {
      var n = this;
      e = e || {};
      var i = this.toJSON();
      i.limit = 0, i.count = 1;
      var r = t._request({
          route: 'classes',
          className: n.className,
          method: 'GET',
          useMasterKey: e.useMasterKey,
          data: i
        });
      return r.then(function (e) {
        return e.count;
      })._thenRunCallbacks(e);
    },
    first: function (e) {
      var i = this;
      e = e || {};
      var r = this.toJSON();
      r.limit = 1;
      var s = t._request({
          route: 'classes',
          className: this.className,
          method: 'GET',
          useMasterKey: e.useMasterKey,
          data: r
        });
      return s.then(function (e) {
        return n.map(e.results, function (e) {
          var t = new i.objectClass();
          return t._finishFetch(e, !0), t;
        })[0];
      })._thenRunCallbacks(e);
    },
    collection: function (e, i) {
      return i = i || {}, new t.Collection(e, n.extend(i, {
        model: this.objectClass,
        query: this
      }));
    },
    skip: function (e) {
      return this._skip = e, this;
    },
    limit: function (e) {
      return this._limit = e, this;
    },
    equalTo: function (e, i) {
      return n.isUndefined(i) ? this.doesNotExist(e) : (this._where[e] = t._encode(i), this);
    },
    _addCondition: function (e, n, i) {
      return this._where[e] || (this._where[e] = {}), this._where[e][n] = t._encode(i), this;
    },
    notEqualTo: function (e, t) {
      return this._addCondition(e, '$ne', t), this;
    },
    lessThan: function (e, t) {
      return this._addCondition(e, '$lt', t), this;
    },
    greaterThan: function (e, t) {
      return this._addCondition(e, '$gt', t), this;
    },
    lessThanOrEqualTo: function (e, t) {
      return this._addCondition(e, '$lte', t), this;
    },
    greaterThanOrEqualTo: function (e, t) {
      return this._addCondition(e, '$gte', t), this;
    },
    containedIn: function (e, t) {
      return this._addCondition(e, '$in', t), this;
    },
    notContainedIn: function (e, t) {
      return this._addCondition(e, '$nin', t), this;
    },
    containsAll: function (e, t) {
      return this._addCondition(e, '$all', t), this;
    },
    exists: function (e) {
      return this._addCondition(e, '$exists', !0), this;
    },
    doesNotExist: function (e) {
      return this._addCondition(e, '$exists', !1), this;
    },
    matches: function (e, t, n) {
      return this._addCondition(e, '$regex', t), n || (n = ''), t.ignoreCase && (n += 'i'), t.multiline && (n += 'm'), n && n.length && this._addCondition(e, '$options', n), this;
    },
    matchesQuery: function (e, t) {
      var n = t.toJSON();
      return n.className = t.className, this._addCondition(e, '$inQuery', n), this;
    },
    doesNotMatchQuery: function (e, t) {
      var n = t.toJSON();
      return n.className = t.className, this._addCondition(e, '$notInQuery', n), this;
    },
    matchesKeyInQuery: function (e, t, n) {
      var i = n.toJSON();
      return i.className = n.className, this._addCondition(e, '$select', {
        key: t,
        query: i
      }), this;
    },
    doesNotMatchKeyInQuery: function (e, t, n) {
      var i = n.toJSON();
      return i.className = n.className, this._addCondition(e, '$dontSelect', {
        key: t,
        query: i
      }), this;
    },
    _orQuery: function (e) {
      var t = n.map(e, function (e) {
          return e.toJSON().where;
        });
      return this._where.$or = t, this;
    },
    _quote: function (e) {
      return '\\Q' + e.replace('\\E', '\\E\\\\E\\Q') + '\\E';
    },
    contains: function (e, t) {
      return this._addCondition(e, '$regex', this._quote(t)), this;
    },
    startsWith: function (e, t) {
      return this._addCondition(e, '$regex', '^' + this._quote(t)), this;
    },
    endsWith: function (e, t) {
      return this._addCondition(e, '$regex', this._quote(t) + '$'), this;
    },
    ascending: function () {
      return this._order = [], this.addAscending.apply(this, arguments);
    },
    addAscending: function () {
      var e = this;
      return this._order || (this._order = []), t._arrayEach(arguments, function (t) {
        Array.isArray(t) && (t = t.join()), e._order = e._order.concat(t.replace(/\s/g, '').split(','));
      }), this;
    },
    descending: function () {
      return this._order = [], this.addDescending.apply(this, arguments);
    },
    addDescending: function () {
      var e = this;
      return this._order || (this._order = []), t._arrayEach(arguments, function (t) {
        Array.isArray(t) && (t = t.join()), e._order = e._order.concat(n.map(t.replace(/\s/g, '').split(','), function (e) {
          return '-' + e;
        }));
      }), this;
    },
    near: function (e, n) {
      return n instanceof t.GeoPoint || (n = new t.GeoPoint(n)), this._addCondition(e, '$nearSphere', n), this;
    },
    withinRadians: function (e, t, n) {
      return this.near(e, t), this._addCondition(e, '$maxDistance', n), this;
    },
    withinMiles: function (e, t, n) {
      return this.withinRadians(e, t, n / 3958.8);
    },
    withinKilometers: function (e, t, n) {
      return this.withinRadians(e, t, n / 6371);
    },
    withinGeoBox: function (e, n, i) {
      return n instanceof t.GeoPoint || (n = new t.GeoPoint(n)), i instanceof t.GeoPoint || (i = new t.GeoPoint(i)), this._addCondition(e, '$within', {
        $box: [
          n,
          i
        ]
      }), this;
    },
    include: function () {
      var e = this;
      return t._arrayEach(arguments, function (t) {
        n.isArray(t) ? e._include = e._include.concat(t) : e._include.push(t);
      }), this;
    },
    select: function () {
      var e = this;
      return this._select = this._select || [], t._arrayEach(arguments, function (t) {
        n.isArray(t) ? e._select = e._select.concat(t) : e._select.push(t);
      }), this;
    },
    each: function (e, i) {
      if (i = i || {}, this._order || this._skip || this._limit >= 0) {
        var r = 'Cannot iterate on a query with sort, skip, or limit.';
        return t.Promise.error(r)._thenRunCallbacks(i);
      }
      new t.Promise();
      var s = new t.Query(this.objectClass);
      s._limit = i.batchSize || 100, s._where = n.clone(this._where), s._include = n.clone(this._include), s.ascending('objectId');
      var a = !1;
      return t.Promise._continueWhile(function () {
        return !a;
      }, function () {
        return s.find().then(function (n) {
          var i = t.Promise.as();
          return t._.each(n, function (t) {
            i = i.then(function () {
              return e(t);
            });
          }), i.then(function () {
            n.length >= s._limit ? s.greaterThan('objectId', n[n.length - 1].id) : a = !0;
          });
        });
      })._thenRunCallbacks(i);
    }
  };
}(this), function (e) {
  e.Parse = e.Parse || {};
  var t, n, i = e.Parse, r = i._, s = !1, a = {
      authenticate: function (e) {
        var n = this;
        FB.login(function (t) {
          t.authResponse ? e.success && e.success(n, {
            id: t.authResponse.userID,
            access_token: t.authResponse.accessToken,
            expiration_date: new Date(1000 * t.authResponse.expiresIn + new Date().getTime()).toJSON()
          }) : e.error && e.error(n, t);
        }, { scope: t });
      },
      restoreAuthentication: function (e) {
        if (e) {
          var t = {
              userID: e.id,
              accessToken: e.access_token,
              expiresIn: (i._parseDate(e.expiration_date).getTime() - new Date().getTime()) / 1000
            }, s = r.clone(n);
          s.authResponse = t, s.status = !1;
          var a = FB.getAuthResponse();
          a && a.userID !== t.userID && FB.logout(), FB.init(s);
        }
        return !0;
      },
      getAuthType: function () {
        return 'facebook';
      },
      deauthenticate: function () {
        this.restoreAuthentication(null);
      }
    };
  i.FacebookUtils = {
    init: function (e) {
      if ('undefined' == typeof FB)
        throw 'The Facebook JavaScript SDK must be loaded before calling init.';
      if (n = r.clone(e) || {}, n.status && 'undefined' != typeof console) {
        var t = console.warn || console.log || function () {
          };
        t.call(console, 'The \'status\' flag passed into FB.init, when set to true, can interfere with Parse Facebook integration, so it has been suppressed. Please call FB.getLoginStatus() explicitly if you require this behavior.');
      }
      n.status = !1, FB.init(n), i.User._registerAuthenticationProvider(a), s = !0;
    },
    isLinked: function (e) {
      return e._isLinked('facebook');
    },
    logIn: function (e, n) {
      if (!e || r.isString(e)) {
        if (!s)
          throw 'You must initialize FacebookUtils before calling logIn.';
        return t = e, i.User._logInWith('facebook', n);
      }
      var a = r.clone(n) || {};
      return a.authData = e, i.User._logInWith('facebook', a);
    },
    link: function (e, n, i) {
      if (!n || r.isString(n)) {
        if (!s)
          throw 'You must initialize FacebookUtils before calling link.';
        return t = n, e._linkWith('facebook', i);
      }
      var a = r.clone(i) || {};
      return a.authData = n, e._linkWith('facebook', a);
    },
    unlink: function (e, t) {
      if (!s)
        throw 'You must initialize FacebookUtils before calling unlink.';
      return e._unlinkFrom('facebook', t);
    }
  };
}(this), function (e) {
  e.Parse = e.Parse || {};
  var t = e.Parse, n = t._;
  t.History = function () {
    this.handlers = [], n.bindAll(this, 'checkUrl');
  };
  var i = /^[#\/]/, r = /msie [\w.]+/;
  t.History.started = !1, n.extend(t.History.prototype, t.Events, {
    interval: 50,
    getHash: function (e) {
      var t = e ? e.location : window.location, n = t.href.match(/#(.*)$/);
      return n ? n[1] : '';
    },
    getFragment: function (e, n) {
      if (t._isNullOrUndefined(e))
        if (this._hasPushState || n) {
          e = window.location.pathname;
          var r = window.location.search;
          r && (e += r);
        } else
          e = this.getHash();
      return e.indexOf(this.options.root) || (e = e.substr(this.options.root.length)), e.replace(i, '');
    },
    start: function (e) {
      if (t.History.started)
        throw Error('Parse.history has already been started');
      t.History.started = !0, this.options = n.extend({}, { root: '/' }, this.options, e), this._wantsHashChange = this.options.hashChange !== !1, this._wantsPushState = !!this.options.pushState, this._hasPushState = !!(this.options.pushState && window.history && window.history.pushState);
      var s = this.getFragment(), a = document.documentMode, o = r.exec(navigator.userAgent.toLowerCase()) && (!a || 7 >= a);
      o && (this.iframe = t.$('<iframe src="javascript:0" tabindex="-1" />').hide().appendTo('body')[0].contentWindow, this.navigate(s)), this._hasPushState ? t.$(window).bind('popstate', this.checkUrl) : this._wantsHashChange && 'onhashchange' in window && !o ? t.$(window).bind('hashchange', this.checkUrl) : this._wantsHashChange && (this._checkUrlInterval = window.setInterval(this.checkUrl, this.interval)), this.fragment = s;
      var u = window.location, c = u.pathname === this.options.root;
      return this._wantsHashChange && this._wantsPushState && !this._hasPushState && !c ? (this.fragment = this.getFragment(null, !0), window.location.replace(this.options.root + '#' + this.fragment), !0) : (this._wantsPushState && this._hasPushState && c && u.hash && (this.fragment = this.getHash().replace(i, ''), window.history.replaceState({}, document.title, u.protocol + '//' + u.host + this.options.root + this.fragment)), this.options.silent ? void 0 : this.loadUrl());
    },
    stop: function () {
      t.$(window).unbind('popstate', this.checkUrl).unbind('hashchange', this.checkUrl), window.clearInterval(this._checkUrlInterval), t.History.started = !1;
    },
    route: function (e, t) {
      this.handlers.unshift({
        route: e,
        callback: t
      });
    },
    checkUrl: function () {
      var e = this.getFragment();
      return e === this.fragment && this.iframe && (e = this.getFragment(this.getHash(this.iframe))), e === this.fragment ? !1 : (this.iframe && this.navigate(e), this.loadUrl() || this.loadUrl(this.getHash()), void 0);
    },
    loadUrl: function (e) {
      var t = this.fragment = this.getFragment(e), i = n.any(this.handlers, function (e) {
          return e.route.test(t) ? (e.callback(t), !0) : void 0;
        });
      return i;
    },
    navigate: function (e, n) {
      if (!t.History.started)
        return !1;
      n && n !== !0 || (n = { trigger: n });
      var r = (e || '').replace(i, '');
      if (this.fragment !== r) {
        if (this._hasPushState) {
          0 !== r.indexOf(this.options.root) && (r = this.options.root + r), this.fragment = r;
          var s = n.replace ? 'replaceState' : 'pushState';
          window.history[s]({}, document.title, r);
        } else
          this._wantsHashChange ? (this.fragment = r, this._updateHash(window.location, r, n.replace), this.iframe && r !== this.getFragment(this.getHash(this.iframe)) && (n.replace || this.iframe.document.open().close(), this._updateHash(this.iframe.location, r, n.replace))) : window.location.assign(this.options.root + e);
        n.trigger && this.loadUrl(e);
      }
    },
    _updateHash: function (e, t, n) {
      if (n) {
        var i = ('' + e).replace(/(javascript:|#).*$/, '');
        e.replace(i + '#' + t);
      } else
        e.hash = t;
    }
  });
}(this), function (e) {
  e.Parse = e.Parse || {};
  var t = e.Parse, n = t._;
  t.Router = function (e) {
    e = e || {}, e.routes && (this.routes = e.routes), this._bindRoutes(), this.initialize.apply(this, arguments);
  };
  var i = /:\w+/g, r = /\*\w+/g, s = /[\-\[\]{}()+?.,\\\^\$\|#\s]/g;
  n.extend(t.Router.prototype, t.Events, {
    initialize: function () {
    },
    route: function (e, i, r) {
      return t.history = t.history || new t.History(), n.isRegExp(e) || (e = this._routeToRegExp(e)), r || (r = this[i]), t.history.route(e, n.bind(function (n) {
        var s = this._extractParameters(e, n);
        r && r.apply(this, s), this.trigger.apply(this, ['route:' + i].concat(s)), t.history.trigger('route', this, i, s);
      }, this)), this;
    },
    navigate: function (e, n) {
      t.history.navigate(e, n);
    },
    _bindRoutes: function () {
      if (this.routes) {
        var e = [];
        for (var t in this.routes)
          this.routes.hasOwnProperty(t) && e.unshift([
            t,
            this.routes[t]
          ]);
        for (var n = 0, i = e.length; i > n; n++)
          this.route(e[n][0], e[n][1], this[e[n][1]]);
      }
    },
    _routeToRegExp: function (e) {
      return e = e.replace(s, '\\$&').replace(i, '([^/]+)').replace(r, '(.*?)'), RegExp('^' + e + '$');
    },
    _extractParameters: function (e, t) {
      return e.exec(t).slice(1);
    }
  }), t.Router.extend = t._extend;
}(this), function (e) {
  e.Parse = e.Parse || {};
  var t = e.Parse, n = t._;
  t.Cloud = t.Cloud || {}, n.extend(t.Cloud, {
    run: function (e, n, i) {
      i = i || {};
      var r = t._request({
          route: 'functions',
          className: e,
          method: 'POST',
          useMasterKey: i.useMasterKey,
          data: t._encode(n, null, !0)
        });
      return r.then(function (e) {
        return t._decode(null, e).result;
      })._thenRunCallbacks(i);
    }
  });
}(this), function (e) {
  e.Parse = e.Parse || {};
  var t = e.Parse;
  t.Installation = t.Object.extend('_Installation'), t.Push = t.Push || {}, t.Push.send = function (e, n) {
    if (n = n || {}, e.where && (e.where = e.where.toJSON().where), e.push_time && (e.push_time = e.push_time.toJSON()), e.expiration_time && (e.expiration_time = e.expiration_time.toJSON()), e.expiration_time && e.expiration_interval)
      throw 'Both expiration_time and expiration_interval can\'t be set';
    var i = t._request({
        route: 'push',
        method: 'POST',
        data: e,
        useMasterKey: n.useMasterKey
      });
    return i._thenRunCallbacks(n);
  };
}(this));
/**
 * MD5 (Message-Digest Algorithm) http://www.webtoolkit.info/
 */
var MD5 = function (string) {
    function RotateLeft(lValue, iShiftBits) {
      return lValue << iShiftBits | lValue >>> 32 - iShiftBits;
    }
    function AddUnsigned(lX, lY) {
      var lX4, lY4, lX8, lY8, lResult;
      lX8 = lX & 2147483648;
      lY8 = lY & 2147483648;
      lX4 = lX & 1073741824;
      lY4 = lY & 1073741824;
      lResult = (lX & 1073741823) + (lY & 1073741823);
      if (lX4 & lY4) {
        return lResult ^ 2147483648 ^ lX8 ^ lY8;
      }
      if (lX4 | lY4) {
        if (lResult & 1073741824) {
          return lResult ^ 3221225472 ^ lX8 ^ lY8;
        } else {
          return lResult ^ 1073741824 ^ lX8 ^ lY8;
        }
      } else {
        return lResult ^ lX8 ^ lY8;
      }
    }
    function F(x, y, z) {
      return x & y | ~x & z;
    }
    function G(x, y, z) {
      return x & z | y & ~z;
    }
    function H(x, y, z) {
      return x ^ y ^ z;
    }
    function I(x, y, z) {
      return y ^ (x | ~z);
    }
    function FF(a, b, c, d, x, s, ac) {
      a = AddUnsigned(a, AddUnsigned(AddUnsigned(F(b, c, d), x), ac));
      return AddUnsigned(RotateLeft(a, s), b);
    }
    ;
    function GG(a, b, c, d, x, s, ac) {
      a = AddUnsigned(a, AddUnsigned(AddUnsigned(G(b, c, d), x), ac));
      return AddUnsigned(RotateLeft(a, s), b);
    }
    ;
    function HH(a, b, c, d, x, s, ac) {
      a = AddUnsigned(a, AddUnsigned(AddUnsigned(H(b, c, d), x), ac));
      return AddUnsigned(RotateLeft(a, s), b);
    }
    ;
    function II(a, b, c, d, x, s, ac) {
      a = AddUnsigned(a, AddUnsigned(AddUnsigned(I(b, c, d), x), ac));
      return AddUnsigned(RotateLeft(a, s), b);
    }
    ;
    function ConvertToWordArray(string) {
      var lWordCount;
      var lMessageLength = string.length;
      var lNumberOfWords_temp1 = lMessageLength + 8;
      var lNumberOfWords_temp2 = (lNumberOfWords_temp1 - lNumberOfWords_temp1 % 64) / 64;
      var lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
      var lWordArray = Array(lNumberOfWords - 1);
      var lBytePosition = 0;
      var lByteCount = 0;
      while (lByteCount < lMessageLength) {
        lWordCount = (lByteCount - lByteCount % 4) / 4;
        lBytePosition = lByteCount % 4 * 8;
        lWordArray[lWordCount] = lWordArray[lWordCount] | string.charCodeAt(lByteCount) << lBytePosition;
        lByteCount++;
      }
      lWordCount = (lByteCount - lByteCount % 4) / 4;
      lBytePosition = lByteCount % 4 * 8;
      lWordArray[lWordCount] = lWordArray[lWordCount] | 128 << lBytePosition;
      lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
      lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
      return lWordArray;
    }
    ;
    function WordToHex(lValue) {
      var WordToHexValue = '', WordToHexValue_temp = '', lByte, lCount;
      for (lCount = 0; lCount <= 3; lCount++) {
        lByte = lValue >>> lCount * 8 & 255;
        WordToHexValue_temp = '0' + lByte.toString(16);
        WordToHexValue = WordToHexValue + WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);
      }
      return WordToHexValue;
    }
    ;
    function Utf8Encode(string) {
      string = string.replace(/\r\n/g, '\n');
      var utftext = '';
      for (var n = 0; n < string.length; n++) {
        var c = string.charCodeAt(n);
        if (c < 128) {
          utftext += String.fromCharCode(c);
        } else if (c > 127 && c < 2048) {
          utftext += String.fromCharCode(c >> 6 | 192);
          utftext += String.fromCharCode(c & 63 | 128);
        } else {
          utftext += String.fromCharCode(c >> 12 | 224);
          utftext += String.fromCharCode(c >> 6 & 63 | 128);
          utftext += String.fromCharCode(c & 63 | 128);
        }
      }
      return utftext;
    }
    ;
    var x = Array();
    var k, AA, BB, CC, DD, a, b, c, d;
    var S11 = 7, S12 = 12, S13 = 17, S14 = 22;
    var S21 = 5, S22 = 9, S23 = 14, S24 = 20;
    var S31 = 4, S32 = 11, S33 = 16, S34 = 23;
    var S41 = 6, S42 = 10, S43 = 15, S44 = 21;
    string = Utf8Encode(string);
    x = ConvertToWordArray(string);
    a = 1732584193;
    b = 4023233417;
    c = 2562383102;
    d = 271733878;
    for (k = 0; k < x.length; k += 16) {
      AA = a;
      BB = b;
      CC = c;
      DD = d;
      a = FF(a, b, c, d, x[k + 0], S11, 3614090360);
      d = FF(d, a, b, c, x[k + 1], S12, 3905402710);
      c = FF(c, d, a, b, x[k + 2], S13, 606105819);
      b = FF(b, c, d, a, x[k + 3], S14, 3250441966);
      a = FF(a, b, c, d, x[k + 4], S11, 4118548399);
      d = FF(d, a, b, c, x[k + 5], S12, 1200080426);
      c = FF(c, d, a, b, x[k + 6], S13, 2821735955);
      b = FF(b, c, d, a, x[k + 7], S14, 4249261313);
      a = FF(a, b, c, d, x[k + 8], S11, 1770035416);
      d = FF(d, a, b, c, x[k + 9], S12, 2336552879);
      c = FF(c, d, a, b, x[k + 10], S13, 4294925233);
      b = FF(b, c, d, a, x[k + 11], S14, 2304563134);
      a = FF(a, b, c, d, x[k + 12], S11, 1804603682);
      d = FF(d, a, b, c, x[k + 13], S12, 4254626195);
      c = FF(c, d, a, b, x[k + 14], S13, 2792965006);
      b = FF(b, c, d, a, x[k + 15], S14, 1236535329);
      a = GG(a, b, c, d, x[k + 1], S21, 4129170786);
      d = GG(d, a, b, c, x[k + 6], S22, 3225465664);
      c = GG(c, d, a, b, x[k + 11], S23, 643717713);
      b = GG(b, c, d, a, x[k + 0], S24, 3921069994);
      a = GG(a, b, c, d, x[k + 5], S21, 3593408605);
      d = GG(d, a, b, c, x[k + 10], S22, 38016083);
      c = GG(c, d, a, b, x[k + 15], S23, 3634488961);
      b = GG(b, c, d, a, x[k + 4], S24, 3889429448);
      a = GG(a, b, c, d, x[k + 9], S21, 568446438);
      d = GG(d, a, b, c, x[k + 14], S22, 3275163606);
      c = GG(c, d, a, b, x[k + 3], S23, 4107603335);
      b = GG(b, c, d, a, x[k + 8], S24, 1163531501);
      a = GG(a, b, c, d, x[k + 13], S21, 2850285829);
      d = GG(d, a, b, c, x[k + 2], S22, 4243563512);
      c = GG(c, d, a, b, x[k + 7], S23, 1735328473);
      b = GG(b, c, d, a, x[k + 12], S24, 2368359562);
      a = HH(a, b, c, d, x[k + 5], S31, 4294588738);
      d = HH(d, a, b, c, x[k + 8], S32, 2272392833);
      c = HH(c, d, a, b, x[k + 11], S33, 1839030562);
      b = HH(b, c, d, a, x[k + 14], S34, 4259657740);
      a = HH(a, b, c, d, x[k + 1], S31, 2763975236);
      d = HH(d, a, b, c, x[k + 4], S32, 1272893353);
      c = HH(c, d, a, b, x[k + 7], S33, 4139469664);
      b = HH(b, c, d, a, x[k + 10], S34, 3200236656);
      a = HH(a, b, c, d, x[k + 13], S31, 681279174);
      d = HH(d, a, b, c, x[k + 0], S32, 3936430074);
      c = HH(c, d, a, b, x[k + 3], S33, 3572445317);
      b = HH(b, c, d, a, x[k + 6], S34, 76029189);
      a = HH(a, b, c, d, x[k + 9], S31, 3654602809);
      d = HH(d, a, b, c, x[k + 12], S32, 3873151461);
      c = HH(c, d, a, b, x[k + 15], S33, 530742520);
      b = HH(b, c, d, a, x[k + 2], S34, 3299628645);
      a = II(a, b, c, d, x[k + 0], S41, 4096336452);
      d = II(d, a, b, c, x[k + 7], S42, 1126891415);
      c = II(c, d, a, b, x[k + 14], S43, 2878612391);
      b = II(b, c, d, a, x[k + 5], S44, 4237533241);
      a = II(a, b, c, d, x[k + 12], S41, 1700485571);
      d = II(d, a, b, c, x[k + 3], S42, 2399980690);
      c = II(c, d, a, b, x[k + 10], S43, 4293915773);
      b = II(b, c, d, a, x[k + 1], S44, 2240044497);
      a = II(a, b, c, d, x[k + 8], S41, 1873313359);
      d = II(d, a, b, c, x[k + 15], S42, 4264355552);
      c = II(c, d, a, b, x[k + 6], S43, 2734768916);
      b = II(b, c, d, a, x[k + 13], S44, 1309151649);
      a = II(a, b, c, d, x[k + 4], S41, 4149444226);
      d = II(d, a, b, c, x[k + 11], S42, 3174756917);
      c = II(c, d, a, b, x[k + 2], S43, 718787259);
      b = II(b, c, d, a, x[k + 9], S44, 3951481745);
      a = AddUnsigned(a, AA);
      b = AddUnsigned(b, BB);
      c = AddUnsigned(c, CC);
      d = AddUnsigned(d, DD);
    }
    var temp = WordToHex(a) + WordToHex(b) + WordToHex(c) + WordToHex(d);
    return temp.toLowerCase();
  }  // Released under MIT license
     // Copyright (c) 2009-2010 Dominic Baggott
     // Copyright (c) 2009-2010 Ash Berlin
     // Copyright (c) 2011 Christoph Dorn <christoph@christophdorn.com> (http://www.christophdorn.com)
(function (expose) {
    /**
 *  class Markdown
 *
 *  Markdown processing in Javascript done right. We have very particular views
 *  on what constitutes 'right' which include:
 *
 *  - produces well-formed HTML (this means that em and strong nesting is
 *    important)
 *
 *  - has an intermediate representation to allow processing of parsed data (We
 *    in fact have two, both as [JsonML]: a markdown tree and an HTML tree).
 *
 *  - is easily extensible to add new dialects without having to rewrite the
 *    entire parsing mechanics
 *
 *  - has a good test suite
 *
 *  This implementation fulfills all of these (except that the test suite could
 *  do with expanding to automatically run all the fixtures from other Markdown
 *  implementations.)
 *
 *  ##### Intermediate Representation
 *
 *  *TODO* Talk about this :) Its JsonML, but document the node names we use.
 *
 *  [JsonML]: http://jsonml.org/ "JSON Markup Language"
 **/
    var Markdown = expose.Markdown = function Markdown(dialect) {
        switch (typeof dialect) {
        case 'undefined':
          this.dialect = Markdown.dialects.Gruber;
          break;
        case 'object':
          this.dialect = dialect;
          break;
        default:
          if (dialect in Markdown.dialects) {
            this.dialect = Markdown.dialects[dialect];
          } else {
            throw new Error('Unknown Markdown dialect \'' + String(dialect) + '\'');
          }
          break;
        }
        this.em_state = [];
        this.strong_state = [];
        this.debug_indent = '';
      };
    /**
 *  parse( markdown, [dialect] ) -> JsonML
 *  - markdown (String): markdown string to parse
 *  - dialect (String | Dialect): the dialect to use, defaults to gruber
 *
 *  Parse `markdown` and return a markdown document as a Markdown.JsonML tree.
 **/
    expose.parse = function (source, dialect) {
      // dialect will default if undefined
      var md = new Markdown(dialect);
      return md.toTree(source);
    };
    /**
 *  toHTML( markdown, [dialect]  ) -> String
 *  toHTML( md_tree ) -> String
 *  - markdown (String): markdown string to parse
 *  - md_tree (Markdown.JsonML): parsed markdown tree
 *
 *  Take markdown (either as a string or as a JsonML tree) and run it through
 *  [[toHTMLTree]] then turn it into a well-formated HTML fragment.
 **/
    expose.toHTML = function toHTML(source, dialect, options) {
      var input = expose.toHTMLTree(source, dialect, options);
      return expose.renderJsonML(input);
    };
    /**
 *  toHTMLTree( markdown, [dialect] ) -> JsonML
 *  toHTMLTree( md_tree ) -> JsonML
 *  - markdown (String): markdown string to parse
 *  - dialect (String | Dialect): the dialect to use, defaults to gruber
 *  - md_tree (Markdown.JsonML): parsed markdown tree
 *
 *  Turn markdown into HTML, represented as a JsonML tree. If a string is given
 *  to this function, it is first parsed into a markdown tree by calling
 *  [[parse]].
 **/
    expose.toHTMLTree = function toHTMLTree(input, dialect, options) {
      // convert string input to an MD tree
      if (typeof input === 'string')
        input = this.parse(input, dialect);
      // Now convert the MD tree to an HTML tree
      // remove references from the tree
      var attrs = extract_attr(input), refs = {};
      if (attrs && attrs.references) {
        refs = attrs.references;
      }
      var html = convert_tree_to_html(input, refs, options);
      merge_text_nodes(html);
      return html;
    };
    // For Spidermonkey based engines
    function mk_block_toSource() {
      return 'Markdown.mk_block( ' + uneval(this.toString()) + ', ' + uneval(this.trailing) + ', ' + uneval(this.lineNumber) + ' )';
    }
    // node
    function mk_block_inspect() {
      var util = require('util');
      return 'Markdown.mk_block( ' + util.inspect(this.toString()) + ', ' + util.inspect(this.trailing) + ', ' + util.inspect(this.lineNumber) + ' )';
    }
    var mk_block = Markdown.mk_block = function (block, trail, line) {
        // Be helpful for default case in tests.
        if (arguments.length == 1)
          trail = '\n\n';
        var s = new String(block);
        s.trailing = trail;
        // To make it clear its not just a string
        s.inspect = mk_block_inspect;
        s.toSource = mk_block_toSource;
        if (line != undefined)
          s.lineNumber = line;
        return s;
      };
    function count_lines(str) {
      var n = 0, i = -1;
      while ((i = str.indexOf('\n', i + 1)) !== -1)
        n++;
      return n;
    }
    // Internal - split source into rough blocks
    Markdown.prototype.split_blocks = function splitBlocks(input, startLine) {
      // [\s\S] matches _anything_ (newline or space)
      var re = /([\s\S]+?)($|\n(?:\s*\n|$)+)/g, blocks = [], m;
      var line_no = 1;
      if ((m = /^(\s*\n)/.exec(input)) != null) {
        // skip (but count) leading blank lines
        line_no += count_lines(m[0]);
        re.lastIndex = m[0].length;
      }
      while ((m = re.exec(input)) !== null) {
        blocks.push(mk_block(m[1], m[2], line_no));
        line_no += count_lines(m[0]);
      }
      return blocks;
    };
    /**
 *  Markdown#processBlock( block, next ) -> undefined | [ JsonML, ... ]
 *  - block (String): the block to process
 *  - next (Array): the following blocks
 *
 * Process `block` and return an array of JsonML nodes representing `block`.
 *
 * It does this by asking each block level function in the dialect to process
 * the block until one can. Succesful handling is indicated by returning an
 * array (with zero or more JsonML nodes), failure by a false value.
 *
 * Blocks handlers are responsible for calling [[Markdown#processInline]]
 * themselves as appropriate.
 *
 * If the blocks were split incorrectly or adjacent blocks need collapsing you
 * can adjust `next` in place using shift/splice etc.
 *
 * If any of this default behaviour is not right for the dialect, you can
 * define a `__call__` method on the dialect that will get invoked to handle
 * the block processing.
 */
    Markdown.prototype.processBlock = function processBlock(block, next) {
      var cbs = this.dialect.block, ord = cbs.__order__;
      if ('__call__' in cbs) {
        return cbs.__call__.call(this, block, next);
      }
      for (var i = 0; i < ord.length; i++) {
        //D:this.debug( "Testing", ord[i] );
        var res = cbs[ord[i]].call(this, block, next);
        if (res) {
          //D:this.debug("  matched");
          if (!isArray(res) || res.length > 0 && !isArray(res[0]))
            this.debug(ord[i], 'didn\'t return a proper array');
          //D:this.debug( "" );
          return res;
        }
      }
      // Uhoh! no match! Should we throw an error?
      return [];
    };
    Markdown.prototype.processInline = function processInline(block) {
      return this.dialect.inline.__call__.call(this, String(block));
    };
    /**
 *  Markdown#toTree( source ) -> JsonML
 *  - source (String): markdown source to parse
 *
 *  Parse `source` into a JsonML tree representing the markdown document.
 **/
    // custom_tree means set this.tree to `custom_tree` and restore old value on return
    Markdown.prototype.toTree = function toTree(source, custom_root) {
      var blocks = source instanceof Array ? source : this.split_blocks(source);
      // Make tree a member variable so its easier to mess with in extensions
      var old_tree = this.tree;
      try {
        this.tree = custom_root || this.tree || ['markdown'];
        blocks:
          while (blocks.length) {
            var b = this.processBlock(blocks.shift(), blocks);
            // Reference blocks and the like won't return any content
            if (!b.length)
              continue blocks;
            this.tree.push.apply(this.tree, b);
          }
        return this.tree;
      } finally {
        if (custom_root) {
          this.tree = old_tree;
        }
      }
    };
    // Noop by default
    Markdown.prototype.debug = function () {
      var args = Array.prototype.slice.call(arguments);
      args.unshift(this.debug_indent);
      if (typeof print !== 'undefined')
        print.apply(print, args);
      if (typeof console !== 'undefined' && typeof console.log !== 'undefined')
        console.log.apply(null, args);
    };
    Markdown.prototype.loop_re_over_block = function (re, block, cb) {
      // Dont use /g regexps with this
      var m, b = block.valueOf();
      while (b.length && (m = re.exec(b)) != null) {
        b = b.substr(m[0].length);
        cb.call(this, m);
      }
      return b;
    };
    /**
 * Markdown.dialects
 *
 * Namespace of built-in dialects.
 **/
    Markdown.dialects = {};
    /**
 * Markdown.dialects.Gruber
 *
 * The default dialect that follows the rules set out by John Gruber's
 * markdown.pl as closely as possible. Well actually we follow the behaviour of
 * that script which in some places is not exactly what the syntax web page
 * says.
 **/
    Markdown.dialects.Gruber = {
      block: {
        atxHeader: function atxHeader(block, next) {
          var m = block.match(/^(#{1,6})\s*(.*?)\s*#*\s*(?:\n|$)/);
          if (!m)
            return undefined;
          var header = [
              'header',
              { level: m[1].length }
            ];
          Array.prototype.push.apply(header, this.processInline(m[2]));
          if (m[0].length < block.length)
            next.unshift(mk_block(block.substr(m[0].length), block.trailing, block.lineNumber + 2));
          return [header];
        },
        setextHeader: function setextHeader(block, next) {
          var m = block.match(/^(.*)\n([-=])\2\2+(?:\n|$)/);
          if (!m)
            return undefined;
          var level = m[2] === '=' ? 1 : 2;
          var header = [
              'header',
              { level: level },
              m[1]
            ];
          if (m[0].length < block.length)
            next.unshift(mk_block(block.substr(m[0].length), block.trailing, block.lineNumber + 2));
          return [header];
        },
        code: function code(block, next) {
          // |    Foo
          // |bar
          // should be a code block followed by a paragraph. Fun
          //
          // There might also be adjacent code block to merge.
          var ret = [], re = /^(?: {0,3}\t| {4})(.*)\n?/, lines;
          // 4 spaces + content
          if (!block.match(re))
            return undefined;
          block_search:
            do {
              // Now pull out the rest of the lines
              var b = this.loop_re_over_block(re, block.valueOf(), function (m) {
                  ret.push(m[1]);
                });
              if (b.length) {
                // Case alluded to in first comment. push it back on as a new block
                next.unshift(mk_block(b, block.trailing));
                break block_search;
              } else if (next.length) {
                // Check the next block - it might be code too
                if (!next[0].match(re))
                  break block_search;
                // Pull how how many blanks lines follow - minus two to account for .join
                ret.push(block.trailing.replace(/[^\n]/g, '').substring(2));
                block = next.shift();
              } else {
                break block_search;
              }
            } while (true);
          return [[
              'code_block',
              ret.join('\n')
            ]];
        },
        horizRule: function horizRule(block, next) {
          // this needs to find any hr in the block to handle abutting blocks
          var m = block.match(/^(?:([\s\S]*?)\n)?[ \t]*([-_*])(?:[ \t]*\2){2,}[ \t]*(?:\n([\s\S]*))?$/);
          if (!m) {
            return undefined;
          }
          var jsonml = [['hr']];
          // if there's a leading abutting block, process it
          if (m[1]) {
            jsonml.unshift.apply(jsonml, this.processBlock(m[1], []));
          }
          // if there's a trailing abutting block, stick it into next
          if (m[3]) {
            next.unshift(mk_block(m[3]));
          }
          return jsonml;
        },
        lists: function () {
          // Use a closure to hide a few variables.
          var any_list = '[*+-]|\\d+\\.', bullet_list = /[*+-]/, number_list = /\d+\./,
            // Capture leading indent as it matters for determining nested lists.
            is_list_re = new RegExp('^( {0,3})(' + any_list + ')[ \t]+'), indent_re = '(?: {0,3}\\t| {4})';
          // TODO: Cache this regexp for certain depths.
          // Create a regexp suitable for matching an li for a given stack depth
          function regex_for_depth(depth) {
            return new RegExp('(?:^(' + indent_re + '{0,' + depth + '} {0,3})(' + any_list + ')\\s+)|' + '(^' + indent_re + '{0,' + (depth - 1) + '}[ ]{0,4})');
          }
          function expand_tab(input) {
            return input.replace(/ {0,3}\t/g, '    ');
          }
          // Add inline content `inline` to `li`. inline comes from processInline
          // so is an array of content
          function add(li, loose, inline, nl) {
            if (loose) {
              li.push(['para'].concat(inline));
              return;
            }
            // Hmmm, should this be any block level element or just paras?
            var add_to = li[li.length - 1] instanceof Array && li[li.length - 1][0] == 'para' ? li[li.length - 1] : li;
            // If there is already some content in this list, add the new line in
            if (nl && li.length > 1)
              inline.unshift(nl);
            for (var i = 0; i < inline.length; i++) {
              var what = inline[i], is_str = typeof what == 'string';
              if (is_str && add_to.length > 1 && typeof add_to[add_to.length - 1] == 'string') {
                add_to[add_to.length - 1] += what;
              } else {
                add_to.push(what);
              }
            }
          }
          // contained means have an indent greater than the current one. On
          // *every* line in the block
          function get_contained_blocks(depth, blocks) {
            var re = new RegExp('^(' + indent_re + '{' + depth + '}.*?\\n?)*$'), replace = new RegExp('^' + indent_re + '{' + depth + '}', 'gm'), ret = [];
            while (blocks.length > 0) {
              if (re.exec(blocks[0])) {
                var b = blocks.shift(),
                  // Now remove that indent
                  x = b.replace(replace, '');
                ret.push(mk_block(x, b.trailing, b.lineNumber));
              }
              break;
            }
            return ret;
          }
          // passed to stack.forEach to turn list items up the stack into paras
          function paragraphify(s, i, stack) {
            var list = s.list;
            var last_li = list[list.length - 1];
            if (last_li[1] instanceof Array && last_li[1][0] == 'para') {
              return;
            }
            if (i + 1 == stack.length) {
              // Last stack frame
              // Keep the same array, but replace the contents
              last_li.push(['para'].concat(last_li.splice(1)));
            } else {
              var sublist = last_li.pop();
              last_li.push(['para'].concat(last_li.splice(1)), sublist);
            }
          }
          // The matcher function
          return function (block, next) {
            var m = block.match(is_list_re);
            if (!m)
              return undefined;
            function make_list(m) {
              var list = bullet_list.exec(m[2]) ? ['bulletlist'] : ['numberlist'];
              stack.push({
                list: list,
                indent: m[1]
              });
              return list;
            }
            var stack = [],
              // Stack of lists for nesting.
              list = make_list(m), last_li, loose = false, ret = [stack[0].list], i;
            // Loop to search over block looking for inner block elements and loose lists
            loose_search:
              while (true) {
                // Split into lines preserving new lines at end of line
                var lines = block.split(/(?=\n)/);
                // We have to grab all lines for a li and call processInline on them
                // once as there are some inline things that can span lines.
                var li_accumulate = '';
                // Loop over the lines in this block looking for tight lists.
                tight_search:
                  for (var line_no = 0; line_no < lines.length; line_no++) {
                    var nl = '', l = lines[line_no].replace(/^\n/, function (n) {
                        nl = n;
                        return '';
                      });
                    // TODO: really should cache this
                    var line_re = regex_for_depth(stack.length);
                    m = l.match(line_re);
                    //print( "line:", uneval(l), "\nline match:", uneval(m) );
                    // We have a list item
                    if (m[1] !== undefined) {
                      // Process the previous list item, if any
                      if (li_accumulate.length) {
                        add(last_li, loose, this.processInline(li_accumulate), nl);
                        // Loose mode will have been dealt with. Reset it
                        loose = false;
                        li_accumulate = '';
                      }
                      m[1] = expand_tab(m[1]);
                      var wanted_depth = Math.floor(m[1].length / 4) + 1;
                      //print( "want:", wanted_depth, "stack:", stack.length);
                      if (wanted_depth > stack.length) {
                        // Deep enough for a nested list outright
                        //print ( "new nested list" );
                        list = make_list(m);
                        last_li.push(list);
                        last_li = list[1] = ['listitem'];
                      } else {
                        // We aren't deep enough to be strictly a new level. This is
                        // where Md.pl goes nuts. If the indent matches a level in the
                        // stack, put it there, else put it one deeper then the
                        // wanted_depth deserves.
                        var found = false;
                        for (i = 0; i < stack.length; i++) {
                          if (stack[i].indent != m[1])
                            continue;
                          list = stack[i].list;
                          stack.splice(i + 1);
                          found = true;
                          break;
                        }
                        if (!found) {
                          //print("not found. l:", uneval(l));
                          wanted_depth++;
                          if (wanted_depth <= stack.length) {
                            stack.splice(wanted_depth);
                            //print("Desired depth now", wanted_depth, "stack:", stack.length);
                            list = stack[wanted_depth - 1].list;  //print("list:", uneval(list) );
                          } else {
                            //print ("made new stack for messy indent");
                            list = make_list(m);
                            last_li.push(list);
                          }
                        }
                        //print( uneval(list), "last", list === stack[stack.length-1].list );
                        last_li = ['listitem'];
                        list.push(last_li);
                      }
                      // end depth of shenegains
                      nl = '';
                    }
                    // Add content
                    if (l.length > m[0].length) {
                      li_accumulate += nl + l.substr(m[0].length);
                    }
                  }
                // tight_search
                if (li_accumulate.length) {
                  add(last_li, loose, this.processInline(li_accumulate), nl);
                  // Loose mode will have been dealt with. Reset it
                  loose = false;
                  li_accumulate = '';
                }
                // Look at the next block - we might have a loose list. Or an extra
                // paragraph for the current li
                var contained = get_contained_blocks(stack.length, next);
                // Deal with code blocks or properly nested lists
                if (contained.length > 0) {
                  // Make sure all listitems up the stack are paragraphs
                  forEach(stack, paragraphify, this);
                  last_li.push.apply(last_li, this.toTree(contained, []));
                }
                var next_block = next[0] && next[0].valueOf() || '';
                if (next_block.match(is_list_re) || next_block.match(/^ /)) {
                  block = next.shift();
                  // Check for an HR following a list: features/lists/hr_abutting
                  var hr = this.dialect.block.horizRule(block, next);
                  if (hr) {
                    ret.push.apply(ret, hr);
                    break;
                  }
                  // Make sure all listitems up the stack are paragraphs
                  forEach(stack, paragraphify, this);
                  loose = true;
                  continue loose_search;
                }
                break;
              }
            // loose_search
            return ret;
          };
        }(),
        blockquote: function blockquote(block, next) {
          if (!block.match(/^>/m))
            return undefined;
          var jsonml = [];
          // separate out the leading abutting block, if any
          if (block[0] != '>') {
            var lines = block.split(/\n/), prev = [];
            // keep shifting lines until you find a crotchet
            while (lines.length && lines[0][0] != '>') {
              prev.push(lines.shift());
            }
            // reassemble!
            block = lines.join('\n');
            jsonml.push.apply(jsonml, this.processBlock(prev.join('\n'), []));
          }
          // if the next block is also a blockquote merge it in
          while (next.length && next[0][0] == '>') {
            var b = next.shift();
            block = new String(block + block.trailing + b);
            block.trailing = b.trailing;
          }
          // Strip off the leading "> " and re-process as a block.
          var input = block.replace(/^> ?/gm, ''), old_tree = this.tree;
          jsonml.push(this.toTree(input, ['blockquote']));
          return jsonml;
        },
        referenceDefn: function referenceDefn(block, next) {
          var re = /^\s*\[(.*?)\]:\s*(\S+)(?:\s+(?:(['"])(.*?)\3|\((.*?)\)))?\n?/;
          // interesting matches are [ , ref_id, url, , title, title ]
          if (!block.match(re))
            return undefined;
          // make an attribute node if it doesn't exist
          if (!extract_attr(this.tree)) {
            this.tree.splice(1, 0, {});
          }
          var attrs = extract_attr(this.tree);
          // make a references hash if it doesn't exist
          if (attrs.references === undefined) {
            attrs.references = {};
          }
          var b = this.loop_re_over_block(re, block, function (m) {
              if (m[2] && m[2][0] == '<' && m[2][m[2].length - 1] == '>')
                m[2] = m[2].substring(1, m[2].length - 1);
              var ref = attrs.references[m[1].toLowerCase()] = { href: m[2] };
              if (m[4] !== undefined)
                ref.title = m[4];
              else if (m[5] !== undefined)
                ref.title = m[5];
            });
          if (b.length)
            next.unshift(mk_block(b, block.trailing));
          return [];
        },
        para: function para(block, next) {
          // everything's a para!
          return [['para'].concat(this.processInline(block))];
        }
      }
    };
    Markdown.dialects.Gruber.inline = {
      __oneElement__: function oneElement(text, patterns_or_re, previous_nodes) {
        var m, res, lastIndex = 0;
        patterns_or_re = patterns_or_re || this.dialect.inline.__patterns__;
        var re = new RegExp('([\\s\\S]*?)(' + (patterns_or_re.source || patterns_or_re) + ')');
        m = re.exec(text);
        if (!m) {
          // Just boring text
          return [
            text.length,
            text
          ];
        } else if (m[1]) {
          // Some un-interesting text matched. Return that first
          return [
            m[1].length,
            m[1]
          ];
        }
        var res;
        if (m[2] in this.dialect.inline) {
          res = this.dialect.inline[m[2]].call(this, text.substr(m.index), m, previous_nodes || []);
        }
        // Default for now to make dev easier. just slurp special and output it.
        res = res || [
          m[2].length,
          m[2]
        ];
        return res;
      },
      __call__: function inline(text, patterns) {
        var out = [], res;
        function add(x) {
          //D:self.debug("  adding output", uneval(x));
          if (typeof x == 'string' && typeof out[out.length - 1] == 'string')
            out[out.length - 1] += x;
          else
            out.push(x);
        }
        while (text.length > 0) {
          res = this.dialect.inline.__oneElement__.call(this, text, patterns, out);
          text = text.substr(res.shift());
          forEach(res, add);
        }
        return out;
      },
      ']': function () {
      },
      '}': function () {
      },
      '\\': function escaped(text) {
        // [ length of input processed, node/children to add... ]
        // Only esacape: \ ` * _ { } [ ] ( ) # * + - . !
        if (text.match(/^\\[\\`\*_{}\[\]()#\+.!\-]/))
          return [
            2,
            text[1]
          ];
        else
          // Not an esacpe
          return [
            1,
            '\\'
          ];
      },
      '![': function image(text) {
        // Unlike images, alt text is plain text only. no other elements are
        // allowed in there
        // ![Alt text](/path/to/img.jpg "Optional title")
        //      1          2            3       4         <--- captures
        var m = text.match(/^!\[(.*?)\][ \t]*\([ \t]*(\S*)(?:[ \t]+(["'])(.*?)\3)?[ \t]*\)/);
        if (m) {
          if (m[2] && m[2][0] == '<' && m[2][m[2].length - 1] == '>')
            m[2] = m[2].substring(1, m[2].length - 1);
          m[2] = this.dialect.inline.__call__.call(this, m[2], /\\/)[0];
          var attrs = {
              alt: m[1],
              href: m[2] || ''
            };
          if (m[4] !== undefined)
            attrs.title = m[4];
          return [
            m[0].length,
            [
              'img',
              attrs
            ]
          ];
        }
        // ![Alt text][id]
        m = text.match(/^!\[(.*?)\][ \t]*\[(.*?)\]/);
        if (m) {
          // We can't check if the reference is known here as it likely wont be
          // found till after. Check it in md tree->hmtl tree conversion
          return [
            m[0].length,
            [
              'img_ref',
              {
                alt: m[1],
                ref: m[2].toLowerCase(),
                original: m[0]
              }
            ]
          ];
        }
        // Just consume the '!['
        return [
          2,
          '!['
        ];
      },
      '[': function link(text) {
        var orig = String(text);
        // Inline content is possible inside `link text`
        var res = Markdown.DialectHelpers.inline_until_char.call(this, text.substr(1), ']');
        // No closing ']' found. Just consume the [
        if (!res)
          return [
            1,
            '['
          ];
        var consumed = 1 + res[0], children = res[1], link, attrs;
        // At this point the first [...] has been parsed. See what follows to find
        // out which kind of link we are (reference or direct url)
        text = text.substr(consumed);
        // [link text](/path/to/img.jpg "Optional title")
        //                 1            2       3         <--- captures
        // This will capture up to the last paren in the block. We then pull
        // back based on if there a matching ones in the url
        //    ([here](/url/(test))
        // The parens have to be balanced
        var m = text.match(/^\s*\([ \t]*(\S+)(?:[ \t]+(["'])(.*?)\2)?[ \t]*\)/);
        if (m) {
          var url = m[1];
          consumed += m[0].length;
          if (url && url[0] == '<' && url[url.length - 1] == '>')
            url = url.substring(1, url.length - 1);
          // If there is a title we don't have to worry about parens in the url
          if (!m[3]) {
            var open_parens = 1;
            // One open that isn't in the capture
            for (var len = 0; len < url.length; len++) {
              switch (url[len]) {
              case '(':
                open_parens++;
                break;
              case ')':
                if (--open_parens == 0) {
                  consumed -= url.length - len;
                  url = url.substring(0, len);
                }
                break;
              }
            }
          }
          // Process escapes only
          url = this.dialect.inline.__call__.call(this, url, /\\/)[0];
          attrs = { href: url || '' };
          if (m[3] !== undefined)
            attrs.title = m[3];
          link = [
            'link',
            attrs
          ].concat(children);
          return [
            consumed,
            link
          ];
        }
        // [Alt text][id]
        // [Alt text] [id]
        m = text.match(/^\s*\[(.*?)\]/);
        if (m) {
          consumed += m[0].length;
          // [links][] uses links as its reference
          attrs = {
            ref: (m[1] || String(children)).toLowerCase(),
            original: orig.substr(0, consumed)
          };
          link = [
            'link_ref',
            attrs
          ].concat(children);
          // We can't check if the reference is known here as it likely wont be
          // found till after. Check it in md tree->hmtl tree conversion.
          // Store the original so that conversion can revert if the ref isn't found.
          return [
            consumed,
            link
          ];
        }
        // [id]
        // Only if id is plain (no formatting.)
        if (children.length == 1 && typeof children[0] == 'string') {
          attrs = {
            ref: children[0].toLowerCase(),
            original: orig.substr(0, consumed)
          };
          link = [
            'link_ref',
            attrs,
            children[0]
          ];
          return [
            consumed,
            link
          ];
        }
        // Just consume the '['
        return [
          1,
          '['
        ];
      },
      '<': function autoLink(text) {
        var m;
        if ((m = text.match(/^<(?:((https?|ftp|mailto):[^>]+)|(.*?@.*?\.[a-zA-Z]+))>/)) != null) {
          if (m[3]) {
            return [
              m[0].length,
              [
                'link',
                { href: 'mailto:' + m[3] },
                m[3]
              ]
            ];
          } else if (m[2] == 'mailto') {
            return [
              m[0].length,
              [
                'link',
                { href: m[1] },
                m[1].substr('mailto:'.length)
              ]
            ];
          } else
            return [
              m[0].length,
              [
                'link',
                { href: m[1] },
                m[1]
              ]
            ];
        }
        return [
          1,
          '<'
        ];
      },
      '`': function inlineCode(text) {
        // Inline code block. as many backticks as you like to start it
        // Always skip over the opening ticks.
        var m = text.match(/(`+)(([\s\S]*?)\1)/);
        if (m && m[2])
          return [
            m[1].length + m[2].length,
            [
              'inlinecode',
              m[3]
            ]
          ];
        else {
          // TODO: No matching end code found - warn!
          return [
            1,
            '`'
          ];
        }
      },
      '  \n': function lineBreak(text) {
        return [
          3,
          ['linebreak']
        ];
      }
    };
    // Meta Helper/generator method for em and strong handling
    function strong_em(tag, md) {
      var state_slot = tag + '_state', other_slot = tag == 'strong' ? 'em_state' : 'strong_state';
      function CloseTag(len) {
        this.len_after = len;
        this.name = 'close_' + md;
      }
      return function (text, orig_match) {
        if (this[state_slot][0] == md) {
          // Most recent em is of this type
          //D:this.debug("closing", md);
          this[state_slot].shift();
          // "Consume" everything to go back to the recrusion in the else-block below
          return [
            text.length,
            new CloseTag(text.length - md.length)
          ];
        } else {
          // Store a clone of the em/strong states
          var other = this[other_slot].slice(), state = this[state_slot].slice();
          this[state_slot].unshift(md);
          //D:this.debug_indent += "  ";
          // Recurse
          var res = this.processInline(text.substr(md.length));
          //D:this.debug_indent = this.debug_indent.substr(2);
          var last = res[res.length - 1];
          //D:this.debug("processInline from", tag + ": ", uneval( res ) );
          var check = this[state_slot].shift();
          if (last instanceof CloseTag) {
            res.pop();
            // We matched! Huzzah.
            var consumed = text.length - last.len_after;
            return [
              consumed,
              [tag].concat(res)
            ];
          } else {
            // Restore the state of the other kind. We might have mistakenly closed it.
            this[other_slot] = other;
            this[state_slot] = state;
            // We can't reuse the processed result as it could have wrong parsing contexts in it.
            return [
              md.length,
              md
            ];
          }
        }
      };  // End returned function
    }
    Markdown.dialects.Gruber.inline['**'] = strong_em('strong', '**');
    Markdown.dialects.Gruber.inline['__'] = strong_em('strong', '__');
    Markdown.dialects.Gruber.inline['*'] = strong_em('em', '*');
    Markdown.dialects.Gruber.inline['_'] = strong_em('em', '_');
    // Build default order from insertion order.
    Markdown.buildBlockOrder = function (d) {
      var ord = [];
      for (var i in d) {
        if (i == '__order__' || i == '__call__')
          continue;
        ord.push(i);
      }
      d.__order__ = ord;
    };
    // Build patterns for inline matcher
    Markdown.buildInlinePatterns = function (d) {
      var patterns = [];
      for (var i in d) {
        // __foo__ is reserved and not a pattern
        if (i.match(/^__.*__$/))
          continue;
        var l = i.replace(/([\\.*+?|()\[\]{}])/g, '\\$1').replace(/\n/, '\\n');
        patterns.push(i.length == 1 ? l : '(?:' + l + ')');
      }
      patterns = patterns.join('|');
      d.__patterns__ = patterns;
      //print("patterns:", uneval( patterns ) );
      var fn = d.__call__;
      d.__call__ = function (text, pattern) {
        if (pattern != undefined) {
          return fn.call(this, text, pattern);
        } else {
          return fn.call(this, text, patterns);
        }
      };
    };
    Markdown.DialectHelpers = {};
    Markdown.DialectHelpers.inline_until_char = function (text, want) {
      var consumed = 0, nodes = [];
      while (true) {
        if (text[consumed] == want) {
          // Found the character we were looking for
          consumed++;
          return [
            consumed,
            nodes
          ];
        }
        if (consumed >= text.length) {
          // No closing char found. Abort.
          return null;
        }
        res = this.dialect.inline.__oneElement__.call(this, text.substr(consumed));
        consumed += res[0];
        // Add any returned nodes.
        nodes.push.apply(nodes, res.slice(1));
      }
    };
    // Helper function to make sub-classing a dialect easier
    Markdown.subclassDialect = function (d) {
      function Block() {
      }
      Block.prototype = d.block;
      function Inline() {
      }
      Inline.prototype = d.inline;
      return {
        block: new Block(),
        inline: new Inline()
      };
    };
    Markdown.buildBlockOrder(Markdown.dialects.Gruber.block);
    Markdown.buildInlinePatterns(Markdown.dialects.Gruber.inline);
    Markdown.dialects.Maruku = Markdown.subclassDialect(Markdown.dialects.Gruber);
    Markdown.dialects.Maruku.processMetaHash = function processMetaHash(meta_string) {
      var meta = split_meta_hash(meta_string), attr = {};
      for (var i = 0; i < meta.length; ++i) {
        // id: #foo
        if (/^#/.test(meta[i])) {
          attr.id = meta[i].substring(1);
        }  // class: .foo
        else if (/^\./.test(meta[i])) {
          // if class already exists, append the new one
          if (attr['class']) {
            attr['class'] = attr['class'] + meta[i].replace(/./, ' ');
          } else {
            attr['class'] = meta[i].substring(1);
          }
        }  // attribute: foo=bar
        else if (/\=/.test(meta[i])) {
          var s = meta[i].split(/\=/);
          attr[s[0]] = s[1];
        }
      }
      return attr;
    };
    function split_meta_hash(meta_string) {
      var meta = meta_string.split(''), parts = [''], in_quotes = false;
      while (meta.length) {
        var letter = meta.shift();
        switch (letter) {
        case ' ':
          // if we're in a quoted section, keep it
          if (in_quotes) {
            parts[parts.length - 1] += letter;
          }  // otherwise make a new part
          else {
            parts.push('');
          }
          break;
        case '\'':
        case '"':
          // reverse the quotes and move straight on
          in_quotes = !in_quotes;
          break;
        case '\\':
          // shift off the next letter to be used straight away.
          // it was escaped so we'll keep it whatever it is
          letter = meta.shift();
        default:
          parts[parts.length - 1] += letter;
          break;
        }
      }
      return parts;
    }
    Markdown.dialects.Maruku.block.document_meta = function document_meta(block, next) {
      // we're only interested in the first block
      if (block.lineNumber > 1)
        return undefined;
      // document_meta blocks consist of one or more lines of `Key: Value\n`
      if (!block.match(/^(?:\w+:.*\n)*\w+:.*$/))
        return undefined;
      // make an attribute node if it doesn't exist
      if (!extract_attr(this.tree)) {
        this.tree.splice(1, 0, {});
      }
      var pairs = block.split(/\n/);
      for (p in pairs) {
        var m = pairs[p].match(/(\w+):\s*(.*)$/), key = m[1].toLowerCase(), value = m[2];
        this.tree[1][key] = value;
      }
      // document_meta produces no content!
      return [];
    };
    Markdown.dialects.Maruku.block.block_meta = function block_meta(block, next) {
      // check if the last line of the block is an meta hash
      var m = block.match(/(^|\n) {0,3}\{:\s*((?:\\\}|[^\}])*)\s*\}$/);
      if (!m)
        return undefined;
      // process the meta hash
      var attr = this.dialect.processMetaHash(m[2]);
      var hash;
      // if we matched ^ then we need to apply meta to the previous block
      if (m[1] === '') {
        var node = this.tree[this.tree.length - 1];
        hash = extract_attr(node);
        // if the node is a string (rather than JsonML), bail
        if (typeof node === 'string')
          return undefined;
        // create the attribute hash if it doesn't exist
        if (!hash) {
          hash = {};
          node.splice(1, 0, hash);
        }
        // add the attributes in
        for (a in attr) {
          hash[a] = attr[a];
        }
        // return nothing so the meta hash is removed
        return [];
      }
      // pull the meta hash off the block and process what's left
      var b = block.replace(/\n.*$/, ''), result = this.processBlock(b, []);
      // get or make the attributes hash
      hash = extract_attr(result[0]);
      if (!hash) {
        hash = {};
        result[0].splice(1, 0, hash);
      }
      // attach the attributes to the block
      for (a in attr) {
        hash[a] = attr[a];
      }
      return result;
    };
    Markdown.dialects.Maruku.block.definition_list = function definition_list(block, next) {
      // one or more terms followed by one or more definitions, in a single block
      var tight = /^((?:[^\s:].*\n)+):\s+([\s\S]+)$/, list = ['dl'], i;
      // see if we're dealing with a tight or loose block
      if (m = block.match(tight)) {
        // pull subsequent tight DL blocks out of `next`
        var blocks = [block];
        while (next.length && tight.exec(next[0])) {
          blocks.push(next.shift());
        }
        for (var b = 0; b < blocks.length; ++b) {
          var m = blocks[b].match(tight), terms = m[1].replace(/\n$/, '').split(/\n/), defns = m[2].split(/\n:\s+/);
          // print( uneval( m ) );
          for (i = 0; i < terms.length; ++i) {
            list.push([
              'dt',
              terms[i]
            ]);
          }
          for (i = 0; i < defns.length; ++i) {
            // run inline processing over the definition
            list.push(['dd'].concat(this.processInline(defns[i].replace(/(\n)\s+/, '$1'))));
          }
        }
      } else {
        return undefined;
      }
      return [list];
    };
    Markdown.dialects.Maruku.inline['{:'] = function inline_meta(text, matches, out) {
      if (!out.length) {
        return [
          2,
          '{:'
        ];
      }
      // get the preceeding element
      var before = out[out.length - 1];
      if (typeof before === 'string') {
        return [
          2,
          '{:'
        ];
      }
      // match a meta hash
      var m = text.match(/^\{:\s*((?:\\\}|[^\}])*)\s*\}/);
      // no match, false alarm
      if (!m) {
        return [
          2,
          '{:'
        ];
      }
      // attach the attributes to the preceeding element
      var meta = this.dialect.processMetaHash(m[1]), attr = extract_attr(before);
      if (!attr) {
        attr = {};
        before.splice(1, 0, attr);
      }
      for (var k in meta) {
        attr[k] = meta[k];
      }
      // cut out the string and replace it with nothing
      return [
        m[0].length,
        ''
      ];
    };
    Markdown.buildBlockOrder(Markdown.dialects.Maruku.block);
    Markdown.buildInlinePatterns(Markdown.dialects.Maruku.inline);
    var isArray = Array.isArray || function (obj) {
        return Object.prototype.toString.call(obj) == '[object Array]';
      };
    var forEach;
    // Don't mess with Array.prototype. Its not friendly
    if (Array.prototype.forEach) {
      forEach = function (arr, cb, thisp) {
        return arr.forEach(cb, thisp);
      };
    } else {
      forEach = function (arr, cb, thisp) {
        for (var i = 0; i < arr.length; i++) {
          cb.call(thisp || arr, arr[i], i, arr);
        }
      };
    }
    function extract_attr(jsonml) {
      return isArray(jsonml) && jsonml.length > 1 && typeof jsonml[1] === 'object' && !isArray(jsonml[1]) ? jsonml[1] : undefined;
    }
    /**
 *  renderJsonML( jsonml[, options] ) -> String
 *  - jsonml (Array): JsonML array to render to XML
 *  - options (Object): options
 *
 *  Converts the given JsonML into well-formed XML.
 *
 *  The options currently understood are:
 *
 *  - root (Boolean): wether or not the root node should be included in the
 *    output, or just its children. The default `false` is to not include the
 *    root itself.
 */
    expose.renderJsonML = function (jsonml, options) {
      options = options || {};
      // include the root element in the rendered output?
      options.root = options.root || false;
      var content = [];
      if (options.root) {
        content.push(render_tree(jsonml));
      } else {
        jsonml.shift();
        // get rid of the tag
        if (jsonml.length && typeof jsonml[0] === 'object' && !(jsonml[0] instanceof Array)) {
          jsonml.shift();  // get rid of the attributes
        }
        while (jsonml.length) {
          content.push(render_tree(jsonml.shift()));
        }
      }
      return content.join('\n\n');
    };
    function escapeHTML(text) {
      return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#39;');
    }
    function render_tree(jsonml) {
      // basic case
      if (typeof jsonml === 'string') {
        return escapeHTML(jsonml);
      }
      var tag = jsonml.shift(), attributes = {}, content = [];
      if (jsonml.length && typeof jsonml[0] === 'object' && !(jsonml[0] instanceof Array)) {
        attributes = jsonml.shift();
      }
      while (jsonml.length) {
        content.push(arguments.callee(jsonml.shift()));
      }
      var tag_attrs = '';
      for (var a in attributes) {
        tag_attrs += ' ' + a + '="' + escapeHTML(attributes[a]) + '"';
      }
      // be careful about adding whitespace here for inline elements
      if (tag == 'img' || tag == 'br' || tag == 'hr') {
        return '<' + tag + tag_attrs + '/>';
      } else {
        return '<' + tag + tag_attrs + '>' + content.join('') + '</' + tag + '>';
      }
    }
    function convert_tree_to_html(tree, references, options) {
      var i;
      options = options || {};
      // shallow clone
      var jsonml = tree.slice(0);
      if (typeof options.preprocessTreeNode === 'function') {
        jsonml = options.preprocessTreeNode(jsonml, references);
      }
      // Clone attributes if they exist
      var attrs = extract_attr(jsonml);
      if (attrs) {
        jsonml[1] = {};
        for (i in attrs) {
          jsonml[1][i] = attrs[i];
        }
        attrs = jsonml[1];
      }
      // basic case
      if (typeof jsonml === 'string') {
        return jsonml;
      }
      // convert this node
      switch (jsonml[0]) {
      case 'header':
        jsonml[0] = 'h' + jsonml[1].level;
        delete jsonml[1].level;
        break;
      case 'bulletlist':
        jsonml[0] = 'ul';
        break;
      case 'numberlist':
        jsonml[0] = 'ol';
        break;
      case 'listitem':
        jsonml[0] = 'li';
        break;
      case 'para':
        jsonml[0] = 'p';
        break;
      case 'markdown':
        jsonml[0] = 'html';
        if (attrs)
          delete attrs.references;
        break;
      case 'code_block':
        jsonml[0] = 'pre';
        i = attrs ? 2 : 1;
        var code = ['code'];
        code.push.apply(code, jsonml.splice(i));
        jsonml[i] = code;
        break;
      case 'inlinecode':
        jsonml[0] = 'code';
        break;
      case 'img':
        jsonml[1].src = jsonml[1].href;
        delete jsonml[1].href;
        break;
      case 'linebreak':
        jsonml[0] = 'br';
        break;
      case 'link':
        jsonml[0] = 'a';
        break;
      case 'link_ref':
        jsonml[0] = 'a';
        // grab this ref and clean up the attribute node
        var ref = references[attrs.ref];
        // if the reference exists, make the link
        if (ref) {
          delete attrs.ref;
          // add in the href and title, if present
          attrs.href = ref.href;
          if (ref.title) {
            attrs.title = ref.title;
          }
          // get rid of the unneeded original text
          delete attrs.original;
        }  // the reference doesn't exist, so revert to plain text
        else {
          return attrs.original;
        }
        break;
      case 'img_ref':
        jsonml[0] = 'img';
        // grab this ref and clean up the attribute node
        var ref = references[attrs.ref];
        // if the reference exists, make the link
        if (ref) {
          delete attrs.ref;
          // add in the href and title, if present
          attrs.src = ref.href;
          if (ref.title) {
            attrs.title = ref.title;
          }
          // get rid of the unneeded original text
          delete attrs.original;
        }  // the reference doesn't exist, so revert to plain text
        else {
          return attrs.original;
        }
        break;
      }
      // convert all the children
      i = 1;
      // deal with the attribute node, if it exists
      if (attrs) {
        // if there are keys, skip over it
        for (var key in jsonml[1]) {
          i = 2;
        }
        // if there aren't, remove it
        if (i === 1) {
          jsonml.splice(i, 1);
        }
      }
      for (; i < jsonml.length; ++i) {
        jsonml[i] = arguments.callee(jsonml[i], references, options);
      }
      return jsonml;
    }
    // merges adjacent text nodes into a single node
    function merge_text_nodes(jsonml) {
      // skip the tag name and attribute hash
      var i = extract_attr(jsonml) ? 2 : 1;
      while (i < jsonml.length) {
        // if it's a string check the next item too
        if (typeof jsonml[i] === 'string') {
          if (i + 1 < jsonml.length && typeof jsonml[i + 1] === 'string') {
            // merge the second string into the first and remove it
            jsonml[i] += jsonml.splice(i + 1, 1)[0];
          } else {
            ++i;
          }
        }  // if it's not a string recurse
        else {
          arguments.callee(jsonml[i]);
          ++i;
        }
      }
    }
  })(function () {
    if (typeof exports === 'undefined') {
      window.markdown = {};
      return window.markdown;
    } else {
      return exports;
    }
  }());